/**
 * @name js-row-num
 * @fileoverview Update all row numbers in all console.logs in JS code
 * @version 5.0.1
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/js-row-num/}
 */

!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r((e="undefined"!=typeof globalThis?globalThis:e||self).jsRowNum={})}(this,(function(e){"use strict";
/**
 * @name string-collapse-leading-whitespace
 * @fileoverview Collapse the leading and trailing whitespace of a string
 * @version 6.0.1
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-collapse-leading-whitespace/}
 */function r(e,r=1){function t(e){return Array.from(e).reverse().join("")}function n(e,r,t){const n=t?"\n":"\r",s=t?"\r":"\n";if(!e)return e;let i=0,o="";for(let t=0,a=e.length;t<a;t++)(e[t]===n||e[t]===s&&e[t-1]!==n)&&i++,"\r\n".includes(e[t])||" "===e[t]?" "===e[t]?o+=e[t]:e[t]===n?i<=r&&(o+=e[t],e[t+1]===s&&(o+=e[t+1],t++)):e[t]===s&&(!e[t-1]||e[t-1]!==n)&&i<=r&&(o+=e[t]):e[t+1]||i||(o+=" ");return o}if("string"==typeof e&&e.length){let s=1;"number"==typeof+r&&Number.isInteger(+r)&&+r>=0&&(s=+r);let i="",o="";if(e.trim()){if(!e[0].trim())for(let r=0,t=e.length;r<t;r++)if(e[r].trim()){i=e.slice(0,r);break}}else i=e;if(e.trim()&&(""===e.slice(-1).trim()||" "===e.slice(-1)))for(let r=e.length;r--;)if(e[r].trim()){o=e.slice(r+1);break}return`${n(i,s,!1)}${e.trim()}${t(n(t(o),s,!0))}`}return e}
/**
 * @name ranges-push
 * @fileoverview Gather string index ranges
 * @version 6.0.1
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-push/}
 */const t={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function n(e,r){if(!Array.isArray(e)||!e.length)return e;const n={...t,...r};let s,i;if(n.strictlyTwoElementsInRangeArrays&&!e.filter((e=>e)).every(((e,r)=>2===e.length||(s=r,i=e.length,!1))))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${s}th range (${JSON.stringify(e[s],null,4)}) has not two but ${i} elements!`);if(!e.filter((e=>e)).every(((e,r)=>!(!Number.isInteger(e[0])||e[0]<0||!Number.isInteger(e[1])||e[1]<0)||(s=r,!1))))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${s}th range (${JSON.stringify(e[s],null,4)}) does not consist of only natural numbers!`);const o=e.filter((e=>e)).length**2;let a=0;return Array.from(e).filter((e=>e)).sort(((e,r)=>(n.progressFn&&(a+=1,n.progressFn(Math.floor(100*a/o))),e[0]===r[0]?e[1]<r[1]?-1:e[1]>r[1]?1:0:e[0]<r[0]?-1:1)))}const s={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function i(e){return null!=e}function o(e){return Number.isInteger(e)&&e>=0}function a(e){return"string"==typeof e}const l={limitToBeAddedWhitespace:!1,limitLinebreaksCount:1,mergeType:1};class g{constructor(e){const r={...l,...e};if(r.mergeType&&1!==r.mergeType&&2!==r.mergeType)if(a(r.mergeType)&&"1"===r.mergeType.trim())r.mergeType=1;else{if(!a(r.mergeType)||"2"!==r.mergeType.trim())throw new Error(`ranges-push: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof r.mergeType}", equal to ${JSON.stringify(r.mergeType,null,4)}`);r.mergeType=2}this.opts=r,this.ranges=[]}ranges;opts;add(e,t,n){if(null==e&&null==t)return;if(i(e)&&!i(t)){if(Array.isArray(e)){if(e.length){if(e.some((e=>Array.isArray(e))))return void e.forEach((e=>{Array.isArray(e)&&this.add(...e)}));e.length&&o(+e[0])&&o(+e[1])&&this.add(...e)}return}throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_12] the first input argument, "from" is set (${JSON.stringify(e,null,0)}) but second-one, "to" is not (${JSON.stringify(t,null,0)})`)}if(!i(e)&&i(t))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_13] the second input argument, "to" is set (${JSON.stringify(t,null,0)}) but first-one, "from" is not (${JSON.stringify(e,null,0)})`);const s=+e,l=+t;if(o(n)&&(n=String(n)),!o(s)||!o(l))throw o(s)&&s>=0?new TypeError(`ranges-push/Ranges/add(): [THROW_ID_10] "to" value, the second input argument, must be a natural number or zero! Currently it's of a type "${typeof l}" equal to: ${JSON.stringify(l,null,4)}`):new TypeError(`ranges-push/Ranges/add(): [THROW_ID_09] "from" value, the first input argument, must be a natural number or zero! Currently it's of a type "${typeof s}" equal to: ${JSON.stringify(s,null,4)}`);if(i(n)&&!a(n)&&!o(n))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_08] The third argument, the value to add, was given not as string but ${typeof n}, equal to:\n${JSON.stringify(n,null,4)}`);if(i(this.ranges)&&Array.isArray(this.last())&&s===this.last()[1]){if(this.last()[1]=l,this.last(),null!==this.last()[2]&&i(n)){let e=!(this.last()[2]&&this.last()[2].length>0)||this.opts&&this.opts.mergeType&&1!==this.opts.mergeType?n:this.last()[2]+n;this.opts.limitToBeAddedWhitespace&&(e=r(e,this.opts.limitLinebreaksCount)),a(e)&&!e.length||(this.last()[2]=e)}}else{this.ranges||(this.ranges=[]);const e=void 0===n||a(n)&&!n.length?[s,l]:[s,l,n&&this.opts.limitToBeAddedWhitespace?r(n,this.opts.limitLinebreaksCount):n];this.ranges.push(e)}}push(e,r,t){this.add(e,r,t)}current(){return Array.isArray(this.ranges)&&this.ranges.length?(this.ranges=function(e,r){function t(e){return e&&"object"==typeof e&&!Array.isArray(e)}if(!Array.isArray(e)||!e.length)return null;let i;if(r){if(!t(r))throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:\n${JSON.stringify(r,null,4)} (type ${typeof r})`);if(i={...s,...r},i.progressFn&&t(i.progressFn)&&!Object.keys(i.progressFn).length)i.progressFn=null;else if(i.progressFn&&"function"!=typeof i.progressFn)throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof i.progressFn}", equal to ${JSON.stringify(i.progressFn,null,4)}`);if(i.mergeType&&1!=+i.mergeType&&2!=+i.mergeType)throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof i.mergeType}", equal to ${JSON.stringify(i.mergeType,null,4)}`);if("boolean"!=typeof i.joinRangesThatTouchEdges)throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof i.joinRangesThatTouchEdges}", equal to ${JSON.stringify(i.joinRangesThatTouchEdges,null,4)}`)}else i={...s};const o=e.filter((e=>e)).map((e=>[...e])).filter((e=>void 0!==e[2]||e[0]!==e[1]));let a,l,g;if(a=i.progressFn?n(o,{progressFn:e=>{g=Math.floor(e/5),g!==l&&(l=g,i.progressFn(g))}}):n(o),!a)return null;const u=a.length-1;for(let e=u;e>0;e--)i.progressFn&&(g=Math.floor(78*(1-e/u))+21,g!==l&&g>l&&(l=g,i.progressFn(g))),(a[e][0]<=a[e-1][0]||!i.joinRangesThatTouchEdges&&a[e][0]<a[e-1][1]||i.joinRangesThatTouchEdges&&a[e][0]<=a[e-1][1])&&(a[e-1][0]=Math.min(a[e][0],a[e-1][0]),a[e-1][1]=Math.max(a[e][1],a[e-1][1]),void 0!==a[e][2]&&(a[e-1][0]>=a[e][0]||a[e-1][1]<=a[e][1])&&null!==a[e-1][2]&&(null===a[e][2]&&null!==a[e-1][2]?a[e-1][2]=null:null!=a[e-1][2]?2==+i.mergeType&&a[e-1][0]===a[e][0]?a[e-1][2]=a[e][2]:a[e-1][2]+=a[e][2]:a[e-1][2]=a[e][2]),a.splice(e,1),e=a.length);return a.length?a:null}(this.ranges,{mergeType:this.opts.mergeType}),this.ranges&&this.opts.limitToBeAddedWhitespace?this.ranges.map((e=>i(e[2])?[e[0],e[1],r(e[2],this.opts.limitLinebreaksCount)]:e)):this.ranges):null}wipe(){this.ranges=[]}replace(e){if(Array.isArray(e)&&e.length){if(!Array.isArray(e[0])||!o(e[0][0]))throw new Error(`ranges-push/Ranges/replace(): [THROW_ID_11] Single range was given but we expected array of arrays! The first element, ${JSON.stringify(e[0],null,4)} should be an array and its first element should be an integer, a string index.`);this.ranges=Array.from(e)}else this.ranges=[]}last(){return Array.isArray(this.ranges)&&this.ranges.length?this.ranges[this.ranges.length-1]:null}}
/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 5.0.1
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */const u={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function f(e,r){if(!Array.isArray(e)||!e.length)return e;const t={...u,...r};let n,s;if(t.strictlyTwoElementsInRangeArrays&&!e.filter((e=>e)).every(((e,r)=>2===e.length||(n=r,s=e.length,!1))))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${n}th range (${JSON.stringify(e[n],null,4)}) has not two but ${s} elements!`);if(!e.filter((e=>e)).every(((e,r)=>!(!Number.isInteger(e[0])||e[0]<0||!Number.isInteger(e[1])||e[1]<0)||(n=r,!1))))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${n}th range (${JSON.stringify(e[n],null,4)}) does not consist of only natural numbers!`);const i=e.filter((e=>e)).length**2;let o=0;return Array.from(e).filter((e=>e)).sort(((e,r)=>(t.progressFn&&(o+=1,t.progressFn(Math.floor(100*o/i))),e[0]===r[0]?e[1]<r[1]?-1:e[1]>r[1]?1:0:e[0]<r[0]?-1:1)))}
/**
 * @name ranges-merge
 * @fileoverview Merge and sort string index ranges
 * @version 8.0.1
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-merge/}
 */const y={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function p(e,r){function t(e){return e&&"object"==typeof e&&!Array.isArray(e)}if(!Array.isArray(e)||!e.length)return null;let n;if(r){if(!t(r))throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:\n${JSON.stringify(r,null,4)} (type ${typeof r})`);if(n={...y,...r},n.progressFn&&t(n.progressFn)&&!Object.keys(n.progressFn).length)n.progressFn=null;else if(n.progressFn&&"function"!=typeof n.progressFn)throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof n.progressFn}", equal to ${JSON.stringify(n.progressFn,null,4)}`);if(n.mergeType&&1!=+n.mergeType&&2!=+n.mergeType)throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof n.mergeType}", equal to ${JSON.stringify(n.mergeType,null,4)}`);if("boolean"!=typeof n.joinRangesThatTouchEdges)throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof n.joinRangesThatTouchEdges}", equal to ${JSON.stringify(n.joinRangesThatTouchEdges,null,4)}`)}else n={...y};const s=e.filter((e=>e)).map((e=>[...e])).filter((e=>void 0!==e[2]||e[0]!==e[1]));let i,o,a;if(i=n.progressFn?f(s,{progressFn:e=>{a=Math.floor(e/5),a!==o&&(o=a,n.progressFn(a))}}):f(s),!i)return null;const l=i.length-1;for(let e=l;e>0;e--)n.progressFn&&(a=Math.floor(78*(1-e/l))+21,a!==o&&a>o&&(o=a,n.progressFn(a))),(i[e][0]<=i[e-1][0]||!n.joinRangesThatTouchEdges&&i[e][0]<i[e-1][1]||n.joinRangesThatTouchEdges&&i[e][0]<=i[e-1][1])&&(i[e-1][0]=Math.min(i[e][0],i[e-1][0]),i[e-1][1]=Math.max(i[e][1],i[e-1][1]),void 0!==i[e][2]&&(i[e-1][0]>=i[e][0]||i[e-1][1]<=i[e][1])&&null!==i[e-1][2]&&(null===i[e][2]&&null!==i[e-1][2]?i[e-1][2]=null:null!=i[e-1][2]?2==+n.mergeType&&i[e-1][0]===i[e][0]?i[e-1][2]=i[e][2]:i[e-1][2]+=i[e][2]:i[e-1][2]=i[e][2]),i.splice(e,1),e=i.length);return i.length?i:null}
/**
 * @name ranges-apply
 * @fileoverview Take an array of string index ranges, delete/replace the string according to them
 * @version 6.0.1
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-apply/}
 */const h={padStart:3,overrideRowNum:null,returnRangesOnly:!1,triggerKeywords:["console.log"],extractedLogContentsWereGiven:!1};e.defaults=h,e.fixRowNums=function(e,r){if("string"!=typeof e||!e.length)return e;function t(e){return/[0-9]/.test(e)}function n(e){return e&&"object"==typeof e&&!Array.isArray(e)}const s={...h,...r};(!s.padStart||"number"!=typeof s.padStart||"number"==typeof s.padStart&&s.padStart<0)&&(s.padStart=0);const i=new g;let o;const a=e.length;let l=null,u=null,f=null,y=1,m=!1,d=null;for(s.padStart&&a>45e3&&(s.padStart=4),o=0;o<a;o++){if(null===s.overrideRowNum&&("\n"===e[o]||"\r"===e[o]&&"\n"!==e[o+1])&&(y+=1),!s.extractedLogContentsWereGiven&&null!==l&&l.start<o&&l.type===e[o]&&(l=null,u=null,f=null,d=null,m=!1),null===l&&(s.extractedLogContentsWereGiven||u&&u<o&&f&&f<o)&&e[o].trim())if('"'===e[o]||"'"===e[o]||"`"===e[o])l={start:o,type:e[o]},m=!1;else if(s.extractedLogContentsWereGiven&&null===d){if(!t(e[o]))break;d=o}else e[o].trim()&&"/"!==e[o]&&!s.extractedLogContentsWereGiven&&(u=null,f=null,d=null);if(l&&Number.isInteger(l.start)&&l.start<o&&!m&&null===d&&t(e[o])&&(d=o),!Number.isInteger(d)||t(e[o])&&e[o+1]||!(o>d)&&e[o+1]||(i.push(d,t(e[o])?o+1:o,s.padStart?String(null!=s.overrideRowNum?s.overrideRowNum:y).padStart(s.padStart,"0"):`${null!=s.overrideRowNum?s.overrideRowNum:y}`),d=null,m=!0),l&&Number.isInteger(l.start)&&l.start<o&&!m&&/[A-Za-z]/.test(e[o])&&("n"!==e[o]||"\\"!==e[o-1])){if("\\"===e[o-1]&&"u"===e[o]&&"0"===e[o+1]&&"0"===e[o+2]&&"1"===e[o+3]&&("b"===e[o+4]||"B"===e[o+5])&&"["===e[o+5]){let r,n,s;if(t(e[o+6])?r=o+6:"$"===e[o+6]&&"{"===e[o+7]&&t(e[o+8])&&(r=o+8),r)for(let s=r;s<a;s++)if(!t(e[s])){n=s;break}if(void 0!==n&&"m"===e[n]?s=n:void 0!==n&&"}"===e[n]&&"m"===e[n+1]&&(s=n+1),!s){m=!0;continue}if("$"===e[s+1]&&"{"===e[s+2]&&"`"===e[s+3]){o=s+3;continue}}m=!0}if(!f&&e[o].trim()&&u&&u<=o&&("("===e[o]?f=o:(u=null,d=null)),n(s)&&s.triggerKeywords&&Array.isArray(s.triggerKeywords)){let r;for(let t=0,n=s.triggerKeywords.length;t<n;t++)if(e.startsWith(s.triggerKeywords[t],o)){r=s.triggerKeywords[t];break}if(r){u=o+r.length,o=o+r.length-1;continue}}}return l=null,u=null,f=null,y=1,m=void 0,d=null,y=1,s.returnRangesOnly?i.current():i.current()?function(e,r,t){let n,s=0,i=0;if(0===arguments.length)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if("string"!=typeof e)throw new TypeError(`ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ${typeof e}, equal to: ${JSON.stringify(e,null,4)}`);if(r&&!Array.isArray(r))throw new TypeError(`ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ${typeof r}, equal to: ${JSON.stringify(r,null,4)}`);if(t&&"function"!=typeof t)throw new TypeError(`ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ${typeof t}, equal to: ${JSON.stringify(t,null,4)}`);if(!r||!r.filter((e=>e)).length)return e;n=Array.isArray(r)&&Number.isInteger(r[0])&&Number.isInteger(r[1])?[Array.from(r)]:Array.from(r);const o=n.length;let a=0;n.filter((e=>e)).forEach(((e,r)=>{if(t&&(s=Math.floor(a/o*10),s!==i&&(i=s,t(s))),!Array.isArray(e))throw new TypeError(`ranges-apply: [THROW_ID_05] ranges array, second input arg., has ${r}th element not an array: ${JSON.stringify(e,null,4)}, which is ${typeof e}`);if(!Number.isInteger(e[0])){if(!Number.isInteger(+e[0])||+e[0]<0)throw new TypeError(`ranges-apply: [THROW_ID_06] ranges array, second input arg. has ${r}th element, array ${JSON.stringify(e,null,0)}. Its first element is not an integer, string index, but ${typeof e[0]}, equal to: ${JSON.stringify(e[0],null,4)}.`);n[r][0]=+n[r][0]}if(!Number.isInteger(e[1])){if(!Number.isInteger(+e[1])||+e[1]<0)throw new TypeError(`ranges-apply: [THROW_ID_07] ranges array, second input arg. has ${r}th element, array ${JSON.stringify(e,null,0)}. Its second element is not an integer, string index, but ${typeof e[1]}, equal to: ${JSON.stringify(e[1],null,4)}.`);n[r][1]=+n[r][1]}a+=1}));const l=p(n,{progressFn:e=>{t&&(s=10+Math.floor(e/10),s!==i&&(i=s,t(s)))}}),g=Array.isArray(l)?l.length:0;if(g>0){const r=e.slice(l[g-1][1]);e=l.reduce(((r,n,o,a)=>(t&&(s=20+Math.floor(o/g*80),s!==i&&(i=s,t(s))),r+e.slice(0===o?0:a[o-1][1],a[o][0])+(a[o][2]||""))),""),e+=r}return e}(e,i.current()):e},e.version="5.0.1",Object.defineProperty(e,"__esModule",{value:!0})}));
