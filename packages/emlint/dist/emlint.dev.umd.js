/**
 * emlint
 * Pluggable email template code linter
 * Version: 4.4.0
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/emlint/
 */

(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.emlint = {}));
}(this, (function (exports) { 'use strict';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

var domain; // This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling `Object.create(null)` to get a "clean" empty
// object (tested with v8 v4.9).

function EventHandlers() {}

EventHandlers.prototype = Object.create(null);

function EventEmitter() {
  EventEmitter.init.call(this);
}
// require('events') === require('events').EventEmitter

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.prototype.domain = undefined;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

EventEmitter.defaultMaxListeners = 10;

EventEmitter.init = function () {
  this.domain = null;

  if (EventEmitter.usingDomains) {
    // if there is an active domain, then attach to it.
    if (domain.active ) ;
  }

  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n)) throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
}; // These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.


function emitNone(handler, isFn, self) {
  if (isFn) handler.call(self);else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) {
      listeners[i].call(self);
    }
  }
}

function emitOne(handler, isFn, self, arg1) {
  if (isFn) handler.call(self, arg1);else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) {
      listeners[i].call(self, arg1);
    }
  }
}

function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn) handler.call(self, arg1, arg2);else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) {
      listeners[i].call(self, arg1, arg2);
    }
  }
}

function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn) handler.call(self, arg1, arg2, arg3);else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) {
      listeners[i].call(self, arg1, arg2, arg3);
    }
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn) handler.apply(self, args);else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) {
      listeners[i].apply(self, args);
    }
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var doError = type === 'error';
  events = this._events;
  if (events) doError = doError && events.error == null;else if (!doError) return false;
  domain = this.domain; // If there is no 'error' event listener then throw.

  if (doError) {
    er = arguments[1];

    if (domain) {
      if (!er) er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }

    return false;
  }

  handler = events[type];
  if (!handler) return false;
  var isFn = typeof handler === 'function';
  len = arguments.length;

  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;

    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;

    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;

    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower

    default:
      args = new Array(len - 1);

      for (i = 1; i < len; i++) {
        args[i - 1] = arguments[i];
      }

      emitMany(handler, isFn, this, args);
  }
  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
  events = target._events;

  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    } // Check for listener leak


    if (!existing.warned) {
      m = $getMaxListeners(target);

      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + type + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }

  return target;
}

function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function _onceWrap(target, type, listener) {
  var fired = false;

  function g() {
    target.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }

  g.listener = listener;
  return g;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // emits a 'removeListener' event iff the listener was removed


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
  events = this._events;
  if (!events) return this;
  list = events[type];
  if (!list) return this;

  if (list === listener || list.listener && list.listener === listener) {
    if (--this._eventsCount === 0) this._events = new EventHandlers();else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length; i-- > 0;) {
      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;

    if (list.length === 1) {
      list[0] = undefined;

      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events[type];
      }
    } else {
      spliceOne(list, position);
    }

    if (events.removeListener) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events;
  events = this._events;
  if (!events) return this; // not listening for removeListener, no need to emit

  if (!events.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events[type]) {
      if (--this._eventsCount === 0) this._events = new EventHandlers();else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);

    for (var i = 0, key; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    do {
      this.removeListener(type, listeners[listeners.length - 1]);
    } while (listeners[0]);
  }

  return this;
};

EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;
  if (!events) ret = [];else {
    evlistener = events[type];
    if (!evlistener) ret = [];else if (typeof evlistener === 'function') ret = [evlistener.listener || evlistener];else ret = unwrapListeners(evlistener);
  }
  return ret;
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
}; // About 1.5x faster than the two-arg version of Array#splice().


function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

function arrayClone(arr, i) {
  var copy = new Array(i);

  while (i--) {
    copy[i] = arr[i];
  }

  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

var events = /*#__PURE__*/Object.freeze({
__proto__: null,
'default': EventEmitter,
EventEmitter: EventEmitter
});

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(events);

var TypedEmitter = require$$0$1.EventEmitter;

var array = [];
var charCodeCache = [];

var leven = function leven(left, right) {
  if (left === right) {
    return 0;
  }

  var swap = left; // Swapping the strings if `a` is longer than `b` so we know which one is the
  // shortest & which one is the longest

  if (left.length > right.length) {
    left = right;
    right = swap;
  }

  var leftLength = left.length;
  var rightLength = right.length; // Performing suffix trimming:
  // We can linearly drop suffix common to both strings since they
  // don't increase distance at all
  // Note: `~-` is the bitwise way to perform a `- 1` operation

  while (leftLength > 0 && left.charCodeAt(~-leftLength) === right.charCodeAt(~-rightLength)) {
    leftLength--;
    rightLength--;
  } // Performing prefix trimming
  // We can linearly drop prefix common to both strings since they
  // don't increase distance at all


  var start = 0;

  while (start < leftLength && left.charCodeAt(start) === right.charCodeAt(start)) {
    start++;
  }

  leftLength -= start;
  rightLength -= start;

  if (leftLength === 0) {
    return rightLength;
  }

  var bCharCode;
  var result;
  var temp;
  var temp2;
  var i = 0;
  var j = 0;

  while (i < leftLength) {
    charCodeCache[i] = left.charCodeAt(start + i);
    array[i] = ++i;
  }

  while (j < rightLength) {
    bCharCode = right.charCodeAt(start + j);
    temp = j++;
    result = j;

    for (i = 0; i < leftLength; i++) {
      temp2 = bCharCode === charCodeCache[i] ? temp : temp + 1;
      temp = array[i]; // eslint-disable-next-line no-multi-assign

      result = array[i] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;
    }
  }

  return result;
};

var leven_1 = leven; // TODO: Remove this for the next major release

var _default = leven;
leven_1.default = _default;

/**
 * all-named-html-entities
 * List of all named HTML entities
 * Version: 1.5.8
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/all-named-html-entities/
 */
var Aacute = "Á";
var aacute = "á";
var Abreve = "Ă";
var abreve = "ă";
var ac$1 = "∾";
var acd = "∿";
var acE = "∾̳";
var Acirc = "Â";
var acirc = "â";
var acute$1 = "´";
var Acy = "А";
var acy = "а";
var AElig = "Æ";
var aelig = "æ";
var af = "⁡";
var Afr = "𝔄";
var afr = "𝔞";
var Agrave = "À";
var agrave = "à";
var alefsym = "ℵ";
var aleph = "ℵ";
var Alpha$1 = "Α";
var alpha$1 = "α";
var Amacr = "Ā";
var amacr = "ā";
var amalg = "⨿";
var AMP = "&";
var amp$1 = "&";
var And$1 = "⩓";
var and$1 = "∧";
var andand = "⩕";
var andd = "⩜";
var andslope = "⩘";
var andv = "⩚";
var ang = "∠";
var ange$1 = "⦤";
var angle$1 = "∠";
var angmsd = "∡";
var angmsdaa = "⦨";
var angmsdab = "⦩";
var angmsdac = "⦪";
var angmsdad = "⦫";
var angmsdae = "⦬";
var angmsdaf = "⦭";
var angmsdag = "⦮";
var angmsdah = "⦯";
var angrt = "∟";
var angrtvb = "⊾";
var angrtvbd = "⦝";
var angsph = "∢";
var angst$1 = "Å";
var angzarr = "⍼";
var Aogon = "Ą";
var aogon = "ą";
var Aopf = "𝔸";
var aopf = "𝕒";
var ap$1 = "≈";
var apacir = "⩯";
var apE = "⩰";
var ape$1 = "≊";
var apid = "≋";
var apos = "'";
var ApplyFunction = "⁡";
var approx$1 = "≈";
var approxeq = "≊";
var Aring$1 = "Å";
var aring$1 = "å";
var Ascr$1 = "𝒜";
var ascr$1 = "𝒶";
var Assign$1 = "≔";
var ast$1 = "*";
var asymp = "≈";
var asympeq = "≍";
var Atilde = "Ã";
var atilde$1 = "ã";
var Auml = "Ä";
var auml = "ä";
var awconint = "∳";
var awint = "⨑";
var backcong = "≌";
var backepsilon = "϶";
var backprime = "‵";
var backsim = "∽";
var backsimeq = "⋍";
var Backslash$1 = "∖";
var Barv = "⫧";
var barvee = "⊽";
var Barwed = "⌆";
var barwed = "⌅";
var barwedge$1 = "⌅";
var bbrk = "⎵";
var bbrktbrk = "⎶";
var bcong = "≌";
var Bcy = "Б";
var bcy = "б";
var bdquo = "„";
var becaus$1 = "∵";
var Because$1 = "∵";
var because$1 = "∵";
var bemptyv = "⦰";
var bepsi$1 = "϶";
var bernou = "ℬ";
var Bernoullis$1 = "ℬ";
var Beta$1 = "Β";
var beta$1 = "β";
var beth$1 = "ℶ";
var between$1 = "≬";
var Bfr = "𝔅";
var bfr = "𝔟";
var bigcap = "⋂";
var bigcirc = "◯";
var bigcup = "⋃";
var bigodot = "⨀";
var bigoplus = "⨁";
var bigotimes = "⨂";
var bigsqcup = "⨆";
var bigstar = "★";
var bigtriangledown = "▽";
var bigtriangleup = "△";
var biguplus = "⨄";
var bigvee = "⋁";
var bigwedge = "⋀";
var bkarow = "⤍";
var blacklozenge = "⧫";
var blacksquare = "▪";
var blacktriangle = "▴";
var blacktriangledown = "▾";
var blacktriangleleft = "◂";
var blacktriangleright = "▸";
var blank$1 = "␣";
var blk12 = "▒";
var blk14 = "░";
var blk34 = "▓";
var block$1 = "█";
var bne = "=⃥";
var bnequiv = "≡⃥";
var bNot = "⫭";
var bnot = "⌐";
var Bopf = "𝔹";
var bopf = "𝕓";
var bot$1 = "⊥";
var bottom$1 = "⊥";
var bowtie$1 = "⋈";
var boxbox = "⧉";
var boxDL = "╗";
var boxDl = "╖";
var boxdL = "╕";
var boxdl = "┐";
var boxDR = "╔";
var boxDr = "╓";
var boxdR = "╒";
var boxdr = "┌";
var boxH = "═";
var boxh = "─";
var boxHD = "╦";
var boxHd = "╤";
var boxhD = "╥";
var boxhd = "┬";
var boxHU = "╩";
var boxHu = "╧";
var boxhU = "╨";
var boxhu = "┴";
var boxminus = "⊟";
var boxplus = "⊞";
var boxtimes = "⊠";
var boxUL = "╝";
var boxUl = "╜";
var boxuL = "╛";
var boxul = "┘";
var boxUR = "╚";
var boxUr = "╙";
var boxuR = "╘";
var boxur = "└";
var boxV = "║";
var boxv = "│";
var boxVH = "╬";
var boxVh = "╫";
var boxvH = "╪";
var boxvh = "┼";
var boxVL = "╣";
var boxVl = "╢";
var boxvL = "╡";
var boxvl = "┤";
var boxVR = "╠";
var boxVr = "╟";
var boxvR = "╞";
var boxvr = "├";
var bprime = "‵";
var Breve = "˘";
var breve$1 = "˘";
var brvbar = "¦";
var Bscr = "ℬ";
var bscr = "𝒷";
var bsemi = "⁏";
var bsim = "∽";
var bsime = "⋍";
var bsol = "\\";
var bsolb = "⧅";
var bsolhsub = "⟈";
var bull$1 = "•";
var bullet$1 = "•";
var bump$1 = "≎";
var bumpE = "⪮";
var bumpe = "≏";
var Bumpeq = "≎";
var bumpeq = "≏";
var Cacute = "Ć";
var cacute$1 = "ć";
var Cap$1 = "⋒";
var cap$1 = "∩";
var capand$1 = "⩄";
var capbrcup = "⩉";
var capcap = "⩋";
var capcup = "⩇";
var capdot = "⩀";
var CapitalDifferentialD = "ⅅ";
var caps$1 = "∩︀";
var caret$1 = "⁁";
var caron$1 = "ˇ";
var Cayleys = "ℭ";
var ccaps = "⩍";
var Ccaron = "Č";
var ccaron = "č";
var Ccedil = "Ç";
var ccedil = "ç";
var Ccirc = "Ĉ";
var ccirc = "ĉ";
var Cconint = "∰";
var ccups = "⩌";
var ccupssm = "⩐";
var Cdot = "Ċ";
var cdot = "ċ";
var cedil$1 = "¸";
var Cedilla$1 = "¸";
var cemptyv = "⦲";
var cent$1 = "¢";
var CenterDot = "·";
var centerdot = "·";
var Cfr = "ℭ";
var cfr = "𝔠";
var CHcy = "Ч";
var chcy = "ч";
var check$1 = "✓";
var checkmark$1 = "✓";
var Chi$1 = "Χ";
var chi$1 = "χ";
var cir$1 = "○";
var circ$1 = "ˆ";
var circeq = "≗";
var circlearrowleft = "↺";
var circlearrowright = "↻";
var circledast = "⊛";
var circledcirc = "⊚";
var circleddash = "⊝";
var CircleDot = "⊙";
var circledR = "®";
var circledS = "Ⓢ";
var CircleMinus = "⊖";
var CirclePlus = "⊕";
var CircleTimes = "⊗";
var cirE = "⧃";
var cire = "≗";
var cirfnint = "⨐";
var cirmid = "⫯";
var cirscir = "⧂";
var ClockwiseContourIntegral = "∲";
var CloseCurlyDoubleQuote = "”";
var CloseCurlyQuote = "’";
var clubs$1 = "♣";
var clubsuit$1 = "♣";
var Colon$1 = "∷";
var colon$1 = ":";
var Colone$1 = "⩴";
var colone$1 = "≔";
var coloneq = "≔";
var comma$1 = ",";
var commat$1 = "@";
var comp$1 = "∁";
var compfn = "∘";
var complement$1 = "∁";
var complexes$1 = "ℂ";
var cong$1 = "≅";
var congdot = "⩭";
var Congruent$1 = "≡";
var Conint = "∯";
var conint$1 = "∮";
var ContourIntegral = "∮";
var Copf = "ℂ";
var copf$1 = "𝕔";
var coprod$1 = "∐";
var Coproduct = "∐";
var COPY$1 = "©";
var copy$1 = "©";
var copysr = "℗";
var CounterClockwiseContourIntegral = "∳";
var crarr = "↵";
var Cross$1 = "⨯";
var cross$1 = "✗";
var Cscr = "𝒞";
var cscr = "𝒸";
var csub = "⫏";
var csube = "⫑";
var csup = "⫐";
var csupe = "⫒";
var ctdot = "⋯";
var cudarrl = "⤸";
var cudarrr = "⤵";
var cuepr = "⋞";
var cuesc = "⋟";
var cularr = "↶";
var cularrp = "⤽";
var Cup$1 = "⋓";
var cup$1 = "∪";
var cupbrcap = "⩈";
var CupCap = "≍";
var cupcap = "⩆";
var cupcup = "⩊";
var cupdot = "⊍";
var cupor = "⩅";
var cups$1 = "∪︀";
var curarr = "↷";
var curarrm = "⤼";
var curlyeqprec = "⋞";
var curlyeqsucc = "⋟";
var curlyvee = "⋎";
var curlywedge = "⋏";
var curren = "¤";
var curvearrowleft = "↶";
var curvearrowright = "↷";
var cuvee = "⋎";
var cuwed = "⋏";
var cwconint = "∲";
var cwint = "∱";
var cylcty = "⌭";
var Dagger$1 = "‡";
var dagger$1 = "†";
var daleth$1 = "ℸ";
var Darr = "↡";
var dArr = "⇓";
var darr$1 = "↓";
var dash$1 = "‐";
var Dashv = "⫤";
var dashv = "⊣";
var dbkarow = "⤏";
var dblac = "˝";
var Dcaron = "Ď";
var dcaron = "ď";
var Dcy = "Д";
var dcy = "д";
var DD$1 = "ⅅ";
var dd$1 = "ⅆ";
var ddagger = "‡";
var ddarr = "⇊";
var DDotrahd = "⤑";
var ddotseq = "⩷";
var deg$1 = "°";
var Del$1 = "∇";
var Delta$1 = "Δ";
var delta$1 = "δ";
var demptyv = "⦱";
var dfisht = "⥿";
var Dfr = "𝔇";
var dfr = "𝔡";
var dHar = "⥥";
var dharl = "⇃";
var dharr$1 = "⇂";
var DiacriticalAcute = "´";
var DiacriticalDot = "˙";
var DiacriticalDoubleAcute = "˝";
var DiacriticalGrave = "`";
var DiacriticalTilde = "˜";
var diam$1 = "⋄";
var Diamond$1 = "⋄";
var diamond$1 = "⋄";
var diamondsuit = "♦";
var diams$1 = "♦";
var die$1 = "¨";
var DifferentialD = "ⅆ";
var digamma$1 = "ϝ";
var disin$1 = "⋲";
var div$1 = "÷";
var divide$1 = "÷";
var divideontimes = "⋇";
var divonx = "⋇";
var DJcy = "Ђ";
var djcy = "ђ";
var dlcorn = "⌞";
var dlcrop = "⌍";
var dollar$1 = "$";
var Dopf = "𝔻";
var dopf$1 = "𝕕";
var Dot$1 = "¨";
var dot$1 = "˙";
var DotDot = "⃜";
var doteq = "≐";
var doteqdot = "≑";
var DotEqual = "≐";
var dotminus = "∸";
var dotplus = "∔";
var dotsquare = "⊡";
var doublebarwedge = "⌆";
var DoubleContourIntegral = "∯";
var DoubleDot = "¨";
var DoubleDownArrow = "⇓";
var DoubleLeftArrow = "⇐";
var DoubleLeftRightArrow = "⇔";
var DoubleLeftTee = "⫤";
var DoubleLongLeftArrow = "⟸";
var DoubleLongLeftRightArrow = "⟺";
var DoubleLongRightArrow = "⟹";
var DoubleRightArrow = "⇒";
var DoubleRightTee = "⊨";
var DoubleUpArrow = "⇑";
var DoubleUpDownArrow = "⇕";
var DoubleVerticalBar = "∥";
var DownArrow = "↓";
var Downarrow = "⇓";
var downarrow = "↓";
var DownArrowBar = "⤓";
var DownArrowUpArrow = "⇵";
var DownBreve = "̑";
var downdownarrows = "⇊";
var downharpoonleft = "⇃";
var downharpoonright = "⇂";
var DownLeftRightVector = "⥐";
var DownLeftTeeVector = "⥞";
var DownLeftVector = "↽";
var DownLeftVectorBar = "⥖";
var DownRightTeeVector = "⥟";
var DownRightVector = "⇁";
var DownRightVectorBar = "⥗";
var DownTee = "⊤";
var DownTeeArrow = "↧";
var drbkarow = "⤐";
var drcorn = "⌟";
var drcrop = "⌌";
var Dscr = "𝒟";
var dscr = "𝒹";
var DScy = "Ѕ";
var dscy = "ѕ";
var dsol$1 = "⧶";
var Dstrok = "Đ";
var dstrok = "đ";
var dtdot = "⋱";
var dtri$1 = "▿";
var dtrif = "▾";
var duarr = "⇵";
var duhar = "⥯";
var dwangle = "⦦";
var DZcy = "Џ";
var dzcy = "џ";
var dzigrarr = "⟿";
var Eacute = "É";
var eacute = "é";
var easter$1 = "⩮";
var Ecaron = "Ě";
var ecaron = "ě";
var ecir$1 = "≖";
var Ecirc = "Ê";
var ecirc = "ê";
var ecolon$1 = "≕";
var Ecy = "Э";
var ecy$1 = "э";
var eDDot = "⩷";
var Edot = "Ė";
var eDot = "≑";
var edot$1 = "ė";
var ee$1 = "ⅇ";
var efDot = "≒";
var Efr = "𝔈";
var efr$1 = "𝔢";
var eg$1 = "⪚";
var Egrave = "È";
var egrave$1 = "è";
var egs$1 = "⪖";
var egsdot = "⪘";
var el$1 = "⪙";
var Element = "∈";
var elinters = "⏧";
var ell$1 = "ℓ";
var els$1 = "⪕";
var elsdot = "⪗";
var Emacr = "Ē";
var emacr = "ē";
var empty$1 = "∅";
var emptyset = "∅";
var EmptySmallSquare = "◻";
var emptyv = "∅";
var EmptyVerySmallSquare = "▫";
var emsp = " ";
var emsp13 = " ";
var emsp14 = " ";
var ENG$1 = "Ŋ";
var eng$1 = "ŋ";
var ensp = " ";
var Eogon = "Ę";
var eogon = "ę";
var Eopf = "𝔼";
var eopf = "𝕖";
var epar = "⋕";
var eparsl = "⧣";
var eplus = "⩱";
var epsi$1 = "ε";
var Epsilon$1 = "Ε";
var epsilon$1 = "ε";
var epsiv = "ϵ";
var eqcirc = "≖";
var eqcolon = "≕";
var eqsim = "≂";
var eqslantgtr = "⪖";
var eqslantless = "⪕";
var Equal$1 = "⩵";
var equals$1 = "=";
var EqualTilde = "≂";
var equest$1 = "≟";
var Equilibrium$1 = "⇌";
var equiv$1 = "≡";
var equivDD = "⩸";
var eqvparsl = "⧥";
var erarr = "⥱";
var erDot = "≓";
var Escr = "ℰ";
var escr$1 = "ℯ";
var esdot = "≐";
var Esim = "⩳";
var esim$1 = "≂";
var Eta$1 = "Η";
var eta$1 = "η";
var ETH$1 = "Ð";
var eth$1 = "ð";
var Euml = "Ë";
var euml = "ë";
var euro$1 = "€";
var excl$1 = "!";
var exist$1 = "∃";
var Exists$1 = "∃";
var expectation$1 = "ℰ";
var ExponentialE = "ⅇ";
var exponentiale = "ⅇ";
var fallingdotseq = "≒";
var Fcy = "Ф";
var fcy = "ф";
var female$1 = "♀";
var ffilig = "ﬃ";
var fflig = "ﬀ";
var ffllig = "ﬄ";
var Ffr = "𝔉";
var ffr = "𝔣";
var filig = "ﬁ";
var FilledSmallSquare = "◼";
var FilledVerySmallSquare = "▪";
var fjlig = "fj";
var flat$1 = "♭";
var fllig = "ﬂ";
var fltns = "▱";
var fnof = "ƒ";
var Fopf = "𝔽";
var fopf = "𝕗";
var ForAll = "∀";
var forall = "∀";
var fork$1 = "⋔";
var forkv = "⫙";
var Fouriertrf = "ℱ";
var fpartint = "⨍";
var frac12 = "½";
var frac13 = "⅓";
var frac14 = "¼";
var frac15 = "⅕";
var frac16 = "⅙";
var frac18 = "⅛";
var frac23 = "⅔";
var frac25 = "⅖";
var frac34 = "¾";
var frac35 = "⅗";
var frac38 = "⅜";
var frac45 = "⅘";
var frac56 = "⅚";
var frac58 = "⅝";
var frac78 = "⅞";
var frasl = "⁄";
var frown$1 = "⌢";
var Fscr = "ℱ";
var fscr = "𝒻";
var gacute = "ǵ";
var Gamma$1 = "Γ";
var gamma$1 = "γ";
var Gammad = "Ϝ";
var gammad = "ϝ";
var gap$1 = "⪆";
var Gbreve = "Ğ";
var gbreve = "ğ";
var Gcedil = "Ģ";
var Gcirc = "Ĝ";
var gcirc = "ĝ";
var Gcy = "Г";
var gcy$1 = "г";
var Gdot = "Ġ";
var gdot = "ġ";
var gE = "≧";
var ge$1 = "≥";
var gEl = "⪌";
var gel$1 = "⋛";
var geq$1 = "≥";
var geqq = "≧";
var geqslant = "⩾";
var ges$1 = "⩾";
var gescc = "⪩";
var gesdot = "⪀";
var gesdoto = "⪂";
var gesdotol = "⪄";
var gesl$1 = "⋛︀";
var gesles = "⪔";
var Gfr = "𝔊";
var gfr = "𝔤";
var Gg = "⋙";
var gg$1 = "≫";
var ggg = "⋙";
var gimel = "ℷ";
var GJcy = "Ѓ";
var gjcy = "ѓ";
var gl$1 = "≷";
var gla$1 = "⪥";
var glE = "⪒";
var glj = "⪤";
var gnap = "⪊";
var gnapprox = "⪊";
var gnE = "≩";
var gne$1 = "⪈";
var gneq = "⪈";
var gneqq = "≩";
var gnsim = "⋧";
var Gopf = "𝔾";
var gopf = "𝕘";
var grave$1 = "`";
var GreaterEqual = "≥";
var GreaterEqualLess = "⋛";
var GreaterFullEqual = "≧";
var GreaterGreater = "⪢";
var GreaterLess = "≷";
var GreaterSlantEqual = "⩾";
var GreaterTilde = "≳";
var Gscr = "𝒢";
var gscr = "ℊ";
var gsim = "≳";
var gsime = "⪎";
var gsiml = "⪐";
var GT$1 = ">";
var Gt = "≫";
var gt$1 = ">";
var gtcc = "⪧";
var gtcir = "⩺";
var gtdot = "⋗";
var gtlPar = "⦕";
var gtquest = "⩼";
var gtrapprox = "⪆";
var gtrarr = "⥸";
var gtrdot = "⋗";
var gtreqless = "⋛";
var gtreqqless = "⪌";
var gtrless = "≷";
var gtrsim = "≳";
var gvertneqq = "≩︀";
var gvnE = "≩︀";
var Hacek = "ˇ";
var hairsp = " ";
var half$1 = "½";
var hamilt = "ℋ";
var HARDcy = "Ъ";
var hardcy = "ъ";
var hArr = "⇔";
var harr = "↔";
var harrcir = "⥈";
var harrw = "↭";
var Hat$1 = "^";
var hbar = "ℏ";
var Hcirc = "Ĥ";
var hcirc = "ĥ";
var hearts$1 = "♥";
var heartsuit = "♥";
var hellip = "…";
var hercon = "⊹";
var Hfr = "ℌ";
var hfr = "𝔥";
var HilbertSpace = "ℋ";
var hksearow = "⤥";
var hkswarow = "⤦";
var hoarr = "⇿";
var homtht = "∻";
var hookleftarrow = "↩";
var hookrightarrow = "↪";
var Hopf = "ℍ";
var hopf$1 = "𝕙";
var horbar = "―";
var HorizontalLine = "─";
var Hscr = "ℋ";
var hscr = "𝒽";
var hslash = "ℏ";
var Hstrok = "Ħ";
var hstrok = "ħ";
var HumpDownHump = "≎";
var HumpEqual = "≏";
var hybull = "⁃";
var hyphen$1 = "‐";
var Iacute = "Í";
var iacute = "í";
var ic$1 = "⁣";
var Icirc = "Î";
var icirc = "î";
var Icy = "И";
var icy$1 = "и";
var Idot = "İ";
var IEcy = "Е";
var iecy = "е";
var iexcl = "¡";
var iff$1 = "⇔";
var Ifr = "ℑ";
var ifr = "𝔦";
var Igrave = "Ì";
var igrave = "ì";
var ii$1 = "ⅈ";
var iiiint = "⨌";
var iiint = "∭";
var iinfin = "⧜";
var iiota = "℩";
var IJlig = "Ĳ";
var ijlig = "ĳ";
var Im = "ℑ";
var Imacr = "Ī";
var imacr = "ī";
var image$1 = "ℑ";
var ImaginaryI = "ⅈ";
var imagline = "ℐ";
var imagpart = "ℑ";
var imath = "ı";
var imof = "⊷";
var imped$1 = "Ƶ";
var Implies = "⇒";
var incare = "℅";
var infin = "∞";
var infintie = "⧝";
var inodot = "ı";
var Int = "∬";
var int$1 = "∫";
var intcal = "⊺";
var integers$1 = "ℤ";
var Integral = "∫";
var intercal = "⊺";
var Intersection = "⋂";
var intlarhk = "⨗";
var intprod = "⨼";
var InvisibleComma = "⁣";
var InvisibleTimes = "⁢";
var IOcy = "Ё";
var iocy$1 = "ё";
var Iogon = "Į";
var iogon$1 = "į";
var Iopf = "𝕀";
var iopf = "𝕚";
var Iota = "Ι";
var iota$1 = "ι";
var iprod = "⨼";
var iquest = "¿";
var Iscr = "ℐ";
var iscr = "𝒾";
var isin$1 = "∈";
var isindot = "⋵";
var isinE = "⋹";
var isins = "⋴";
var isinsv = "⋳";
var isinv = "∈";
var it$1 = "⁢";
var Itilde = "Ĩ";
var itilde = "ĩ";
var Iukcy = "І";
var iukcy = "і";
var Iuml = "Ï";
var iuml = "ï";
var Jcirc = "Ĵ";
var jcirc = "ĵ";
var Jcy = "Й";
var jcy = "й";
var Jfr = "𝔍";
var jfr = "𝔧";
var jmath = "ȷ";
var Jopf = "𝕁";
var jopf = "𝕛";
var Jscr = "𝒥";
var jscr = "𝒿";
var Jsercy = "Ј";
var jsercy = "ј";
var Jukcy = "Є";
var jukcy = "є";
var Kappa$1 = "Κ";
var kappa$1 = "κ";
var kappav = "ϰ";
var Kcedil = "Ķ";
var kcedil = "ķ";
var Kcy = "К";
var kcy = "к";
var Kfr = "𝔎";
var kfr = "𝔨";
var kgreen = "ĸ";
var KHcy = "Х";
var khcy = "х";
var KJcy = "Ќ";
var kjcy = "ќ";
var Kopf = "𝕂";
var kopf$1 = "𝕜";
var Kscr = "𝒦";
var kscr = "𝓀";
var lAarr = "⇚";
var Lacute = "Ĺ";
var lacute = "ĺ";
var laemptyv = "⦴";
var lagran = "ℒ";
var Lambda$1 = "Λ";
var lambda$1 = "λ";
var Lang = "⟪";
var lang$1 = "⟨";
var langd = "⦑";
var langle = "⟨";
var lap$1 = "⪅";
var Laplacetrf = "ℒ";
var laquo = "«";
var Larr = "↞";
var lArr = "⇐";
var larr = "←";
var larrb = "⇤";
var larrbfs = "⤟";
var larrfs = "⤝";
var larrhk = "↩";
var larrlp = "↫";
var larrpl = "⤹";
var larrsim = "⥳";
var larrtl = "↢";
var lat$1 = "⪫";
var lAtail = "⤛";
var latail = "⤙";
var late$1 = "⪭";
var lates$1 = "⪭︀";
var lBarr = "⤎";
var lbarr = "⤌";
var lbbrk = "❲";
var lbrace = "{";
var lbrack = "[";
var lbrke = "⦋";
var lbrksld = "⦏";
var lbrkslu = "⦍";
var Lcaron = "Ľ";
var lcaron = "ľ";
var Lcedil = "Ļ";
var lcedil = "ļ";
var lceil = "⌈";
var lcub = "{";
var Lcy = "Л";
var lcy = "л";
var ldca = "⤶";
var ldquo = "“";
var ldquor = "„";
var ldrdhar = "⥧";
var ldrushar = "⥋";
var ldsh = "↲";
var lE = "≦";
var le$1 = "≤";
var LeftAngleBracket = "⟨";
var LeftArrow = "←";
var Leftarrow = "⇐";
var leftarrow = "←";
var LeftArrowBar = "⇤";
var LeftArrowRightArrow = "⇆";
var leftarrowtail = "↢";
var LeftCeiling = "⌈";
var LeftDoubleBracket = "⟦";
var LeftDownTeeVector = "⥡";
var LeftDownVector = "⇃";
var LeftDownVectorBar = "⥙";
var LeftFloor = "⌊";
var leftharpoondown = "↽";
var leftharpoonup = "↼";
var leftleftarrows = "⇇";
var LeftRightArrow = "↔";
var Leftrightarrow = "⇔";
var leftrightarrow = "↔";
var leftrightarrows = "⇆";
var leftrightharpoons = "⇋";
var leftrightsquigarrow = "↭";
var LeftRightVector = "⥎";
var LeftTee = "⊣";
var LeftTeeArrow = "↤";
var LeftTeeVector = "⥚";
var leftthreetimes = "⋋";
var LeftTriangle = "⊲";
var LeftTriangleBar = "⧏";
var LeftTriangleEqual = "⊴";
var LeftUpDownVector = "⥑";
var LeftUpTeeVector = "⥠";
var LeftUpVector = "↿";
var LeftUpVectorBar = "⥘";
var LeftVector = "↼";
var LeftVectorBar = "⥒";
var lEg = "⪋";
var leg$1 = "⋚";
var leq$1 = "≤";
var leqq = "≦";
var leqslant = "⩽";
var les$1 = "⩽";
var lescc = "⪨";
var lesdot = "⩿";
var lesdoto = "⪁";
var lesdotor = "⪃";
var lesg = "⋚︀";
var lesges = "⪓";
var lessapprox = "⪅";
var lessdot = "⋖";
var lesseqgtr = "⋚";
var lesseqqgtr = "⪋";
var LessEqualGreater = "⋚";
var LessFullEqual = "≦";
var LessGreater = "≶";
var lessgtr = "≶";
var LessLess = "⪡";
var lesssim = "≲";
var LessSlantEqual = "⩽";
var LessTilde = "≲";
var lfisht = "⥼";
var lfloor = "⌊";
var Lfr = "𝔏";
var lfr = "𝔩";
var lg$1 = "≶";
var lgE = "⪑";
var lHar = "⥢";
var lhard = "↽";
var lharu = "↼";
var lharul = "⥪";
var lhblk = "▄";
var LJcy = "Љ";
var ljcy = "љ";
var Ll = "⋘";
var ll$1 = "≪";
var llarr = "⇇";
var llcorner = "⌞";
var Lleftarrow = "⇚";
var llhard = "⥫";
var lltri = "◺";
var Lmidot = "Ŀ";
var lmidot = "ŀ";
var lmoust = "⎰";
var lmoustache = "⎰";
var lnap = "⪉";
var lnapprox = "⪉";
var lnE = "≨";
var lne$1 = "⪇";
var lneq = "⪇";
var lneqq = "≨";
var lnsim = "⋦";
var loang = "⟬";
var loarr = "⇽";
var lobrk = "⟦";
var LongLeftArrow = "⟵";
var Longleftarrow = "⟸";
var longleftarrow = "⟵";
var LongLeftRightArrow = "⟷";
var Longleftrightarrow = "⟺";
var longleftrightarrow = "⟷";
var longmapsto = "⟼";
var LongRightArrow = "⟶";
var Longrightarrow = "⟹";
var longrightarrow = "⟶";
var looparrowleft = "↫";
var looparrowright = "↬";
var lopar = "⦅";
var Lopf = "𝕃";
var lopf = "𝕝";
var loplus = "⨭";
var lotimes = "⨴";
var lowast = "∗";
var lowbar = "_";
var LowerLeftArrow = "↙";
var LowerRightArrow = "↘";
var loz = "◊";
var lozenge$1 = "◊";
var lozf = "⧫";
var lpar = "(";
var lparlt = "⦓";
var lrarr = "⇆";
var lrcorner = "⌟";
var lrhar = "⇋";
var lrhard = "⥭";
var lrm = "‎";
var lrtri = "⊿";
var lsaquo = "‹";
var Lscr = "ℒ";
var lscr = "𝓁";
var Lsh = "↰";
var lsh$1 = "↰";
var lsim = "≲";
var lsime = "⪍";
var lsimg = "⪏";
var lsqb = "[";
var lsquo = "‘";
var lsquor = "‚";
var Lstrok = "Ł";
var lstrok = "ł";
var LT$1 = "<";
var Lt = "≪";
var lt$1 = "<";
var ltcc = "⪦";
var ltcir = "⩹";
var ltdot = "⋖";
var lthree = "⋋";
var ltimes$1 = "⋉";
var ltlarr = "⥶";
var ltquest = "⩻";
var ltri = "◃";
var ltrie = "⊴";
var ltrif = "◂";
var ltrPar = "⦖";
var lurdshar = "⥊";
var luruhar = "⥦";
var lvertneqq = "≨︀";
var lvnE = "≨︀";
var macr = "¯";
var male$1 = "♂";
var malt$1 = "✠";
var maltese = "✠";
var map$1 = "↦";
var mapsto = "↦";
var mapstodown = "↧";
var mapstoleft = "↤";
var mapstoup = "↥";
var marker$1 = "▮";
var mcomma = "⨩";
var Mcy = "М";
var mcy = "м";
var mdash = "—";
var mDDot = "∺";
var measuredangle = "∡";
var MediumSpace = " ";
var Mellintrf = "ℳ";
var Mfr = "𝔐";
var mfr = "𝔪";
var mho = "℧";
var micro = "µ";
var mid$1 = "∣";
var midast = "*";
var midcir = "⫰";
var middot = "·";
var minus$1 = "−";
var minusb = "⊟";
var minusd = "∸";
var minusdu = "⨪";
var MinusPlus = "∓";
var mlcp = "⫛";
var mldr = "…";
var mnplus = "∓";
var models$1 = "⊧";
var Mopf = "𝕄";
var mopf = "𝕞";
var mp$1 = "∓";
var Mscr = "ℳ";
var mscr = "𝓂";
var mstpos = "∾";
var Mu = "Μ";
var mu$1 = "μ";
var multimap = "⊸";
var mumap = "⊸";
var nabla = "∇";
var Nacute = "Ń";
var nacute = "ń";
var nang$1 = "∠⃒";
var nap$1 = "≉";
var napE = "⩰̸";
var napid = "≋̸";
var napos = "ŉ";
var napprox = "≉";
var natur = "♮";
var natural$1 = "♮";
var naturals$1 = "ℕ";
var nbsp = " ";
var nbump = "≎̸";
var nbumpe = "≏̸";
var ncap = "⩃";
var Ncaron = "Ň";
var ncaron = "ň";
var Ncedil = "Ņ";
var ncedil = "ņ";
var ncong = "≇";
var ncongdot = "⩭̸";
var ncup = "⩂";
var Ncy = "Н";
var ncy$1 = "н";
var ndash = "–";
var ne$1 = "≠";
var nearhk = "⤤";
var neArr = "⇗";
var nearr = "↗";
var nearrow = "↗";
var nedot = "≐̸";
var NegativeMediumSpace = "​";
var NegativeThickSpace = "​";
var NegativeThinSpace = "​";
var NegativeVeryThinSpace = "​";
var nequiv = "≢";
var nesear = "⤨";
var nesim = "≂̸";
var NestedGreaterGreater = "≫";
var NestedLessLess = "≪";
var NewLine = "\n";
var nexist = "∄";
var nexists = "∄";
var Nfr = "𝔑";
var nfr = "𝔫";
var ngE = "≧̸";
var nge$1 = "≱";
var ngeq = "≱";
var ngeqq = "≧̸";
var ngeqslant = "⩾̸";
var nges = "⩾̸";
var nGg = "⋙̸";
var ngsim = "≵";
var nGt = "≫⃒";
var ngt$1 = "≯";
var ngtr = "≯";
var nGtv = "≫̸";
var nhArr = "⇎";
var nharr = "↮";
var nhpar = "⫲";
var ni$1 = "∋";
var nis$1 = "⋼";
var nisd = "⋺";
var niv = "∋";
var NJcy = "Њ";
var njcy = "њ";
var nlArr = "⇍";
var nlarr = "↚";
var nldr = "‥";
var nlE = "≦̸";
var nle$1 = "≰";
var nLeftarrow = "⇍";
var nleftarrow = "↚";
var nLeftrightarrow = "⇎";
var nleftrightarrow = "↮";
var nleq = "≰";
var nleqq = "≦̸";
var nleqslant = "⩽̸";
var nles$1 = "⩽̸";
var nless$1 = "≮";
var nLl = "⋘̸";
var nlsim = "≴";
var nLt = "≪⃒";
var nlt$1 = "≮";
var nltri = "⋪";
var nltrie = "⋬";
var nLtv = "≪̸";
var nmid = "∤";
var NoBreak = "⁠";
var NonBreakingSpace = " ";
var Nopf = "ℕ";
var nopf$1 = "𝕟";
var Not$1 = "⫬";
var not$1 = "¬";
var NotCongruent = "≢";
var NotCupCap = "≭";
var NotDoubleVerticalBar = "∦";
var NotElement = "∉";
var NotEqual = "≠";
var NotEqualTilde = "≂̸";
var NotExists = "∄";
var NotGreater = "≯";
var NotGreaterEqual = "≱";
var NotGreaterFullEqual = "≧̸";
var NotGreaterGreater = "≫̸";
var NotGreaterLess = "≹";
var NotGreaterSlantEqual = "⩾̸";
var NotGreaterTilde = "≵";
var NotHumpDownHump = "≎̸";
var NotHumpEqual = "≏̸";
var notin = "∉";
var notindot = "⋵̸";
var notinE = "⋹̸";
var notinva = "∉";
var notinvb = "⋷";
var notinvc = "⋶";
var NotLeftTriangle = "⋪";
var NotLeftTriangleBar = "⧏̸";
var NotLeftTriangleEqual = "⋬";
var NotLess = "≮";
var NotLessEqual = "≰";
var NotLessGreater = "≸";
var NotLessLess = "≪̸";
var NotLessSlantEqual = "⩽̸";
var NotLessTilde = "≴";
var NotNestedGreaterGreater = "⪢̸";
var NotNestedLessLess = "⪡̸";
var notni = "∌";
var notniva = "∌";
var notnivb = "⋾";
var notnivc = "⋽";
var NotPrecedes = "⊀";
var NotPrecedesEqual = "⪯̸";
var NotPrecedesSlantEqual = "⋠";
var NotReverseElement = "∌";
var NotRightTriangle = "⋫";
var NotRightTriangleBar = "⧐̸";
var NotRightTriangleEqual = "⋭";
var NotSquareSubset = "⊏̸";
var NotSquareSubsetEqual = "⋢";
var NotSquareSuperset = "⊐̸";
var NotSquareSupersetEqual = "⋣";
var NotSubset = "⊂⃒";
var NotSubsetEqual = "⊈";
var NotSucceeds = "⊁";
var NotSucceedsEqual = "⪰̸";
var NotSucceedsSlantEqual = "⋡";
var NotSucceedsTilde = "≿̸";
var NotSuperset = "⊃⃒";
var NotSupersetEqual = "⊉";
var NotTilde = "≁";
var NotTildeEqual = "≄";
var NotTildeFullEqual = "≇";
var NotTildeTilde = "≉";
var NotVerticalBar = "∤";
var npar = "∦";
var nparallel = "∦";
var nparsl = "⫽⃥";
var npart = "∂̸";
var npolint = "⨔";
var npr = "⊀";
var nprcue = "⋠";
var npre = "⪯̸";
var nprec = "⊀";
var npreceq = "⪯̸";
var nrArr = "⇏";
var nrarr = "↛";
var nrarrc = "⤳̸";
var nrarrw = "↝̸";
var nRightarrow = "⇏";
var nrightarrow = "↛";
var nrtri = "⋫";
var nrtrie = "⋭";
var nsc$1 = "⊁";
var nsccue = "⋡";
var nsce$1 = "⪰̸";
var Nscr = "𝒩";
var nscr = "𝓃";
var nshortmid = "∤";
var nshortparallel = "∦";
var nsim = "≁";
var nsime = "≄";
var nsimeq = "≄";
var nsmid = "∤";
var nspar = "∦";
var nsqsube = "⋢";
var nsqsupe = "⋣";
var nsub = "⊄";
var nsubE = "⫅̸";
var nsube = "⊈";
var nsubset = "⊂⃒";
var nsubseteq = "⊈";
var nsubseteqq = "⫅̸";
var nsucc = "⊁";
var nsucceq = "⪰̸";
var nsup = "⊅";
var nsupE = "⫆̸";
var nsupe = "⊉";
var nsupset = "⊃⃒";
var nsupseteq = "⊉";
var nsupseteqq = "⫆̸";
var ntgl = "≹";
var Ntilde = "Ñ";
var ntilde = "ñ";
var ntlg = "≸";
var ntriangleleft = "⋪";
var ntrianglelefteq = "⋬";
var ntriangleright = "⋫";
var ntrianglerighteq = "⋭";
var Nu = "Ν";
var nu$1 = "ν";
var num$1 = "#";
var numero = "№";
var numsp = " ";
var nvap = "≍⃒";
var nVDash = "⊯";
var nVdash = "⊮";
var nvDash = "⊭";
var nvdash = "⊬";
var nvge = "≥⃒";
var nvgt = ">⃒";
var nvHarr = "⤄";
var nvinfin = "⧞";
var nvlArr = "⤂";
var nvle = "≤⃒";
var nvlt = "<⃒";
var nvltrie = "⊴⃒";
var nvrArr = "⤃";
var nvrtrie = "⊵⃒";
var nvsim = "∼⃒";
var nwarhk = "⤣";
var nwArr = "⇖";
var nwarr = "↖";
var nwarrow = "↖";
var nwnear = "⤧";
var Oacute = "Ó";
var oacute = "ó";
var oast = "⊛";
var ocir = "⊚";
var Ocirc = "Ô";
var ocirc = "ô";
var Ocy = "О";
var ocy = "о";
var odash = "⊝";
var Odblac = "Ő";
var odblac = "ő";
var odiv = "⨸";
var odot = "⊙";
var odsold = "⦼";
var OElig = "Œ";
var oelig = "œ";
var ofcir = "⦿";
var Ofr = "𝔒";
var ofr = "𝔬";
var ogon = "˛";
var Ograve = "Ò";
var ograve = "ò";
var ogt$1 = "⧁";
var ohbar = "⦵";
var ohm$1 = "Ω";
var oint = "∮";
var olarr = "↺";
var olcir = "⦾";
var olcross = "⦻";
var oline$1 = "‾";
var olt$1 = "⧀";
var Omacr = "Ō";
var omacr = "ō";
var Omega$1 = "Ω";
var omega$1 = "ω";
var Omicron$1 = "Ο";
var omicron$1 = "ο";
var omid = "⦶";
var ominus = "⊖";
var Oopf = "𝕆";
var oopf$1 = "𝕠";
var opar$1 = "⦷";
var OpenCurlyDoubleQuote = "“";
var OpenCurlyQuote = "‘";
var operp = "⦹";
var oplus = "⊕";
var Or = "⩔";
var or$1 = "∨";
var orarr = "↻";
var ord = "⩝";
var order$1 = "ℴ";
var orderof = "ℴ";
var ordf = "ª";
var ordm = "º";
var origof = "⊶";
var oror$1 = "⩖";
var orslope = "⩗";
var orv$1 = "⩛";
var oS = "Ⓢ";
var Oscr = "𝒪";
var oscr = "ℴ";
var Oslash = "Ø";
var oslash = "ø";
var osol$1 = "⊘";
var Otilde = "Õ";
var otilde = "õ";
var Otimes = "⨷";
var otimes = "⊗";
var otimesas = "⨶";
var Ouml = "Ö";
var ouml = "ö";
var ovbar = "⌽";
var OverBar = "‾";
var OverBrace = "⏞";
var OverBracket = "⎴";
var OverParenthesis = "⏜";
var par$1 = "∥";
var para$1 = "¶";
var parallel$1 = "∥";
var parsim = "⫳";
var parsl = "⫽";
var part$1 = "∂";
var PartialD = "∂";
var Pcy = "П";
var pcy = "п";
var percnt = "%";
var period = ".";
var permil = "‰";
var perp = "⊥";
var pertenk = "‱";
var Pfr = "𝔓";
var pfr = "𝔭";
var Phi = "Φ";
var phi$1 = "φ";
var phiv = "ϕ";
var phmmat = "ℳ";
var phone$1 = "☎";
var Pi$1 = "Π";
var pi$1 = "π";
var pitchfork$1 = "⋔";
var piv = "ϖ";
var planck = "ℏ";
var planckh = "ℎ";
var plankv = "ℏ";
var plus$1 = "+";
var plusacir = "⨣";
var plusb = "⊞";
var pluscir = "⨢";
var plusdo = "∔";
var plusdu = "⨥";
var pluse = "⩲";
var PlusMinus = "±";
var plusmn = "±";
var plussim = "⨦";
var plustwo = "⨧";
var pm$1 = "±";
var Poincareplane = "ℌ";
var pointint = "⨕";
var Popf = "ℙ";
var popf$1 = "𝕡";
var pound$1 = "£";
var Pr = "⪻";
var pr$1 = "≺";
var prap = "⪷";
var prcue = "≼";
var prE = "⪳";
var pre = "⪯";
var prec = "≺";
var precapprox = "⪷";
var preccurlyeq = "≼";
var Precedes = "≺";
var PrecedesEqual = "⪯";
var PrecedesSlantEqual = "≼";
var PrecedesTilde = "≾";
var preceq = "⪯";
var precnapprox = "⪹";
var precneqq = "⪵";
var precnsim = "⋨";
var precsim = "≾";
var Prime = "″";
var prime$1 = "′";
var primes$1 = "ℙ";
var prnap = "⪹";
var prnE = "⪵";
var prnsim = "⋨";
var prod$1 = "∏";
var Product$1 = "∏";
var profalar = "⌮";
var profline = "⌒";
var profsurf = "⌓";
var prop$1 = "∝";
var Proportion$1 = "∷";
var Proportional$1 = "∝";
var propto = "∝";
var prsim = "≾";
var prurel = "⊰";
var Pscr = "𝒫";
var pscr = "𝓅";
var Psi = "Ψ";
var psi$1 = "ψ";
var puncsp = " ";
var Qfr = "𝔔";
var qfr = "𝔮";
var qint = "⨌";
var Qopf = "ℚ";
var qopf = "𝕢";
var qprime = "⁗";
var Qscr = "𝒬";
var qscr = "𝓆";
var quaternions = "ℍ";
var quatint = "⨖";
var quest$1 = "?";
var questeq = "≟";
var QUOT$1 = "\"";
var quot$1 = "\"";
var rAarr = "⇛";
var race$1 = "∽̱";
var Racute = "Ŕ";
var racute = "ŕ";
var radic = "√";
var raemptyv = "⦳";
var Rang = "⟫";
var rang$1 = "⟩";
var rangd = "⦒";
var range$1 = "⦥";
var rangle = "⟩";
var raquo = "»";
var Rarr = "↠";
var rArr = "⇒";
var rarr = "→";
var rarrap = "⥵";
var rarrb = "⇥";
var rarrbfs = "⤠";
var rarrc = "⤳";
var rarrfs = "⤞";
var rarrhk = "↪";
var rarrlp = "↬";
var rarrpl = "⥅";
var rarrsim = "⥴";
var Rarrtl = "⤖";
var rarrtl = "↣";
var rarrw = "↝";
var rAtail = "⤜";
var ratail = "⤚";
var ratio$1 = "∶";
var rationals = "ℚ";
var RBarr = "⤐";
var rBarr = "⤏";
var rbarr = "⤍";
var rbbrk = "❳";
var rbrace = "}";
var rbrack = "]";
var rbrke = "⦌";
var rbrksld = "⦎";
var rbrkslu = "⦐";
var Rcaron = "Ř";
var rcaron = "ř";
var Rcedil = "Ŗ";
var rcedil = "ŗ";
var rceil = "⌉";
var rcub = "}";
var Rcy = "Р";
var rcy = "р";
var rdca = "⤷";
var rdldhar = "⥩";
var rdquo = "”";
var rdquor = "”";
var rdsh = "↳";
var Re$1 = "ℜ";
var real$1 = "ℜ";
var realine = "ℛ";
var realpart = "ℜ";
var reals$1 = "ℝ";
var rect$1 = "▭";
var REG$1 = "®";
var reg$1 = "®";
var ReverseElement = "∋";
var ReverseEquilibrium = "⇋";
var ReverseUpEquilibrium = "⥯";
var rfisht = "⥽";
var rfloor = "⌋";
var Rfr = "ℜ";
var rfr = "𝔯";
var rHar = "⥤";
var rhard = "⇁";
var rharu = "⇀";
var rharul = "⥬";
var Rho = "Ρ";
var rho = "ρ";
var rhov = "ϱ";
var RightAngleBracket = "⟩";
var RightArrow = "→";
var Rightarrow = "⇒";
var rightarrow = "→";
var RightArrowBar = "⇥";
var RightArrowLeftArrow = "⇄";
var rightarrowtail = "↣";
var RightCeiling = "⌉";
var RightDoubleBracket = "⟧";
var RightDownTeeVector = "⥝";
var RightDownVector = "⇂";
var RightDownVectorBar = "⥕";
var RightFloor = "⌋";
var rightharpoondown = "⇁";
var rightharpoonup = "⇀";
var rightleftarrows = "⇄";
var rightleftharpoons = "⇌";
var rightrightarrows = "⇉";
var rightsquigarrow = "↝";
var RightTee = "⊢";
var RightTeeArrow = "↦";
var RightTeeVector = "⥛";
var rightthreetimes = "⋌";
var RightTriangle = "⊳";
var RightTriangleBar = "⧐";
var RightTriangleEqual = "⊵";
var RightUpDownVector = "⥏";
var RightUpTeeVector = "⥜";
var RightUpVector = "↾";
var RightUpVectorBar = "⥔";
var RightVector = "⇀";
var RightVectorBar = "⥓";
var ring$1 = "˚";
var risingdotseq = "≓";
var rlarr = "⇄";
var rlhar = "⇌";
var rlm = "‏";
var rmoust = "⎱";
var rmoustache = "⎱";
var rnmid = "⫮";
var roang = "⟭";
var roarr = "⇾";
var robrk = "⟧";
var ropar = "⦆";
var Ropf = "ℝ";
var ropf = "𝕣";
var roplus = "⨮";
var rotimes = "⨵";
var RoundImplies = "⥰";
var rpar = ")";
var rpargt = "⦔";
var rppolint = "⨒";
var rrarr = "⇉";
var Rrightarrow = "⇛";
var rsaquo = "›";
var Rscr = "ℛ";
var rscr = "𝓇";
var Rsh = "↱";
var rsh$1 = "↱";
var rsqb = "]";
var rsquo = "’";
var rsquor = "’";
var rthree = "⋌";
var rtimes = "⋊";
var rtri = "▹";
var rtrie = "⊵";
var rtrif = "▸";
var rtriltri = "⧎";
var RuleDelayed = "⧴";
var ruluhar = "⥨";
var rx = "℞";
var Sacute = "Ś";
var sacute = "ś";
var sbquo = "‚";
var Sc = "⪼";
var sc$1 = "≻";
var scap$1 = "⪸";
var Scaron = "Š";
var scaron = "š";
var sccue = "≽";
var scE = "⪴";
var sce$1 = "⪰";
var Scedil = "Ş";
var scedil = "ş";
var Scirc = "Ŝ";
var scirc = "ŝ";
var scnap = "⪺";
var scnE = "⪶";
var scnsim = "⋩";
var scpolint = "⨓";
var scsim = "≿";
var Scy = "С";
var scy$1 = "с";
var sdot$1 = "⋅";
var sdotb = "⊡";
var sdote = "⩦";
var searhk = "⤥";
var seArr = "⇘";
var searr = "↘";
var searrow = "↘";
var sect$1 = "§";
var semi$1 = ";";
var seswar = "⤩";
var setminus = "∖";
var setmn = "∖";
var sext = "✶";
var Sfr = "𝔖";
var sfr = "𝔰";
var sfrown = "⌢";
var sharp$1 = "♯";
var SHCHcy = "Щ";
var shchcy = "щ";
var SHcy = "Ш";
var shcy = "ш";
var ShortDownArrow = "↓";
var ShortLeftArrow = "←";
var shortmid = "∣";
var shortparallel = "∥";
var ShortRightArrow = "→";
var ShortUpArrow = "↑";
var shy$1 = "­";
var Sigma$1 = "Σ";
var sigma$1 = "σ";
var sigmaf = "ς";
var sigmav = "ς";
var sim$1 = "∼";
var simdot = "⩪";
var sime = "≃";
var simeq = "≃";
var simg = "⪞";
var simgE = "⪠";
var siml = "⪝";
var simlE = "⪟";
var simne = "≆";
var simplus = "⨤";
var simrarr = "⥲";
var slarr = "←";
var SmallCircle = "∘";
var smallsetminus = "∖";
var smashp = "⨳";
var smeparsl = "⧤";
var smid = "∣";
var smile = "⌣";
var smt = "⪪";
var smte = "⪬";
var smtes = "⪬︀";
var SOFTcy = "Ь";
var softcy = "ь";
var sol$1 = "/";
var solb = "⧄";
var solbar = "⌿";
var Sopf = "𝕊";
var sopf = "𝕤";
var spades$1 = "♠";
var spadesuit = "♠";
var spar = "∥";
var sqcap = "⊓";
var sqcaps = "⊓︀";
var sqcup = "⊔";
var sqcups = "⊔︀";
var Sqrt = "√";
var sqsub = "⊏";
var sqsube = "⊑";
var sqsubset = "⊏";
var sqsubseteq = "⊑";
var sqsup = "⊐";
var sqsupe = "⊒";
var sqsupset = "⊐";
var sqsupseteq = "⊒";
var squ = "□";
var Square = "□";
var square$1 = "□";
var SquareIntersection = "⊓";
var SquareSubset = "⊏";
var SquareSubsetEqual = "⊑";
var SquareSuperset = "⊐";
var SquareSupersetEqual = "⊒";
var SquareUnion = "⊔";
var squarf = "▪";
var squf = "▪";
var srarr = "→";
var Sscr = "𝒮";
var sscr = "𝓈";
var ssetmn = "∖";
var ssmile = "⌣";
var sstarf = "⋆";
var Star$1 = "⋆";
var star$1 = "☆";
var starf = "★";
var straightepsilon = "ϵ";
var straightphi = "ϕ";
var strns = "¯";
var Sub$1 = "⋐";
var sub$1 = "⊂";
var subdot = "⪽";
var subE = "⫅";
var sube$1 = "⊆";
var subedot = "⫃";
var submult = "⫁";
var subnE = "⫋";
var subne = "⊊";
var subplus = "⪿";
var subrarr = "⥹";
var Subset = "⋐";
var subset = "⊂";
var subseteq = "⊆";
var subseteqq = "⫅";
var SubsetEqual = "⊆";
var subsetneq = "⊊";
var subsetneqq = "⫋";
var subsim = "⫇";
var subsub = "⫕";
var subsup = "⫓";
var succ = "≻";
var succapprox = "⪸";
var succcurlyeq = "≽";
var Succeeds = "≻";
var SucceedsEqual = "⪰";
var SucceedsSlantEqual = "≽";
var SucceedsTilde = "≿";
var succeq = "⪰";
var succnapprox = "⪺";
var succneqq = "⪶";
var succnsim = "⋩";
var succsim = "≿";
var SuchThat = "∋";
var Sum$1 = "∑";
var sum$1 = "∑";
var sung = "♪";
var Sup = "⋑";
var sup = "⊃";
var sup1 = "¹";
var sup2 = "²";
var sup3 = "³";
var supdot = "⪾";
var supdsub = "⫘";
var supE = "⫆";
var supe = "⊇";
var supedot = "⫄";
var Superset = "⊃";
var SupersetEqual = "⊇";
var suphsol = "⟉";
var suphsub = "⫗";
var suplarr = "⥻";
var supmult = "⫂";
var supnE = "⫌";
var supne = "⊋";
var supplus = "⫀";
var Supset = "⋑";
var supset = "⊃";
var supseteq = "⊇";
var supseteqq = "⫆";
var supsetneq = "⊋";
var supsetneqq = "⫌";
var supsim = "⫈";
var supsub = "⫔";
var supsup = "⫖";
var swarhk = "⤦";
var swArr = "⇙";
var swarr = "↙";
var swarrow = "↙";
var swnwar = "⤪";
var szlig = "ß";
var Tab$1 = "\t";
var target$1 = "⌖";
var Tau$1 = "Τ";
var tau$1 = "τ";
var tbrk = "⎴";
var Tcaron = "Ť";
var tcaron = "ť";
var Tcedil = "Ţ";
var tcedil = "ţ";
var Tcy = "Т";
var tcy = "т";
var tdot = "⃛";
var telrec = "⌕";
var Tfr = "𝔗";
var tfr = "𝔱";
var there4 = "∴";
var Therefore = "∴";
var therefore$1 = "∴";
var Theta$1 = "Θ";
var theta$1 = "θ";
var thetasym = "ϑ";
var thetav = "ϑ";
var thickapprox = "≈";
var thicksim = "∼";
var ThickSpace = "  ";
var thinsp = " ";
var ThinSpace = " ";
var thkap = "≈";
var thksim = "∼";
var THORN$1 = "Þ";
var thorn$1 = "þ";
var Tilde$1 = "∼";
var tilde$1 = "˜";
var TildeEqual = "≃";
var TildeFullEqual = "≅";
var TildeTilde = "≈";
var times$1 = "×";
var timesb = "⊠";
var timesbar = "⨱";
var timesd = "⨰";
var tint$1 = "∭";
var toea = "⤨";
var top$1 = "⊤";
var topbot = "⌶";
var topcir = "⫱";
var Topf = "𝕋";
var topf = "𝕥";
var topfork = "⫚";
var tosa$1 = "⤩";
var tprime = "‴";
var TRADE$1 = "™";
var trade$1 = "™";
var triangle$1 = "▵";
var triangledown = "▿";
var triangleleft = "◃";
var trianglelefteq = "⊴";
var triangleq = "≜";
var triangleright = "▹";
var trianglerighteq = "⊵";
var tridot = "◬";
var trie$1 = "≜";
var triminus = "⨺";
var TripleDot = "⃛";
var triplus = "⨹";
var trisb = "⧍";
var tritime = "⨻";
var trpezium = "⏢";
var Tscr = "𝒯";
var tscr = "𝓉";
var TScy = "Ц";
var tscy = "ц";
var TSHcy = "Ћ";
var tshcy = "ћ";
var Tstrok = "Ŧ";
var tstrok = "ŧ";
var twixt = "≬";
var twoheadleftarrow = "↞";
var twoheadrightarrow = "↠";
var Uacute = "Ú";
var uacute = "ú";
var Uarr = "↟";
var uArr = "⇑";
var uarr = "↑";
var Uarrocir = "⥉";
var Ubrcy = "Ў";
var ubrcy = "ў";
var Ubreve = "Ŭ";
var ubreve = "ŭ";
var Ucirc = "Û";
var ucirc = "û";
var Ucy = "У";
var ucy$1 = "у";
var udarr = "⇅";
var Udblac = "Ű";
var udblac = "ű";
var udhar = "⥮";
var ufisht = "⥾";
var Ufr = "𝔘";
var ufr = "𝔲";
var Ugrave = "Ù";
var ugrave = "ù";
var uHar = "⥣";
var uharl = "↿";
var uharr = "↾";
var uhblk = "▀";
var ulcorn = "⌜";
var ulcorner = "⌜";
var ulcrop = "⌏";
var ultri = "◸";
var Umacr = "Ū";
var umacr = "ū";
var uml$1 = "¨";
var UnderBar = "_";
var UnderBrace = "⏟";
var UnderBracket = "⎵";
var UnderParenthesis = "⏝";
var Union$1 = "⋃";
var UnionPlus = "⊎";
var Uogon = "Ų";
var uogon = "ų";
var Uopf = "𝕌";
var uopf = "𝕦";
var UpArrow = "↑";
var Uparrow = "⇑";
var uparrow = "↑";
var UpArrowBar = "⤒";
var UpArrowDownArrow = "⇅";
var UpDownArrow = "↕";
var Updownarrow = "⇕";
var updownarrow = "↕";
var UpEquilibrium = "⥮";
var upharpoonleft = "↿";
var upharpoonright = "↾";
var uplus$1 = "⊎";
var UpperLeftArrow = "↖";
var UpperRightArrow = "↗";
var Upsi$1 = "ϒ";
var upsi$1 = "υ";
var upsih = "ϒ";
var Upsilon = "Υ";
var upsilon = "υ";
var UpTee = "⊥";
var UpTeeArrow = "↥";
var upuparrows = "⇈";
var urcorn = "⌝";
var urcorner = "⌝";
var urcrop = "⌎";
var Uring = "Ů";
var uring$1 = "ů";
var urtri = "◹";
var Uscr = "𝒰";
var uscr = "𝓊";
var utdot = "⋰";
var Utilde = "Ũ";
var utilde = "ũ";
var utri = "▵";
var utrif = "▴";
var uuarr = "⇈";
var Uuml = "Ü";
var uuml = "ü";
var uwangle = "⦧";
var vangrt = "⦜";
var varepsilon = "ϵ";
var varkappa = "ϰ";
var varnothing = "∅";
var varphi = "ϕ";
var varpi = "ϖ";
var varpropto = "∝";
var vArr = "⇕";
var varr = "↕";
var varrho = "ϱ";
var varsigma = "ς";
var varsubsetneq = "⊊︀";
var varsubsetneqq = "⫋︀";
var varsupsetneq = "⊋︀";
var varsupsetneqq = "⫌︀";
var vartheta = "ϑ";
var vartriangleleft = "⊲";
var vartriangleright = "⊳";
var Vbar = "⫫";
var vBar = "⫨";
var vBarv = "⫩";
var Vcy = "В";
var vcy = "в";
var VDash = "⊫";
var Vdash = "⊩";
var vDash = "⊨";
var vdash = "⊢";
var Vdashl = "⫦";
var Vee = "⋁";
var vee$1 = "∨";
var veebar = "⊻";
var veeeq = "≚";
var vellip = "⋮";
var Verbar = "‖";
var verbar = "|";
var Vert$1 = "‖";
var vert$1 = "|";
var VerticalBar = "∣";
var VerticalLine = "|";
var VerticalSeparator = "❘";
var VerticalTilde = "≀";
var VeryThinSpace = " ";
var Vfr = "𝔙";
var vfr = "𝔳";
var vltri = "⊲";
var vnsub = "⊂⃒";
var vnsup = "⊃⃒";
var Vopf = "𝕍";
var vopf = "𝕧";
var vprop = "∝";
var vrtri = "⊳";
var Vscr = "𝒱";
var vscr = "𝓋";
var vsubnE = "⫋︀";
var vsubne = "⊊︀";
var vsupnE = "⫌︀";
var vsupne = "⊋︀";
var Vvdash = "⊪";
var vzigzag = "⦚";
var Wcirc = "Ŵ";
var wcirc = "ŵ";
var wedbar = "⩟";
var Wedge$1 = "⋀";
var wedge$1 = "∧";
var wedgeq = "≙";
var weierp = "℘";
var Wfr = "𝔚";
var wfr = "𝔴";
var Wopf = "𝕎";
var wopf = "𝕨";
var wp = "℘";
var wr = "≀";
var wreath$1 = "≀";
var Wscr = "𝒲";
var wscr = "𝓌";
var xcap = "⋂";
var xcirc = "◯";
var xcup = "⋃";
var xdtri = "▽";
var Xfr = "𝔛";
var xfr = "𝔵";
var xhArr = "⟺";
var xharr = "⟷";
var Xi$1 = "Ξ";
var xi$1 = "ξ";
var xlArr = "⟸";
var xlarr = "⟵";
var xmap = "⟼";
var xnis = "⋻";
var xodot = "⨀";
var Xopf = "𝕏";
var xopf = "𝕩";
var xoplus = "⨁";
var xotime = "⨂";
var xrArr = "⟹";
var xrarr = "⟶";
var Xscr = "𝒳";
var xscr = "𝓍";
var xsqcup = "⨆";
var xuplus = "⨄";
var xutri = "△";
var xvee = "⋁";
var xwedge = "⋀";
var Yacute = "Ý";
var yacute = "ý";
var YAcy = "Я";
var yacy = "я";
var Ycirc$1 = "Ŷ";
var ycirc$1 = "ŷ";
var Ycy = "Ы";
var ycy$1 = "ы";
var yen$1 = "¥";
var Yfr = "𝔜";
var yfr = "𝔶";
var YIcy = "Ї";
var yicy = "ї";
var Yopf = "𝕐";
var yopf = "𝕪";
var Yscr = "𝒴";
var yscr = "𝓎";
var YUcy = "Ю";
var yucy = "ю";
var Yuml = "Ÿ";
var yuml = "ÿ";
var Zacute$1 = "Ź";
var zacute$1 = "ź";
var Zcaron = "Ž";
var zcaron = "ž";
var Zcy = "З";
var zcy = "з";
var Zdot = "Ż";
var zdot = "ż";
var zeetrf = "ℨ";
var ZeroWidthSpace = "​";
var Zeta$1 = "Ζ";
var zeta$1 = "ζ";
var Zfr = "ℨ";
var zfr = "𝔷";
var ZHcy = "Ж";
var zhcy = "ж";
var zigrarr = "⇝";
var Zopf = "ℤ";
var zopf = "𝕫";
var Zscr = "𝒵";
var zscr = "𝓏";
var zwj = "‍";
var zwnj = "‌";
var allNamedEntitiesJson = {
  Aacute: Aacute,
  aacute: aacute,
  Abreve: Abreve,
  abreve: abreve,
  ac: ac$1,
  acd: acd,
  acE: acE,
  Acirc: Acirc,
  acirc: acirc,
  acute: acute$1,
  Acy: Acy,
  acy: acy,
  AElig: AElig,
  aelig: aelig,
  af: af,
  Afr: Afr,
  afr: afr,
  Agrave: Agrave,
  agrave: agrave,
  alefsym: alefsym,
  aleph: aleph,
  Alpha: Alpha$1,
  alpha: alpha$1,
  Amacr: Amacr,
  amacr: amacr,
  amalg: amalg,
  AMP: AMP,
  amp: amp$1,
  And: And$1,
  and: and$1,
  andand: andand,
  andd: andd,
  andslope: andslope,
  andv: andv,
  ang: ang,
  ange: ange$1,
  angle: angle$1,
  angmsd: angmsd,
  angmsdaa: angmsdaa,
  angmsdab: angmsdab,
  angmsdac: angmsdac,
  angmsdad: angmsdad,
  angmsdae: angmsdae,
  angmsdaf: angmsdaf,
  angmsdag: angmsdag,
  angmsdah: angmsdah,
  angrt: angrt,
  angrtvb: angrtvb,
  angrtvbd: angrtvbd,
  angsph: angsph,
  angst: angst$1,
  angzarr: angzarr,
  Aogon: Aogon,
  aogon: aogon,
  Aopf: Aopf,
  aopf: aopf,
  ap: ap$1,
  apacir: apacir,
  apE: apE,
  ape: ape$1,
  apid: apid,
  apos: apos,
  ApplyFunction: ApplyFunction,
  approx: approx$1,
  approxeq: approxeq,
  Aring: Aring$1,
  aring: aring$1,
  Ascr: Ascr$1,
  ascr: ascr$1,
  Assign: Assign$1,
  ast: ast$1,
  asymp: asymp,
  asympeq: asympeq,
  Atilde: Atilde,
  atilde: atilde$1,
  Auml: Auml,
  auml: auml,
  awconint: awconint,
  awint: awint,
  backcong: backcong,
  backepsilon: backepsilon,
  backprime: backprime,
  backsim: backsim,
  backsimeq: backsimeq,
  Backslash: Backslash$1,
  Barv: Barv,
  barvee: barvee,
  Barwed: Barwed,
  barwed: barwed,
  barwedge: barwedge$1,
  bbrk: bbrk,
  bbrktbrk: bbrktbrk,
  bcong: bcong,
  Bcy: Bcy,
  bcy: bcy,
  bdquo: bdquo,
  becaus: becaus$1,
  Because: Because$1,
  because: because$1,
  bemptyv: bemptyv,
  bepsi: bepsi$1,
  bernou: bernou,
  Bernoullis: Bernoullis$1,
  Beta: Beta$1,
  beta: beta$1,
  beth: beth$1,
  between: between$1,
  Bfr: Bfr,
  bfr: bfr,
  bigcap: bigcap,
  bigcirc: bigcirc,
  bigcup: bigcup,
  bigodot: bigodot,
  bigoplus: bigoplus,
  bigotimes: bigotimes,
  bigsqcup: bigsqcup,
  bigstar: bigstar,
  bigtriangledown: bigtriangledown,
  bigtriangleup: bigtriangleup,
  biguplus: biguplus,
  bigvee: bigvee,
  bigwedge: bigwedge,
  bkarow: bkarow,
  blacklozenge: blacklozenge,
  blacksquare: blacksquare,
  blacktriangle: blacktriangle,
  blacktriangledown: blacktriangledown,
  blacktriangleleft: blacktriangleleft,
  blacktriangleright: blacktriangleright,
  blank: blank$1,
  blk12: blk12,
  blk14: blk14,
  blk34: blk34,
  block: block$1,
  bne: bne,
  bnequiv: bnequiv,
  bNot: bNot,
  bnot: bnot,
  Bopf: Bopf,
  bopf: bopf,
  bot: bot$1,
  bottom: bottom$1,
  bowtie: bowtie$1,
  boxbox: boxbox,
  boxDL: boxDL,
  boxDl: boxDl,
  boxdL: boxdL,
  boxdl: boxdl,
  boxDR: boxDR,
  boxDr: boxDr,
  boxdR: boxdR,
  boxdr: boxdr,
  boxH: boxH,
  boxh: boxh,
  boxHD: boxHD,
  boxHd: boxHd,
  boxhD: boxhD,
  boxhd: boxhd,
  boxHU: boxHU,
  boxHu: boxHu,
  boxhU: boxhU,
  boxhu: boxhu,
  boxminus: boxminus,
  boxplus: boxplus,
  boxtimes: boxtimes,
  boxUL: boxUL,
  boxUl: boxUl,
  boxuL: boxuL,
  boxul: boxul,
  boxUR: boxUR,
  boxUr: boxUr,
  boxuR: boxuR,
  boxur: boxur,
  boxV: boxV,
  boxv: boxv,
  boxVH: boxVH,
  boxVh: boxVh,
  boxvH: boxvH,
  boxvh: boxvh,
  boxVL: boxVL,
  boxVl: boxVl,
  boxvL: boxvL,
  boxvl: boxvl,
  boxVR: boxVR,
  boxVr: boxVr,
  boxvR: boxvR,
  boxvr: boxvr,
  bprime: bprime,
  Breve: Breve,
  breve: breve$1,
  brvbar: brvbar,
  Bscr: Bscr,
  bscr: bscr,
  bsemi: bsemi,
  bsim: bsim,
  bsime: bsime,
  bsol: bsol,
  bsolb: bsolb,
  bsolhsub: bsolhsub,
  bull: bull$1,
  bullet: bullet$1,
  bump: bump$1,
  bumpE: bumpE,
  bumpe: bumpe,
  Bumpeq: Bumpeq,
  bumpeq: bumpeq,
  Cacute: Cacute,
  cacute: cacute$1,
  Cap: Cap$1,
  cap: cap$1,
  capand: capand$1,
  capbrcup: capbrcup,
  capcap: capcap,
  capcup: capcup,
  capdot: capdot,
  CapitalDifferentialD: CapitalDifferentialD,
  caps: caps$1,
  caret: caret$1,
  caron: caron$1,
  Cayleys: Cayleys,
  ccaps: ccaps,
  Ccaron: Ccaron,
  ccaron: ccaron,
  Ccedil: Ccedil,
  ccedil: ccedil,
  Ccirc: Ccirc,
  ccirc: ccirc,
  Cconint: Cconint,
  ccups: ccups,
  ccupssm: ccupssm,
  Cdot: Cdot,
  cdot: cdot,
  cedil: cedil$1,
  Cedilla: Cedilla$1,
  cemptyv: cemptyv,
  cent: cent$1,
  CenterDot: CenterDot,
  centerdot: centerdot,
  Cfr: Cfr,
  cfr: cfr,
  CHcy: CHcy,
  chcy: chcy,
  check: check$1,
  checkmark: checkmark$1,
  Chi: Chi$1,
  chi: chi$1,
  cir: cir$1,
  circ: circ$1,
  circeq: circeq,
  circlearrowleft: circlearrowleft,
  circlearrowright: circlearrowright,
  circledast: circledast,
  circledcirc: circledcirc,
  circleddash: circleddash,
  CircleDot: CircleDot,
  circledR: circledR,
  circledS: circledS,
  CircleMinus: CircleMinus,
  CirclePlus: CirclePlus,
  CircleTimes: CircleTimes,
  cirE: cirE,
  cire: cire,
  cirfnint: cirfnint,
  cirmid: cirmid,
  cirscir: cirscir,
  ClockwiseContourIntegral: ClockwiseContourIntegral,
  CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
  CloseCurlyQuote: CloseCurlyQuote,
  clubs: clubs$1,
  clubsuit: clubsuit$1,
  Colon: Colon$1,
  colon: colon$1,
  Colone: Colone$1,
  colone: colone$1,
  coloneq: coloneq,
  comma: comma$1,
  commat: commat$1,
  comp: comp$1,
  compfn: compfn,
  complement: complement$1,
  complexes: complexes$1,
  cong: cong$1,
  congdot: congdot,
  Congruent: Congruent$1,
  Conint: Conint,
  conint: conint$1,
  ContourIntegral: ContourIntegral,
  Copf: Copf,
  copf: copf$1,
  coprod: coprod$1,
  Coproduct: Coproduct,
  COPY: COPY$1,
  copy: copy$1,
  copysr: copysr,
  CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
  crarr: crarr,
  Cross: Cross$1,
  cross: cross$1,
  Cscr: Cscr,
  cscr: cscr,
  csub: csub,
  csube: csube,
  csup: csup,
  csupe: csupe,
  ctdot: ctdot,
  cudarrl: cudarrl,
  cudarrr: cudarrr,
  cuepr: cuepr,
  cuesc: cuesc,
  cularr: cularr,
  cularrp: cularrp,
  Cup: Cup$1,
  cup: cup$1,
  cupbrcap: cupbrcap,
  CupCap: CupCap,
  cupcap: cupcap,
  cupcup: cupcup,
  cupdot: cupdot,
  cupor: cupor,
  cups: cups$1,
  curarr: curarr,
  curarrm: curarrm,
  curlyeqprec: curlyeqprec,
  curlyeqsucc: curlyeqsucc,
  curlyvee: curlyvee,
  curlywedge: curlywedge,
  curren: curren,
  curvearrowleft: curvearrowleft,
  curvearrowright: curvearrowright,
  cuvee: cuvee,
  cuwed: cuwed,
  cwconint: cwconint,
  cwint: cwint,
  cylcty: cylcty,
  Dagger: Dagger$1,
  dagger: dagger$1,
  daleth: daleth$1,
  Darr: Darr,
  dArr: dArr,
  darr: darr$1,
  dash: dash$1,
  Dashv: Dashv,
  dashv: dashv,
  dbkarow: dbkarow,
  dblac: dblac,
  Dcaron: Dcaron,
  dcaron: dcaron,
  Dcy: Dcy,
  dcy: dcy,
  DD: DD$1,
  dd: dd$1,
  ddagger: ddagger,
  ddarr: ddarr,
  DDotrahd: DDotrahd,
  ddotseq: ddotseq,
  deg: deg$1,
  Del: Del$1,
  Delta: Delta$1,
  delta: delta$1,
  demptyv: demptyv,
  dfisht: dfisht,
  Dfr: Dfr,
  dfr: dfr,
  dHar: dHar,
  dharl: dharl,
  dharr: dharr$1,
  DiacriticalAcute: DiacriticalAcute,
  DiacriticalDot: DiacriticalDot,
  DiacriticalDoubleAcute: DiacriticalDoubleAcute,
  DiacriticalGrave: DiacriticalGrave,
  DiacriticalTilde: DiacriticalTilde,
  diam: diam$1,
  Diamond: Diamond$1,
  diamond: diamond$1,
  diamondsuit: diamondsuit,
  diams: diams$1,
  die: die$1,
  DifferentialD: DifferentialD,
  digamma: digamma$1,
  disin: disin$1,
  div: div$1,
  divide: divide$1,
  divideontimes: divideontimes,
  divonx: divonx,
  DJcy: DJcy,
  djcy: djcy,
  dlcorn: dlcorn,
  dlcrop: dlcrop,
  dollar: dollar$1,
  Dopf: Dopf,
  dopf: dopf$1,
  Dot: Dot$1,
  dot: dot$1,
  DotDot: DotDot,
  doteq: doteq,
  doteqdot: doteqdot,
  DotEqual: DotEqual,
  dotminus: dotminus,
  dotplus: dotplus,
  dotsquare: dotsquare,
  doublebarwedge: doublebarwedge,
  DoubleContourIntegral: DoubleContourIntegral,
  DoubleDot: DoubleDot,
  DoubleDownArrow: DoubleDownArrow,
  DoubleLeftArrow: DoubleLeftArrow,
  DoubleLeftRightArrow: DoubleLeftRightArrow,
  DoubleLeftTee: DoubleLeftTee,
  DoubleLongLeftArrow: DoubleLongLeftArrow,
  DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
  DoubleLongRightArrow: DoubleLongRightArrow,
  DoubleRightArrow: DoubleRightArrow,
  DoubleRightTee: DoubleRightTee,
  DoubleUpArrow: DoubleUpArrow,
  DoubleUpDownArrow: DoubleUpDownArrow,
  DoubleVerticalBar: DoubleVerticalBar,
  DownArrow: DownArrow,
  Downarrow: Downarrow,
  downarrow: downarrow,
  DownArrowBar: DownArrowBar,
  DownArrowUpArrow: DownArrowUpArrow,
  DownBreve: DownBreve,
  downdownarrows: downdownarrows,
  downharpoonleft: downharpoonleft,
  downharpoonright: downharpoonright,
  DownLeftRightVector: DownLeftRightVector,
  DownLeftTeeVector: DownLeftTeeVector,
  DownLeftVector: DownLeftVector,
  DownLeftVectorBar: DownLeftVectorBar,
  DownRightTeeVector: DownRightTeeVector,
  DownRightVector: DownRightVector,
  DownRightVectorBar: DownRightVectorBar,
  DownTee: DownTee,
  DownTeeArrow: DownTeeArrow,
  drbkarow: drbkarow,
  drcorn: drcorn,
  drcrop: drcrop,
  Dscr: Dscr,
  dscr: dscr,
  DScy: DScy,
  dscy: dscy,
  dsol: dsol$1,
  Dstrok: Dstrok,
  dstrok: dstrok,
  dtdot: dtdot,
  dtri: dtri$1,
  dtrif: dtrif,
  duarr: duarr,
  duhar: duhar,
  dwangle: dwangle,
  DZcy: DZcy,
  dzcy: dzcy,
  dzigrarr: dzigrarr,
  Eacute: Eacute,
  eacute: eacute,
  easter: easter$1,
  Ecaron: Ecaron,
  ecaron: ecaron,
  ecir: ecir$1,
  Ecirc: Ecirc,
  ecirc: ecirc,
  ecolon: ecolon$1,
  Ecy: Ecy,
  ecy: ecy$1,
  eDDot: eDDot,
  Edot: Edot,
  eDot: eDot,
  edot: edot$1,
  ee: ee$1,
  efDot: efDot,
  Efr: Efr,
  efr: efr$1,
  eg: eg$1,
  Egrave: Egrave,
  egrave: egrave$1,
  egs: egs$1,
  egsdot: egsdot,
  el: el$1,
  Element: Element,
  elinters: elinters,
  ell: ell$1,
  els: els$1,
  elsdot: elsdot,
  Emacr: Emacr,
  emacr: emacr,
  empty: empty$1,
  emptyset: emptyset,
  EmptySmallSquare: EmptySmallSquare,
  emptyv: emptyv,
  EmptyVerySmallSquare: EmptyVerySmallSquare,
  emsp: emsp,
  emsp13: emsp13,
  emsp14: emsp14,
  ENG: ENG$1,
  eng: eng$1,
  ensp: ensp,
  Eogon: Eogon,
  eogon: eogon,
  Eopf: Eopf,
  eopf: eopf,
  epar: epar,
  eparsl: eparsl,
  eplus: eplus,
  epsi: epsi$1,
  Epsilon: Epsilon$1,
  epsilon: epsilon$1,
  epsiv: epsiv,
  eqcirc: eqcirc,
  eqcolon: eqcolon,
  eqsim: eqsim,
  eqslantgtr: eqslantgtr,
  eqslantless: eqslantless,
  Equal: Equal$1,
  equals: equals$1,
  EqualTilde: EqualTilde,
  equest: equest$1,
  Equilibrium: Equilibrium$1,
  equiv: equiv$1,
  equivDD: equivDD,
  eqvparsl: eqvparsl,
  erarr: erarr,
  erDot: erDot,
  Escr: Escr,
  escr: escr$1,
  esdot: esdot,
  Esim: Esim,
  esim: esim$1,
  Eta: Eta$1,
  eta: eta$1,
  ETH: ETH$1,
  eth: eth$1,
  Euml: Euml,
  euml: euml,
  euro: euro$1,
  excl: excl$1,
  exist: exist$1,
  Exists: Exists$1,
  expectation: expectation$1,
  ExponentialE: ExponentialE,
  exponentiale: exponentiale,
  fallingdotseq: fallingdotseq,
  Fcy: Fcy,
  fcy: fcy,
  female: female$1,
  ffilig: ffilig,
  fflig: fflig,
  ffllig: ffllig,
  Ffr: Ffr,
  ffr: ffr,
  filig: filig,
  FilledSmallSquare: FilledSmallSquare,
  FilledVerySmallSquare: FilledVerySmallSquare,
  fjlig: fjlig,
  flat: flat$1,
  fllig: fllig,
  fltns: fltns,
  fnof: fnof,
  Fopf: Fopf,
  fopf: fopf,
  ForAll: ForAll,
  forall: forall,
  fork: fork$1,
  forkv: forkv,
  Fouriertrf: Fouriertrf,
  fpartint: fpartint,
  frac12: frac12,
  frac13: frac13,
  frac14: frac14,
  frac15: frac15,
  frac16: frac16,
  frac18: frac18,
  frac23: frac23,
  frac25: frac25,
  frac34: frac34,
  frac35: frac35,
  frac38: frac38,
  frac45: frac45,
  frac56: frac56,
  frac58: frac58,
  frac78: frac78,
  frasl: frasl,
  frown: frown$1,
  Fscr: Fscr,
  fscr: fscr,
  gacute: gacute,
  Gamma: Gamma$1,
  gamma: gamma$1,
  Gammad: Gammad,
  gammad: gammad,
  gap: gap$1,
  Gbreve: Gbreve,
  gbreve: gbreve,
  Gcedil: Gcedil,
  Gcirc: Gcirc,
  gcirc: gcirc,
  Gcy: Gcy,
  gcy: gcy$1,
  Gdot: Gdot,
  gdot: gdot,
  gE: gE,
  ge: ge$1,
  gEl: gEl,
  gel: gel$1,
  geq: geq$1,
  geqq: geqq,
  geqslant: geqslant,
  ges: ges$1,
  gescc: gescc,
  gesdot: gesdot,
  gesdoto: gesdoto,
  gesdotol: gesdotol,
  gesl: gesl$1,
  gesles: gesles,
  Gfr: Gfr,
  gfr: gfr,
  Gg: Gg,
  gg: gg$1,
  ggg: ggg,
  gimel: gimel,
  GJcy: GJcy,
  gjcy: gjcy,
  gl: gl$1,
  gla: gla$1,
  glE: glE,
  glj: glj,
  gnap: gnap,
  gnapprox: gnapprox,
  gnE: gnE,
  gne: gne$1,
  gneq: gneq,
  gneqq: gneqq,
  gnsim: gnsim,
  Gopf: Gopf,
  gopf: gopf,
  grave: grave$1,
  GreaterEqual: GreaterEqual,
  GreaterEqualLess: GreaterEqualLess,
  GreaterFullEqual: GreaterFullEqual,
  GreaterGreater: GreaterGreater,
  GreaterLess: GreaterLess,
  GreaterSlantEqual: GreaterSlantEqual,
  GreaterTilde: GreaterTilde,
  Gscr: Gscr,
  gscr: gscr,
  gsim: gsim,
  gsime: gsime,
  gsiml: gsiml,
  GT: GT$1,
  Gt: Gt,
  gt: gt$1,
  gtcc: gtcc,
  gtcir: gtcir,
  gtdot: gtdot,
  gtlPar: gtlPar,
  gtquest: gtquest,
  gtrapprox: gtrapprox,
  gtrarr: gtrarr,
  gtrdot: gtrdot,
  gtreqless: gtreqless,
  gtreqqless: gtreqqless,
  gtrless: gtrless,
  gtrsim: gtrsim,
  gvertneqq: gvertneqq,
  gvnE: gvnE,
  Hacek: Hacek,
  hairsp: hairsp,
  half: half$1,
  hamilt: hamilt,
  HARDcy: HARDcy,
  hardcy: hardcy,
  hArr: hArr,
  harr: harr,
  harrcir: harrcir,
  harrw: harrw,
  Hat: Hat$1,
  hbar: hbar,
  Hcirc: Hcirc,
  hcirc: hcirc,
  hearts: hearts$1,
  heartsuit: heartsuit,
  hellip: hellip,
  hercon: hercon,
  Hfr: Hfr,
  hfr: hfr,
  HilbertSpace: HilbertSpace,
  hksearow: hksearow,
  hkswarow: hkswarow,
  hoarr: hoarr,
  homtht: homtht,
  hookleftarrow: hookleftarrow,
  hookrightarrow: hookrightarrow,
  Hopf: Hopf,
  hopf: hopf$1,
  horbar: horbar,
  HorizontalLine: HorizontalLine,
  Hscr: Hscr,
  hscr: hscr,
  hslash: hslash,
  Hstrok: Hstrok,
  hstrok: hstrok,
  HumpDownHump: HumpDownHump,
  HumpEqual: HumpEqual,
  hybull: hybull,
  hyphen: hyphen$1,
  Iacute: Iacute,
  iacute: iacute,
  ic: ic$1,
  Icirc: Icirc,
  icirc: icirc,
  Icy: Icy,
  icy: icy$1,
  Idot: Idot,
  IEcy: IEcy,
  iecy: iecy,
  iexcl: iexcl,
  iff: iff$1,
  Ifr: Ifr,
  ifr: ifr,
  Igrave: Igrave,
  igrave: igrave,
  ii: ii$1,
  iiiint: iiiint,
  iiint: iiint,
  iinfin: iinfin,
  iiota: iiota,
  IJlig: IJlig,
  ijlig: ijlig,
  Im: Im,
  Imacr: Imacr,
  imacr: imacr,
  image: image$1,
  ImaginaryI: ImaginaryI,
  imagline: imagline,
  imagpart: imagpart,
  imath: imath,
  imof: imof,
  imped: imped$1,
  Implies: Implies,
  "in": "∈",
  incare: incare,
  infin: infin,
  infintie: infintie,
  inodot: inodot,
  Int: Int,
  int: int$1,
  intcal: intcal,
  integers: integers$1,
  Integral: Integral,
  intercal: intercal,
  Intersection: Intersection,
  intlarhk: intlarhk,
  intprod: intprod,
  InvisibleComma: InvisibleComma,
  InvisibleTimes: InvisibleTimes,
  IOcy: IOcy,
  iocy: iocy$1,
  Iogon: Iogon,
  iogon: iogon$1,
  Iopf: Iopf,
  iopf: iopf,
  Iota: Iota,
  iota: iota$1,
  iprod: iprod,
  iquest: iquest,
  Iscr: Iscr,
  iscr: iscr,
  isin: isin$1,
  isindot: isindot,
  isinE: isinE,
  isins: isins,
  isinsv: isinsv,
  isinv: isinv,
  it: it$1,
  Itilde: Itilde,
  itilde: itilde,
  Iukcy: Iukcy,
  iukcy: iukcy,
  Iuml: Iuml,
  iuml: iuml,
  Jcirc: Jcirc,
  jcirc: jcirc,
  Jcy: Jcy,
  jcy: jcy,
  Jfr: Jfr,
  jfr: jfr,
  jmath: jmath,
  Jopf: Jopf,
  jopf: jopf,
  Jscr: Jscr,
  jscr: jscr,
  Jsercy: Jsercy,
  jsercy: jsercy,
  Jukcy: Jukcy,
  jukcy: jukcy,
  Kappa: Kappa$1,
  kappa: kappa$1,
  kappav: kappav,
  Kcedil: Kcedil,
  kcedil: kcedil,
  Kcy: Kcy,
  kcy: kcy,
  Kfr: Kfr,
  kfr: kfr,
  kgreen: kgreen,
  KHcy: KHcy,
  khcy: khcy,
  KJcy: KJcy,
  kjcy: kjcy,
  Kopf: Kopf,
  kopf: kopf$1,
  Kscr: Kscr,
  kscr: kscr,
  lAarr: lAarr,
  Lacute: Lacute,
  lacute: lacute,
  laemptyv: laemptyv,
  lagran: lagran,
  Lambda: Lambda$1,
  lambda: lambda$1,
  Lang: Lang,
  lang: lang$1,
  langd: langd,
  langle: langle,
  lap: lap$1,
  Laplacetrf: Laplacetrf,
  laquo: laquo,
  Larr: Larr,
  lArr: lArr,
  larr: larr,
  larrb: larrb,
  larrbfs: larrbfs,
  larrfs: larrfs,
  larrhk: larrhk,
  larrlp: larrlp,
  larrpl: larrpl,
  larrsim: larrsim,
  larrtl: larrtl,
  lat: lat$1,
  lAtail: lAtail,
  latail: latail,
  late: late$1,
  lates: lates$1,
  lBarr: lBarr,
  lbarr: lbarr,
  lbbrk: lbbrk,
  lbrace: lbrace,
  lbrack: lbrack,
  lbrke: lbrke,
  lbrksld: lbrksld,
  lbrkslu: lbrkslu,
  Lcaron: Lcaron,
  lcaron: lcaron,
  Lcedil: Lcedil,
  lcedil: lcedil,
  lceil: lceil,
  lcub: lcub,
  Lcy: Lcy,
  lcy: lcy,
  ldca: ldca,
  ldquo: ldquo,
  ldquor: ldquor,
  ldrdhar: ldrdhar,
  ldrushar: ldrushar,
  ldsh: ldsh,
  lE: lE,
  le: le$1,
  LeftAngleBracket: LeftAngleBracket,
  LeftArrow: LeftArrow,
  Leftarrow: Leftarrow,
  leftarrow: leftarrow,
  LeftArrowBar: LeftArrowBar,
  LeftArrowRightArrow: LeftArrowRightArrow,
  leftarrowtail: leftarrowtail,
  LeftCeiling: LeftCeiling,
  LeftDoubleBracket: LeftDoubleBracket,
  LeftDownTeeVector: LeftDownTeeVector,
  LeftDownVector: LeftDownVector,
  LeftDownVectorBar: LeftDownVectorBar,
  LeftFloor: LeftFloor,
  leftharpoondown: leftharpoondown,
  leftharpoonup: leftharpoonup,
  leftleftarrows: leftleftarrows,
  LeftRightArrow: LeftRightArrow,
  Leftrightarrow: Leftrightarrow,
  leftrightarrow: leftrightarrow,
  leftrightarrows: leftrightarrows,
  leftrightharpoons: leftrightharpoons,
  leftrightsquigarrow: leftrightsquigarrow,
  LeftRightVector: LeftRightVector,
  LeftTee: LeftTee,
  LeftTeeArrow: LeftTeeArrow,
  LeftTeeVector: LeftTeeVector,
  leftthreetimes: leftthreetimes,
  LeftTriangle: LeftTriangle,
  LeftTriangleBar: LeftTriangleBar,
  LeftTriangleEqual: LeftTriangleEqual,
  LeftUpDownVector: LeftUpDownVector,
  LeftUpTeeVector: LeftUpTeeVector,
  LeftUpVector: LeftUpVector,
  LeftUpVectorBar: LeftUpVectorBar,
  LeftVector: LeftVector,
  LeftVectorBar: LeftVectorBar,
  lEg: lEg,
  leg: leg$1,
  leq: leq$1,
  leqq: leqq,
  leqslant: leqslant,
  les: les$1,
  lescc: lescc,
  lesdot: lesdot,
  lesdoto: lesdoto,
  lesdotor: lesdotor,
  lesg: lesg,
  lesges: lesges,
  lessapprox: lessapprox,
  lessdot: lessdot,
  lesseqgtr: lesseqgtr,
  lesseqqgtr: lesseqqgtr,
  LessEqualGreater: LessEqualGreater,
  LessFullEqual: LessFullEqual,
  LessGreater: LessGreater,
  lessgtr: lessgtr,
  LessLess: LessLess,
  lesssim: lesssim,
  LessSlantEqual: LessSlantEqual,
  LessTilde: LessTilde,
  lfisht: lfisht,
  lfloor: lfloor,
  Lfr: Lfr,
  lfr: lfr,
  lg: lg$1,
  lgE: lgE,
  lHar: lHar,
  lhard: lhard,
  lharu: lharu,
  lharul: lharul,
  lhblk: lhblk,
  LJcy: LJcy,
  ljcy: ljcy,
  Ll: Ll,
  ll: ll$1,
  llarr: llarr,
  llcorner: llcorner,
  Lleftarrow: Lleftarrow,
  llhard: llhard,
  lltri: lltri,
  Lmidot: Lmidot,
  lmidot: lmidot,
  lmoust: lmoust,
  lmoustache: lmoustache,
  lnap: lnap,
  lnapprox: lnapprox,
  lnE: lnE,
  lne: lne$1,
  lneq: lneq,
  lneqq: lneqq,
  lnsim: lnsim,
  loang: loang,
  loarr: loarr,
  lobrk: lobrk,
  LongLeftArrow: LongLeftArrow,
  Longleftarrow: Longleftarrow,
  longleftarrow: longleftarrow,
  LongLeftRightArrow: LongLeftRightArrow,
  Longleftrightarrow: Longleftrightarrow,
  longleftrightarrow: longleftrightarrow,
  longmapsto: longmapsto,
  LongRightArrow: LongRightArrow,
  Longrightarrow: Longrightarrow,
  longrightarrow: longrightarrow,
  looparrowleft: looparrowleft,
  looparrowright: looparrowright,
  lopar: lopar,
  Lopf: Lopf,
  lopf: lopf,
  loplus: loplus,
  lotimes: lotimes,
  lowast: lowast,
  lowbar: lowbar,
  LowerLeftArrow: LowerLeftArrow,
  LowerRightArrow: LowerRightArrow,
  loz: loz,
  lozenge: lozenge$1,
  lozf: lozf,
  lpar: lpar,
  lparlt: lparlt,
  lrarr: lrarr,
  lrcorner: lrcorner,
  lrhar: lrhar,
  lrhard: lrhard,
  lrm: lrm,
  lrtri: lrtri,
  lsaquo: lsaquo,
  Lscr: Lscr,
  lscr: lscr,
  Lsh: Lsh,
  lsh: lsh$1,
  lsim: lsim,
  lsime: lsime,
  lsimg: lsimg,
  lsqb: lsqb,
  lsquo: lsquo,
  lsquor: lsquor,
  Lstrok: Lstrok,
  lstrok: lstrok,
  LT: LT$1,
  Lt: Lt,
  lt: lt$1,
  ltcc: ltcc,
  ltcir: ltcir,
  ltdot: ltdot,
  lthree: lthree,
  ltimes: ltimes$1,
  ltlarr: ltlarr,
  ltquest: ltquest,
  ltri: ltri,
  ltrie: ltrie,
  ltrif: ltrif,
  ltrPar: ltrPar,
  lurdshar: lurdshar,
  luruhar: luruhar,
  lvertneqq: lvertneqq,
  lvnE: lvnE,
  macr: macr,
  male: male$1,
  malt: malt$1,
  maltese: maltese,
  "Map": "⤅",
  map: map$1,
  mapsto: mapsto,
  mapstodown: mapstodown,
  mapstoleft: mapstoleft,
  mapstoup: mapstoup,
  marker: marker$1,
  mcomma: mcomma,
  Mcy: Mcy,
  mcy: mcy,
  mdash: mdash,
  mDDot: mDDot,
  measuredangle: measuredangle,
  MediumSpace: MediumSpace,
  Mellintrf: Mellintrf,
  Mfr: Mfr,
  mfr: mfr,
  mho: mho,
  micro: micro,
  mid: mid$1,
  midast: midast,
  midcir: midcir,
  middot: middot,
  minus: minus$1,
  minusb: minusb,
  minusd: minusd,
  minusdu: minusdu,
  MinusPlus: MinusPlus,
  mlcp: mlcp,
  mldr: mldr,
  mnplus: mnplus,
  models: models$1,
  Mopf: Mopf,
  mopf: mopf,
  mp: mp$1,
  Mscr: Mscr,
  mscr: mscr,
  mstpos: mstpos,
  Mu: Mu,
  mu: mu$1,
  multimap: multimap,
  mumap: mumap,
  nabla: nabla,
  Nacute: Nacute,
  nacute: nacute,
  nang: nang$1,
  nap: nap$1,
  napE: napE,
  napid: napid,
  napos: napos,
  napprox: napprox,
  natur: natur,
  natural: natural$1,
  naturals: naturals$1,
  nbsp: nbsp,
  nbump: nbump,
  nbumpe: nbumpe,
  ncap: ncap,
  Ncaron: Ncaron,
  ncaron: ncaron,
  Ncedil: Ncedil,
  ncedil: ncedil,
  ncong: ncong,
  ncongdot: ncongdot,
  ncup: ncup,
  Ncy: Ncy,
  ncy: ncy$1,
  ndash: ndash,
  ne: ne$1,
  nearhk: nearhk,
  neArr: neArr,
  nearr: nearr,
  nearrow: nearrow,
  nedot: nedot,
  NegativeMediumSpace: NegativeMediumSpace,
  NegativeThickSpace: NegativeThickSpace,
  NegativeThinSpace: NegativeThinSpace,
  NegativeVeryThinSpace: NegativeVeryThinSpace,
  nequiv: nequiv,
  nesear: nesear,
  nesim: nesim,
  NestedGreaterGreater: NestedGreaterGreater,
  NestedLessLess: NestedLessLess,
  NewLine: NewLine,
  nexist: nexist,
  nexists: nexists,
  Nfr: Nfr,
  nfr: nfr,
  ngE: ngE,
  nge: nge$1,
  ngeq: ngeq,
  ngeqq: ngeqq,
  ngeqslant: ngeqslant,
  nges: nges,
  nGg: nGg,
  ngsim: ngsim,
  nGt: nGt,
  ngt: ngt$1,
  ngtr: ngtr,
  nGtv: nGtv,
  nhArr: nhArr,
  nharr: nharr,
  nhpar: nhpar,
  ni: ni$1,
  nis: nis$1,
  nisd: nisd,
  niv: niv,
  NJcy: NJcy,
  njcy: njcy,
  nlArr: nlArr,
  nlarr: nlarr,
  nldr: nldr,
  nlE: nlE,
  nle: nle$1,
  nLeftarrow: nLeftarrow,
  nleftarrow: nleftarrow,
  nLeftrightarrow: nLeftrightarrow,
  nleftrightarrow: nleftrightarrow,
  nleq: nleq,
  nleqq: nleqq,
  nleqslant: nleqslant,
  nles: nles$1,
  nless: nless$1,
  nLl: nLl,
  nlsim: nlsim,
  nLt: nLt,
  nlt: nlt$1,
  nltri: nltri,
  nltrie: nltrie,
  nLtv: nLtv,
  nmid: nmid,
  NoBreak: NoBreak,
  NonBreakingSpace: NonBreakingSpace,
  Nopf: Nopf,
  nopf: nopf$1,
  Not: Not$1,
  not: not$1,
  NotCongruent: NotCongruent,
  NotCupCap: NotCupCap,
  NotDoubleVerticalBar: NotDoubleVerticalBar,
  NotElement: NotElement,
  NotEqual: NotEqual,
  NotEqualTilde: NotEqualTilde,
  NotExists: NotExists,
  NotGreater: NotGreater,
  NotGreaterEqual: NotGreaterEqual,
  NotGreaterFullEqual: NotGreaterFullEqual,
  NotGreaterGreater: NotGreaterGreater,
  NotGreaterLess: NotGreaterLess,
  NotGreaterSlantEqual: NotGreaterSlantEqual,
  NotGreaterTilde: NotGreaterTilde,
  NotHumpDownHump: NotHumpDownHump,
  NotHumpEqual: NotHumpEqual,
  notin: notin,
  notindot: notindot,
  notinE: notinE,
  notinva: notinva,
  notinvb: notinvb,
  notinvc: notinvc,
  NotLeftTriangle: NotLeftTriangle,
  NotLeftTriangleBar: NotLeftTriangleBar,
  NotLeftTriangleEqual: NotLeftTriangleEqual,
  NotLess: NotLess,
  NotLessEqual: NotLessEqual,
  NotLessGreater: NotLessGreater,
  NotLessLess: NotLessLess,
  NotLessSlantEqual: NotLessSlantEqual,
  NotLessTilde: NotLessTilde,
  NotNestedGreaterGreater: NotNestedGreaterGreater,
  NotNestedLessLess: NotNestedLessLess,
  notni: notni,
  notniva: notniva,
  notnivb: notnivb,
  notnivc: notnivc,
  NotPrecedes: NotPrecedes,
  NotPrecedesEqual: NotPrecedesEqual,
  NotPrecedesSlantEqual: NotPrecedesSlantEqual,
  NotReverseElement: NotReverseElement,
  NotRightTriangle: NotRightTriangle,
  NotRightTriangleBar: NotRightTriangleBar,
  NotRightTriangleEqual: NotRightTriangleEqual,
  NotSquareSubset: NotSquareSubset,
  NotSquareSubsetEqual: NotSquareSubsetEqual,
  NotSquareSuperset: NotSquareSuperset,
  NotSquareSupersetEqual: NotSquareSupersetEqual,
  NotSubset: NotSubset,
  NotSubsetEqual: NotSubsetEqual,
  NotSucceeds: NotSucceeds,
  NotSucceedsEqual: NotSucceedsEqual,
  NotSucceedsSlantEqual: NotSucceedsSlantEqual,
  NotSucceedsTilde: NotSucceedsTilde,
  NotSuperset: NotSuperset,
  NotSupersetEqual: NotSupersetEqual,
  NotTilde: NotTilde,
  NotTildeEqual: NotTildeEqual,
  NotTildeFullEqual: NotTildeFullEqual,
  NotTildeTilde: NotTildeTilde,
  NotVerticalBar: NotVerticalBar,
  npar: npar,
  nparallel: nparallel,
  nparsl: nparsl,
  npart: npart,
  npolint: npolint,
  npr: npr,
  nprcue: nprcue,
  npre: npre,
  nprec: nprec,
  npreceq: npreceq,
  nrArr: nrArr,
  nrarr: nrarr,
  nrarrc: nrarrc,
  nrarrw: nrarrw,
  nRightarrow: nRightarrow,
  nrightarrow: nrightarrow,
  nrtri: nrtri,
  nrtrie: nrtrie,
  nsc: nsc$1,
  nsccue: nsccue,
  nsce: nsce$1,
  Nscr: Nscr,
  nscr: nscr,
  nshortmid: nshortmid,
  nshortparallel: nshortparallel,
  nsim: nsim,
  nsime: nsime,
  nsimeq: nsimeq,
  nsmid: nsmid,
  nspar: nspar,
  nsqsube: nsqsube,
  nsqsupe: nsqsupe,
  nsub: nsub,
  nsubE: nsubE,
  nsube: nsube,
  nsubset: nsubset,
  nsubseteq: nsubseteq,
  nsubseteqq: nsubseteqq,
  nsucc: nsucc,
  nsucceq: nsucceq,
  nsup: nsup,
  nsupE: nsupE,
  nsupe: nsupe,
  nsupset: nsupset,
  nsupseteq: nsupseteq,
  nsupseteqq: nsupseteqq,
  ntgl: ntgl,
  Ntilde: Ntilde,
  ntilde: ntilde,
  ntlg: ntlg,
  ntriangleleft: ntriangleleft,
  ntrianglelefteq: ntrianglelefteq,
  ntriangleright: ntriangleright,
  ntrianglerighteq: ntrianglerighteq,
  Nu: Nu,
  nu: nu$1,
  num: num$1,
  numero: numero,
  numsp: numsp,
  nvap: nvap,
  nVDash: nVDash,
  nVdash: nVdash,
  nvDash: nvDash,
  nvdash: nvdash,
  nvge: nvge,
  nvgt: nvgt,
  nvHarr: nvHarr,
  nvinfin: nvinfin,
  nvlArr: nvlArr,
  nvle: nvle,
  nvlt: nvlt,
  nvltrie: nvltrie,
  nvrArr: nvrArr,
  nvrtrie: nvrtrie,
  nvsim: nvsim,
  nwarhk: nwarhk,
  nwArr: nwArr,
  nwarr: nwarr,
  nwarrow: nwarrow,
  nwnear: nwnear,
  Oacute: Oacute,
  oacute: oacute,
  oast: oast,
  ocir: ocir,
  Ocirc: Ocirc,
  ocirc: ocirc,
  Ocy: Ocy,
  ocy: ocy,
  odash: odash,
  Odblac: Odblac,
  odblac: odblac,
  odiv: odiv,
  odot: odot,
  odsold: odsold,
  OElig: OElig,
  oelig: oelig,
  ofcir: ofcir,
  Ofr: Ofr,
  ofr: ofr,
  ogon: ogon,
  Ograve: Ograve,
  ograve: ograve,
  ogt: ogt$1,
  ohbar: ohbar,
  ohm: ohm$1,
  oint: oint,
  olarr: olarr,
  olcir: olcir,
  olcross: olcross,
  oline: oline$1,
  olt: olt$1,
  Omacr: Omacr,
  omacr: omacr,
  Omega: Omega$1,
  omega: omega$1,
  Omicron: Omicron$1,
  omicron: omicron$1,
  omid: omid,
  ominus: ominus,
  Oopf: Oopf,
  oopf: oopf$1,
  opar: opar$1,
  OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
  OpenCurlyQuote: OpenCurlyQuote,
  operp: operp,
  oplus: oplus,
  Or: Or,
  or: or$1,
  orarr: orarr,
  ord: ord,
  order: order$1,
  orderof: orderof,
  ordf: ordf,
  ordm: ordm,
  origof: origof,
  oror: oror$1,
  orslope: orslope,
  orv: orv$1,
  oS: oS,
  Oscr: Oscr,
  oscr: oscr,
  Oslash: Oslash,
  oslash: oslash,
  osol: osol$1,
  Otilde: Otilde,
  otilde: otilde,
  Otimes: Otimes,
  otimes: otimes,
  otimesas: otimesas,
  Ouml: Ouml,
  ouml: ouml,
  ovbar: ovbar,
  OverBar: OverBar,
  OverBrace: OverBrace,
  OverBracket: OverBracket,
  OverParenthesis: OverParenthesis,
  par: par$1,
  para: para$1,
  parallel: parallel$1,
  parsim: parsim,
  parsl: parsl,
  part: part$1,
  PartialD: PartialD,
  Pcy: Pcy,
  pcy: pcy,
  percnt: percnt,
  period: period,
  permil: permil,
  perp: perp,
  pertenk: pertenk,
  Pfr: Pfr,
  pfr: pfr,
  Phi: Phi,
  phi: phi$1,
  phiv: phiv,
  phmmat: phmmat,
  phone: phone$1,
  Pi: Pi$1,
  pi: pi$1,
  pitchfork: pitchfork$1,
  piv: piv,
  planck: planck,
  planckh: planckh,
  plankv: plankv,
  plus: plus$1,
  plusacir: plusacir,
  plusb: plusb,
  pluscir: pluscir,
  plusdo: plusdo,
  plusdu: plusdu,
  pluse: pluse,
  PlusMinus: PlusMinus,
  plusmn: plusmn,
  plussim: plussim,
  plustwo: plustwo,
  pm: pm$1,
  Poincareplane: Poincareplane,
  pointint: pointint,
  Popf: Popf,
  popf: popf$1,
  pound: pound$1,
  Pr: Pr,
  pr: pr$1,
  prap: prap,
  prcue: prcue,
  prE: prE,
  pre: pre,
  prec: prec,
  precapprox: precapprox,
  preccurlyeq: preccurlyeq,
  Precedes: Precedes,
  PrecedesEqual: PrecedesEqual,
  PrecedesSlantEqual: PrecedesSlantEqual,
  PrecedesTilde: PrecedesTilde,
  preceq: preceq,
  precnapprox: precnapprox,
  precneqq: precneqq,
  precnsim: precnsim,
  precsim: precsim,
  Prime: Prime,
  prime: prime$1,
  primes: primes$1,
  prnap: prnap,
  prnE: prnE,
  prnsim: prnsim,
  prod: prod$1,
  Product: Product$1,
  profalar: profalar,
  profline: profline,
  profsurf: profsurf,
  prop: prop$1,
  Proportion: Proportion$1,
  Proportional: Proportional$1,
  propto: propto,
  prsim: prsim,
  prurel: prurel,
  Pscr: Pscr,
  pscr: pscr,
  Psi: Psi,
  psi: psi$1,
  puncsp: puncsp,
  Qfr: Qfr,
  qfr: qfr,
  qint: qint,
  Qopf: Qopf,
  qopf: qopf,
  qprime: qprime,
  Qscr: Qscr,
  qscr: qscr,
  quaternions: quaternions,
  quatint: quatint,
  quest: quest$1,
  questeq: questeq,
  QUOT: QUOT$1,
  quot: quot$1,
  rAarr: rAarr,
  race: race$1,
  Racute: Racute,
  racute: racute,
  radic: radic,
  raemptyv: raemptyv,
  Rang: Rang,
  rang: rang$1,
  rangd: rangd,
  range: range$1,
  rangle: rangle,
  raquo: raquo,
  Rarr: Rarr,
  rArr: rArr,
  rarr: rarr,
  rarrap: rarrap,
  rarrb: rarrb,
  rarrbfs: rarrbfs,
  rarrc: rarrc,
  rarrfs: rarrfs,
  rarrhk: rarrhk,
  rarrlp: rarrlp,
  rarrpl: rarrpl,
  rarrsim: rarrsim,
  Rarrtl: Rarrtl,
  rarrtl: rarrtl,
  rarrw: rarrw,
  rAtail: rAtail,
  ratail: ratail,
  ratio: ratio$1,
  rationals: rationals,
  RBarr: RBarr,
  rBarr: rBarr,
  rbarr: rbarr,
  rbbrk: rbbrk,
  rbrace: rbrace,
  rbrack: rbrack,
  rbrke: rbrke,
  rbrksld: rbrksld,
  rbrkslu: rbrkslu,
  Rcaron: Rcaron,
  rcaron: rcaron,
  Rcedil: Rcedil,
  rcedil: rcedil,
  rceil: rceil,
  rcub: rcub,
  Rcy: Rcy,
  rcy: rcy,
  rdca: rdca,
  rdldhar: rdldhar,
  rdquo: rdquo,
  rdquor: rdquor,
  rdsh: rdsh,
  Re: Re$1,
  real: real$1,
  realine: realine,
  realpart: realpart,
  reals: reals$1,
  rect: rect$1,
  REG: REG$1,
  reg: reg$1,
  ReverseElement: ReverseElement,
  ReverseEquilibrium: ReverseEquilibrium,
  ReverseUpEquilibrium: ReverseUpEquilibrium,
  rfisht: rfisht,
  rfloor: rfloor,
  Rfr: Rfr,
  rfr: rfr,
  rHar: rHar,
  rhard: rhard,
  rharu: rharu,
  rharul: rharul,
  Rho: Rho,
  rho: rho,
  rhov: rhov,
  RightAngleBracket: RightAngleBracket,
  RightArrow: RightArrow,
  Rightarrow: Rightarrow,
  rightarrow: rightarrow,
  RightArrowBar: RightArrowBar,
  RightArrowLeftArrow: RightArrowLeftArrow,
  rightarrowtail: rightarrowtail,
  RightCeiling: RightCeiling,
  RightDoubleBracket: RightDoubleBracket,
  RightDownTeeVector: RightDownTeeVector,
  RightDownVector: RightDownVector,
  RightDownVectorBar: RightDownVectorBar,
  RightFloor: RightFloor,
  rightharpoondown: rightharpoondown,
  rightharpoonup: rightharpoonup,
  rightleftarrows: rightleftarrows,
  rightleftharpoons: rightleftharpoons,
  rightrightarrows: rightrightarrows,
  rightsquigarrow: rightsquigarrow,
  RightTee: RightTee,
  RightTeeArrow: RightTeeArrow,
  RightTeeVector: RightTeeVector,
  rightthreetimes: rightthreetimes,
  RightTriangle: RightTriangle,
  RightTriangleBar: RightTriangleBar,
  RightTriangleEqual: RightTriangleEqual,
  RightUpDownVector: RightUpDownVector,
  RightUpTeeVector: RightUpTeeVector,
  RightUpVector: RightUpVector,
  RightUpVectorBar: RightUpVectorBar,
  RightVector: RightVector,
  RightVectorBar: RightVectorBar,
  ring: ring$1,
  risingdotseq: risingdotseq,
  rlarr: rlarr,
  rlhar: rlhar,
  rlm: rlm,
  rmoust: rmoust,
  rmoustache: rmoustache,
  rnmid: rnmid,
  roang: roang,
  roarr: roarr,
  robrk: robrk,
  ropar: ropar,
  Ropf: Ropf,
  ropf: ropf,
  roplus: roplus,
  rotimes: rotimes,
  RoundImplies: RoundImplies,
  rpar: rpar,
  rpargt: rpargt,
  rppolint: rppolint,
  rrarr: rrarr,
  Rrightarrow: Rrightarrow,
  rsaquo: rsaquo,
  Rscr: Rscr,
  rscr: rscr,
  Rsh: Rsh,
  rsh: rsh$1,
  rsqb: rsqb,
  rsquo: rsquo,
  rsquor: rsquor,
  rthree: rthree,
  rtimes: rtimes,
  rtri: rtri,
  rtrie: rtrie,
  rtrif: rtrif,
  rtriltri: rtriltri,
  RuleDelayed: RuleDelayed,
  ruluhar: ruluhar,
  rx: rx,
  Sacute: Sacute,
  sacute: sacute,
  sbquo: sbquo,
  Sc: Sc,
  sc: sc$1,
  scap: scap$1,
  Scaron: Scaron,
  scaron: scaron,
  sccue: sccue,
  scE: scE,
  sce: sce$1,
  Scedil: Scedil,
  scedil: scedil,
  Scirc: Scirc,
  scirc: scirc,
  scnap: scnap,
  scnE: scnE,
  scnsim: scnsim,
  scpolint: scpolint,
  scsim: scsim,
  Scy: Scy,
  scy: scy$1,
  sdot: sdot$1,
  sdotb: sdotb,
  sdote: sdote,
  searhk: searhk,
  seArr: seArr,
  searr: searr,
  searrow: searrow,
  sect: sect$1,
  semi: semi$1,
  seswar: seswar,
  setminus: setminus,
  setmn: setmn,
  sext: sext,
  Sfr: Sfr,
  sfr: sfr,
  sfrown: sfrown,
  sharp: sharp$1,
  SHCHcy: SHCHcy,
  shchcy: shchcy,
  SHcy: SHcy,
  shcy: shcy,
  ShortDownArrow: ShortDownArrow,
  ShortLeftArrow: ShortLeftArrow,
  shortmid: shortmid,
  shortparallel: shortparallel,
  ShortRightArrow: ShortRightArrow,
  ShortUpArrow: ShortUpArrow,
  shy: shy$1,
  Sigma: Sigma$1,
  sigma: sigma$1,
  sigmaf: sigmaf,
  sigmav: sigmav,
  sim: sim$1,
  simdot: simdot,
  sime: sime,
  simeq: simeq,
  simg: simg,
  simgE: simgE,
  siml: siml,
  simlE: simlE,
  simne: simne,
  simplus: simplus,
  simrarr: simrarr,
  slarr: slarr,
  SmallCircle: SmallCircle,
  smallsetminus: smallsetminus,
  smashp: smashp,
  smeparsl: smeparsl,
  smid: smid,
  smile: smile,
  smt: smt,
  smte: smte,
  smtes: smtes,
  SOFTcy: SOFTcy,
  softcy: softcy,
  sol: sol$1,
  solb: solb,
  solbar: solbar,
  Sopf: Sopf,
  sopf: sopf,
  spades: spades$1,
  spadesuit: spadesuit,
  spar: spar,
  sqcap: sqcap,
  sqcaps: sqcaps,
  sqcup: sqcup,
  sqcups: sqcups,
  Sqrt: Sqrt,
  sqsub: sqsub,
  sqsube: sqsube,
  sqsubset: sqsubset,
  sqsubseteq: sqsubseteq,
  sqsup: sqsup,
  sqsupe: sqsupe,
  sqsupset: sqsupset,
  sqsupseteq: sqsupseteq,
  squ: squ,
  Square: Square,
  square: square$1,
  SquareIntersection: SquareIntersection,
  SquareSubset: SquareSubset,
  SquareSubsetEqual: SquareSubsetEqual,
  SquareSuperset: SquareSuperset,
  SquareSupersetEqual: SquareSupersetEqual,
  SquareUnion: SquareUnion,
  squarf: squarf,
  squf: squf,
  srarr: srarr,
  Sscr: Sscr,
  sscr: sscr,
  ssetmn: ssetmn,
  ssmile: ssmile,
  sstarf: sstarf,
  Star: Star$1,
  star: star$1,
  starf: starf,
  straightepsilon: straightepsilon,
  straightphi: straightphi,
  strns: strns,
  Sub: Sub$1,
  sub: sub$1,
  subdot: subdot,
  subE: subE,
  sube: sube$1,
  subedot: subedot,
  submult: submult,
  subnE: subnE,
  subne: subne,
  subplus: subplus,
  subrarr: subrarr,
  Subset: Subset,
  subset: subset,
  subseteq: subseteq,
  subseteqq: subseteqq,
  SubsetEqual: SubsetEqual,
  subsetneq: subsetneq,
  subsetneqq: subsetneqq,
  subsim: subsim,
  subsub: subsub,
  subsup: subsup,
  succ: succ,
  succapprox: succapprox,
  succcurlyeq: succcurlyeq,
  Succeeds: Succeeds,
  SucceedsEqual: SucceedsEqual,
  SucceedsSlantEqual: SucceedsSlantEqual,
  SucceedsTilde: SucceedsTilde,
  succeq: succeq,
  succnapprox: succnapprox,
  succneqq: succneqq,
  succnsim: succnsim,
  succsim: succsim,
  SuchThat: SuchThat,
  Sum: Sum$1,
  sum: sum$1,
  sung: sung,
  Sup: Sup,
  sup: sup,
  sup1: sup1,
  sup2: sup2,
  sup3: sup3,
  supdot: supdot,
  supdsub: supdsub,
  supE: supE,
  supe: supe,
  supedot: supedot,
  Superset: Superset,
  SupersetEqual: SupersetEqual,
  suphsol: suphsol,
  suphsub: suphsub,
  suplarr: suplarr,
  supmult: supmult,
  supnE: supnE,
  supne: supne,
  supplus: supplus,
  Supset: Supset,
  supset: supset,
  supseteq: supseteq,
  supseteqq: supseteqq,
  supsetneq: supsetneq,
  supsetneqq: supsetneqq,
  supsim: supsim,
  supsub: supsub,
  supsup: supsup,
  swarhk: swarhk,
  swArr: swArr,
  swarr: swarr,
  swarrow: swarrow,
  swnwar: swnwar,
  szlig: szlig,
  Tab: Tab$1,
  target: target$1,
  Tau: Tau$1,
  tau: tau$1,
  tbrk: tbrk,
  Tcaron: Tcaron,
  tcaron: tcaron,
  Tcedil: Tcedil,
  tcedil: tcedil,
  Tcy: Tcy,
  tcy: tcy,
  tdot: tdot,
  telrec: telrec,
  Tfr: Tfr,
  tfr: tfr,
  there4: there4,
  Therefore: Therefore,
  therefore: therefore$1,
  Theta: Theta$1,
  theta: theta$1,
  thetasym: thetasym,
  thetav: thetav,
  thickapprox: thickapprox,
  thicksim: thicksim,
  ThickSpace: ThickSpace,
  thinsp: thinsp,
  ThinSpace: ThinSpace,
  thkap: thkap,
  thksim: thksim,
  THORN: THORN$1,
  thorn: thorn$1,
  Tilde: Tilde$1,
  tilde: tilde$1,
  TildeEqual: TildeEqual,
  TildeFullEqual: TildeFullEqual,
  TildeTilde: TildeTilde,
  times: times$1,
  timesb: timesb,
  timesbar: timesbar,
  timesd: timesd,
  tint: tint$1,
  toea: toea,
  top: top$1,
  topbot: topbot,
  topcir: topcir,
  Topf: Topf,
  topf: topf,
  topfork: topfork,
  tosa: tosa$1,
  tprime: tprime,
  TRADE: TRADE$1,
  trade: trade$1,
  triangle: triangle$1,
  triangledown: triangledown,
  triangleleft: triangleleft,
  trianglelefteq: trianglelefteq,
  triangleq: triangleq,
  triangleright: triangleright,
  trianglerighteq: trianglerighteq,
  tridot: tridot,
  trie: trie$1,
  triminus: triminus,
  TripleDot: TripleDot,
  triplus: triplus,
  trisb: trisb,
  tritime: tritime,
  trpezium: trpezium,
  Tscr: Tscr,
  tscr: tscr,
  TScy: TScy,
  tscy: tscy,
  TSHcy: TSHcy,
  tshcy: tshcy,
  Tstrok: Tstrok,
  tstrok: tstrok,
  twixt: twixt,
  twoheadleftarrow: twoheadleftarrow,
  twoheadrightarrow: twoheadrightarrow,
  Uacute: Uacute,
  uacute: uacute,
  Uarr: Uarr,
  uArr: uArr,
  uarr: uarr,
  Uarrocir: Uarrocir,
  Ubrcy: Ubrcy,
  ubrcy: ubrcy,
  Ubreve: Ubreve,
  ubreve: ubreve,
  Ucirc: Ucirc,
  ucirc: ucirc,
  Ucy: Ucy,
  ucy: ucy$1,
  udarr: udarr,
  Udblac: Udblac,
  udblac: udblac,
  udhar: udhar,
  ufisht: ufisht,
  Ufr: Ufr,
  ufr: ufr,
  Ugrave: Ugrave,
  ugrave: ugrave,
  uHar: uHar,
  uharl: uharl,
  uharr: uharr,
  uhblk: uhblk,
  ulcorn: ulcorn,
  ulcorner: ulcorner,
  ulcrop: ulcrop,
  ultri: ultri,
  Umacr: Umacr,
  umacr: umacr,
  uml: uml$1,
  UnderBar: UnderBar,
  UnderBrace: UnderBrace,
  UnderBracket: UnderBracket,
  UnderParenthesis: UnderParenthesis,
  Union: Union$1,
  UnionPlus: UnionPlus,
  Uogon: Uogon,
  uogon: uogon,
  Uopf: Uopf,
  uopf: uopf,
  UpArrow: UpArrow,
  Uparrow: Uparrow,
  uparrow: uparrow,
  UpArrowBar: UpArrowBar,
  UpArrowDownArrow: UpArrowDownArrow,
  UpDownArrow: UpDownArrow,
  Updownarrow: Updownarrow,
  updownarrow: updownarrow,
  UpEquilibrium: UpEquilibrium,
  upharpoonleft: upharpoonleft,
  upharpoonright: upharpoonright,
  uplus: uplus$1,
  UpperLeftArrow: UpperLeftArrow,
  UpperRightArrow: UpperRightArrow,
  Upsi: Upsi$1,
  upsi: upsi$1,
  upsih: upsih,
  Upsilon: Upsilon,
  upsilon: upsilon,
  UpTee: UpTee,
  UpTeeArrow: UpTeeArrow,
  upuparrows: upuparrows,
  urcorn: urcorn,
  urcorner: urcorner,
  urcrop: urcrop,
  Uring: Uring,
  uring: uring$1,
  urtri: urtri,
  Uscr: Uscr,
  uscr: uscr,
  utdot: utdot,
  Utilde: Utilde,
  utilde: utilde,
  utri: utri,
  utrif: utrif,
  uuarr: uuarr,
  Uuml: Uuml,
  uuml: uuml,
  uwangle: uwangle,
  vangrt: vangrt,
  varepsilon: varepsilon,
  varkappa: varkappa,
  varnothing: varnothing,
  varphi: varphi,
  varpi: varpi,
  varpropto: varpropto,
  vArr: vArr,
  varr: varr,
  varrho: varrho,
  varsigma: varsigma,
  varsubsetneq: varsubsetneq,
  varsubsetneqq: varsubsetneqq,
  varsupsetneq: varsupsetneq,
  varsupsetneqq: varsupsetneqq,
  vartheta: vartheta,
  vartriangleleft: vartriangleleft,
  vartriangleright: vartriangleright,
  Vbar: Vbar,
  vBar: vBar,
  vBarv: vBarv,
  Vcy: Vcy,
  vcy: vcy,
  VDash: VDash,
  Vdash: Vdash,
  vDash: vDash,
  vdash: vdash,
  Vdashl: Vdashl,
  Vee: Vee,
  vee: vee$1,
  veebar: veebar,
  veeeq: veeeq,
  vellip: vellip,
  Verbar: Verbar,
  verbar: verbar,
  Vert: Vert$1,
  vert: vert$1,
  VerticalBar: VerticalBar,
  VerticalLine: VerticalLine,
  VerticalSeparator: VerticalSeparator,
  VerticalTilde: VerticalTilde,
  VeryThinSpace: VeryThinSpace,
  Vfr: Vfr,
  vfr: vfr,
  vltri: vltri,
  vnsub: vnsub,
  vnsup: vnsup,
  Vopf: Vopf,
  vopf: vopf,
  vprop: vprop,
  vrtri: vrtri,
  Vscr: Vscr,
  vscr: vscr,
  vsubnE: vsubnE,
  vsubne: vsubne,
  vsupnE: vsupnE,
  vsupne: vsupne,
  Vvdash: Vvdash,
  vzigzag: vzigzag,
  Wcirc: Wcirc,
  wcirc: wcirc,
  wedbar: wedbar,
  Wedge: Wedge$1,
  wedge: wedge$1,
  wedgeq: wedgeq,
  weierp: weierp,
  Wfr: Wfr,
  wfr: wfr,
  Wopf: Wopf,
  wopf: wopf,
  wp: wp,
  wr: wr,
  wreath: wreath$1,
  Wscr: Wscr,
  wscr: wscr,
  xcap: xcap,
  xcirc: xcirc,
  xcup: xcup,
  xdtri: xdtri,
  Xfr: Xfr,
  xfr: xfr,
  xhArr: xhArr,
  xharr: xharr,
  Xi: Xi$1,
  xi: xi$1,
  xlArr: xlArr,
  xlarr: xlarr,
  xmap: xmap,
  xnis: xnis,
  xodot: xodot,
  Xopf: Xopf,
  xopf: xopf,
  xoplus: xoplus,
  xotime: xotime,
  xrArr: xrArr,
  xrarr: xrarr,
  Xscr: Xscr,
  xscr: xscr,
  xsqcup: xsqcup,
  xuplus: xuplus,
  xutri: xutri,
  xvee: xvee,
  xwedge: xwedge,
  Yacute: Yacute,
  yacute: yacute,
  YAcy: YAcy,
  yacy: yacy,
  Ycirc: Ycirc$1,
  ycirc: ycirc$1,
  Ycy: Ycy,
  ycy: ycy$1,
  yen: yen$1,
  Yfr: Yfr,
  yfr: yfr,
  YIcy: YIcy,
  yicy: yicy,
  Yopf: Yopf,
  yopf: yopf,
  Yscr: Yscr,
  yscr: yscr,
  YUcy: YUcy,
  yucy: yucy,
  Yuml: Yuml,
  yuml: yuml,
  Zacute: Zacute$1,
  zacute: zacute$1,
  Zcaron: Zcaron,
  zcaron: zcaron,
  Zcy: Zcy,
  zcy: zcy,
  Zdot: Zdot,
  zdot: zdot,
  zeetrf: zeetrf,
  ZeroWidthSpace: ZeroWidthSpace,
  Zeta: Zeta$1,
  zeta: zeta$1,
  Zfr: Zfr,
  zfr: zfr,
  ZHcy: ZHcy,
  zhcy: zhcy,
  zigrarr: zigrarr,
  Zopf: Zopf,
  zopf: zopf,
  Zscr: Zscr,
  zscr: zscr,
  zwj: zwj,
  zwnj: zwnj
};
var ound = "pound";
var pond = "pound";
var poubd = "pound";
var poud = "pound";
var poumd = "pound";
var poun = "pound";
var pund = "pound";
var zvbj = "zwnj";
var zvhj = "zwnj";
var zvjb = "zwnj";
var zvjh = "zwnj";
var zvjm = "zwnj";
var zvjn = "zwnj";
var zvmj = "zwnj";
var zvng = "zwnj";
var zvnh = "zwnj";
var zvnj = "zwnj";
var zvnk = "zwnj";
var zvnm = "zwnj";
var zwbj = "zwnj";
var zwhj = "zwnj";
var zwjb = "zwnj";
var zwjh = "zwnj";
var zwjm = "zwnj";
var zwjn = "zwnj";
var zwmj = "zwnj";
var zwng = "zwnj";
var zwnh = "zwnj";
var zwnk = "zwnj";
var zwnm = "zwnj";
var bsp = "nbsp";
var nsp = "nbsp";
var nbp = "nbsp";
var nbs = "nbsp";
var brokenNamedEntitiesJson = {
  ound: ound,
  pond: pond,
  poubd: poubd,
  poud: poud,
  poumd: poumd,
  poun: poun,
  pund: pund,
  zvbj: zvbj,
  zvhj: zvhj,
  zvjb: zvjb,
  zvjh: zvjh,
  zvjm: zvjm,
  zvjn: zvjn,
  zvmj: zvmj,
  zvng: zvng,
  zvnh: zvnh,
  zvnj: zvnj,
  zvnk: zvnk,
  zvnm: zvnm,
  zwbj: zwbj,
  zwhj: zwhj,
  zwjb: zwjb,
  zwjh: zwjh,
  zwjm: zwjm,
  zwjn: zwjn,
  zwmj: zwmj,
  zwng: zwng,
  zwnh: zwnh,
  zwnk: zwnk,
  zwnm: zwnm,
  bsp: bsp,
  nsp: nsp,
  nbp: nbp,
  nbs: nbs
};
var A = {
  a: ["Aacute"],
  b: ["Abreve"],
  c: ["Acirc", "Acy"],
  E: ["AElig"],
  f: ["Afr"],
  g: ["Agrave"],
  l: ["Alpha"],
  m: ["Amacr"],
  M: ["AMP"],
  n: ["And"],
  o: ["Aogon", "Aopf"],
  p: ["ApplyFunction"],
  r: ["Aring"],
  s: ["Ascr", "Assign"],
  t: ["Atilde"],
  u: ["Auml"]
};
var a$3 = {
  a: ["aacute"],
  b: ["abreve"],
  c: ["ac", "acd", "acE", "acirc", "acute", "acy"],
  e: ["aelig"],
  f: ["af", "afr"],
  g: ["agrave"],
  l: ["alefsym", "aleph", "alpha"],
  m: ["amacr", "amalg", "amp"],
  n: ["and", "andand", "andd", "andslope", "andv", "ang", "ange", "angle", "angmsd", "angmsdaa", "angmsdab", "angmsdac", "angmsdad", "angmsdae", "angmsdaf", "angmsdag", "angmsdah", "angrt", "angrtvb", "angrtvbd", "angsph", "angst", "angzarr"],
  o: ["aogon", "aopf"],
  p: ["ap", "apacir", "apE", "ape", "apid", "apos", "approx", "approxeq"],
  r: ["aring"],
  s: ["ascr", "ast", "asymp", "asympeq"],
  t: ["atilde"],
  u: ["auml"],
  w: ["awconint", "awint"]
};
var b$3 = {
  a: ["backcong", "backepsilon", "backprime", "backsim", "backsimeq", "barvee", "barwed", "barwedge"],
  b: ["bbrk", "bbrktbrk"],
  c: ["bcong", "bcy"],
  d: ["bdquo"],
  e: ["becaus", "because", "bemptyv", "bepsi", "bernou", "beta", "beth", "between"],
  f: ["bfr"],
  i: ["bigcap", "bigcirc", "bigcup", "bigodot", "bigoplus", "bigotimes", "bigsqcup", "bigstar", "bigtriangledown", "bigtriangleup", "biguplus", "bigvee", "bigwedge"],
  k: ["bkarow"],
  l: ["blacklozenge", "blacksquare", "blacktriangle", "blacktriangledown", "blacktriangleleft", "blacktriangleright", "blank", "blk12", "blk14", "blk34", "block"],
  n: ["bne", "bnequiv", "bnot"],
  N: ["bNot"],
  o: ["bopf", "bot", "bottom", "bowtie", "boxbox", "boxDL", "boxDl", "boxdL", "boxdl", "boxDR", "boxDr", "boxdR", "boxdr", "boxH", "boxh", "boxHD", "boxHd", "boxhD", "boxhd", "boxHU", "boxHu", "boxhU", "boxhu", "boxminus", "boxplus", "boxtimes", "boxUL", "boxUl", "boxuL", "boxul", "boxUR", "boxUr", "boxuR", "boxur", "boxV", "boxv", "boxVH", "boxVh", "boxvH", "boxvh", "boxVL", "boxVl", "boxvL", "boxvl", "boxVR", "boxVr", "boxvR", "boxvr"],
  p: ["bprime"],
  r: ["breve", "brvbar"],
  s: ["bscr", "bsemi", "bsim", "bsime", "bsol", "bsolb", "bsolhsub"],
  u: ["bull", "bullet", "bump", "bumpE", "bumpe", "bumpeq"]
};
var B = {
  a: ["Backslash", "Barv", "Barwed"],
  c: ["Bcy"],
  e: ["Because", "Bernoullis", "Beta"],
  f: ["Bfr"],
  o: ["Bopf"],
  r: ["Breve"],
  s: ["Bscr"],
  u: ["Bumpeq"]
};
var C = {
  a: ["Cacute", "Cap", "CapitalDifferentialD", "Cayleys"],
  c: ["Ccaron", "Ccedil", "Ccirc", "Cconint"],
  d: ["Cdot"],
  e: ["Cedilla", "CenterDot"],
  f: ["Cfr"],
  H: ["CHcy"],
  h: ["Chi"],
  i: ["CircleDot", "CircleMinus", "CirclePlus", "CircleTimes"],
  l: ["ClockwiseContourIntegral", "CloseCurlyDoubleQuote", "CloseCurlyQuote"],
  o: ["Colon", "Colone", "Congruent", "Conint", "ContourIntegral", "Copf", "Coproduct", "CounterClockwiseContourIntegral"],
  O: ["COPY"],
  r: ["Cross"],
  s: ["Cscr"],
  u: ["Cup", "CupCap"]
};
var c$3 = {
  a: ["cacute", "cap", "capand", "capbrcup", "capcap", "capcup", "capdot", "caps", "caret", "caron"],
  c: ["ccaps", "ccaron", "ccedil", "ccirc", "ccups", "ccupssm"],
  d: ["cdot"],
  e: ["cedil", "cemptyv", "cent", "centerdot"],
  f: ["cfr"],
  h: ["chcy", "check", "checkmark", "chi"],
  i: ["cir", "circ", "circeq", "circlearrowleft", "circlearrowright", "circledast", "circledcirc", "circleddash", "circledR", "circledS", "cirE", "cire", "cirfnint", "cirmid", "cirscir"],
  l: ["clubs", "clubsuit"],
  o: ["colon", "colone", "coloneq", "comma", "commat", "comp", "compfn", "complement", "complexes", "cong", "congdot", "conint", "copf", "coprod", "copy", "copysr"],
  r: ["crarr", "cross"],
  s: ["cscr", "csub", "csube", "csup", "csupe"],
  t: ["ctdot"],
  u: ["cudarrl", "cudarrr", "cuepr", "cuesc", "cularr", "cularrp", "cup", "cupbrcap", "cupcap", "cupcup", "cupdot", "cupor", "cups", "curarr", "curarrm", "curlyeqprec", "curlyeqsucc", "curlyvee", "curlywedge", "curren", "curvearrowleft", "curvearrowright", "cuvee", "cuwed"],
  w: ["cwconint", "cwint"],
  y: ["cylcty"]
};
var D$1 = {
  a: ["Dagger", "Darr", "Dashv"],
  c: ["Dcaron", "Dcy"],
  D: ["DD", "DDotrahd"],
  e: ["Del", "Delta"],
  f: ["Dfr"],
  i: ["DiacriticalAcute", "DiacriticalDot", "DiacriticalDoubleAcute", "DiacriticalGrave", "DiacriticalTilde", "Diamond", "DifferentialD"],
  J: ["DJcy"],
  o: ["Dopf", "Dot", "DotDot", "DotEqual", "DoubleContourIntegral", "DoubleDot", "DoubleDownArrow", "DoubleLeftArrow", "DoubleLeftRightArrow", "DoubleLeftTee", "DoubleLongLeftArrow", "DoubleLongLeftRightArrow", "DoubleLongRightArrow", "DoubleRightArrow", "DoubleRightTee", "DoubleUpArrow", "DoubleUpDownArrow", "DoubleVerticalBar", "DownArrow", "Downarrow", "DownArrowBar", "DownArrowUpArrow", "DownBreve", "DownLeftRightVector", "DownLeftTeeVector", "DownLeftVector", "DownLeftVectorBar", "DownRightTeeVector", "DownRightVector", "DownRightVectorBar", "DownTee", "DownTeeArrow"],
  s: ["Dscr", "Dstrok"],
  S: ["DScy"],
  Z: ["DZcy"]
};
var d$3 = {
  a: ["dagger", "daleth", "darr", "dash", "dashv"],
  A: ["dArr"],
  b: ["dbkarow", "dblac"],
  c: ["dcaron", "dcy"],
  d: ["dd", "ddagger", "ddarr", "ddotseq"],
  e: ["deg", "delta", "demptyv"],
  f: ["dfisht", "dfr"],
  H: ["dHar"],
  h: ["dharl", "dharr"],
  i: ["diam", "diamond", "diamondsuit", "diams", "die", "digamma", "disin", "div", "divide", "divideontimes", "divonx"],
  j: ["djcy"],
  l: ["dlcorn", "dlcrop"],
  o: ["dollar", "dopf", "dot", "doteq", "doteqdot", "dotminus", "dotplus", "dotsquare", "doublebarwedge", "downarrow", "downdownarrows", "downharpoonleft", "downharpoonright"],
  r: ["drbkarow", "drcorn", "drcrop"],
  s: ["dscr", "dscy", "dsol", "dstrok"],
  t: ["dtdot", "dtri", "dtrif"],
  u: ["duarr", "duhar"],
  w: ["dwangle"],
  z: ["dzcy", "dzigrarr"]
};
var E$1 = {
  a: ["Eacute"],
  c: ["Ecaron", "Ecirc", "Ecy"],
  d: ["Edot"],
  f: ["Efr"],
  g: ["Egrave"],
  l: ["Element"],
  m: ["Emacr", "EmptySmallSquare", "EmptyVerySmallSquare"],
  N: ["ENG"],
  o: ["Eogon", "Eopf"],
  p: ["Epsilon"],
  q: ["Equal", "EqualTilde", "Equilibrium"],
  s: ["Escr", "Esim"],
  t: ["Eta"],
  T: ["ETH"],
  u: ["Euml"],
  x: ["Exists", "ExponentialE"]
};
var e$3 = {
  a: ["eacute", "easter"],
  c: ["ecaron", "ecir", "ecirc", "ecolon", "ecy"],
  D: ["eDDot", "eDot"],
  d: ["edot"],
  e: ["ee"],
  f: ["efDot", "efr"],
  g: ["eg", "egrave", "egs", "egsdot"],
  l: ["el", "elinters", "ell", "els", "elsdot"],
  m: ["emacr", "empty", "emptyset", "emptyv", "emsp", "emsp13", "emsp14"],
  n: ["eng", "ensp"],
  o: ["eogon", "eopf"],
  p: ["epar", "eparsl", "eplus", "epsi", "epsilon", "epsiv"],
  q: ["eqcirc", "eqcolon", "eqsim", "eqslantgtr", "eqslantless", "equals", "equest", "equiv", "equivDD", "eqvparsl"],
  r: ["erarr", "erDot"],
  s: ["escr", "esdot", "esim"],
  t: ["eta", "eth"],
  u: ["euml", "euro"],
  x: ["excl", "exist", "expectation", "exponentiale"]
};
var f$3 = {
  a: ["fallingdotseq"],
  c: ["fcy"],
  e: ["female"],
  f: ["ffilig", "fflig", "ffllig", "ffr"],
  i: ["filig"],
  j: ["fjlig"],
  l: ["flat", "fllig", "fltns"],
  n: ["fnof"],
  o: ["fopf", "forall", "fork", "forkv"],
  p: ["fpartint"],
  r: ["frac12", "frac13", "frac14", "frac15", "frac16", "frac18", "frac23", "frac25", "frac34", "frac35", "frac38", "frac45", "frac56", "frac58", "frac78", "frasl", "frown"],
  s: ["fscr"]
};
var F = {
  c: ["Fcy"],
  f: ["Ffr"],
  i: ["FilledSmallSquare", "FilledVerySmallSquare"],
  o: ["Fopf", "ForAll", "Fouriertrf"],
  s: ["Fscr"]
};
var g$3 = {
  a: ["gacute", "gamma", "gammad", "gap"],
  b: ["gbreve"],
  c: ["gcirc", "gcy"],
  d: ["gdot"],
  E: ["gE", "gEl"],
  e: ["ge", "gel", "geq", "geqq", "geqslant", "ges", "gescc", "gesdot", "gesdoto", "gesdotol", "gesl", "gesles"],
  f: ["gfr"],
  g: ["gg", "ggg"],
  i: ["gimel"],
  j: ["gjcy"],
  l: ["gl", "gla", "glE", "glj"],
  n: ["gnap", "gnapprox", "gnE", "gne", "gneq", "gneqq", "gnsim"],
  o: ["gopf"],
  r: ["grave"],
  s: ["gscr", "gsim", "gsime", "gsiml"],
  t: ["gt", "gtcc", "gtcir", "gtdot", "gtlPar", "gtquest", "gtrapprox", "gtrarr", "gtrdot", "gtreqless", "gtreqqless", "gtrless", "gtrsim"],
  v: ["gvertneqq", "gvnE"]
};
var G$1 = {
  a: ["Gamma", "Gammad"],
  b: ["Gbreve"],
  c: ["Gcedil", "Gcirc", "Gcy"],
  d: ["Gdot"],
  f: ["Gfr"],
  g: ["Gg"],
  J: ["GJcy"],
  o: ["Gopf"],
  r: ["GreaterEqual", "GreaterEqualLess", "GreaterFullEqual", "GreaterGreater", "GreaterLess", "GreaterSlantEqual", "GreaterTilde"],
  s: ["Gscr"],
  T: ["GT"],
  t: ["Gt"]
};
var H$1 = {
  a: ["Hacek", "Hat"],
  A: ["HARDcy"],
  c: ["Hcirc"],
  f: ["Hfr"],
  i: ["HilbertSpace"],
  o: ["Hopf", "HorizontalLine"],
  s: ["Hscr", "Hstrok"],
  u: ["HumpDownHump", "HumpEqual"]
};
var h$3 = {
  a: ["hairsp", "half", "hamilt", "hardcy", "harr", "harrcir", "harrw"],
  A: ["hArr"],
  b: ["hbar"],
  c: ["hcirc"],
  e: ["hearts", "heartsuit", "hellip", "hercon"],
  f: ["hfr"],
  k: ["hksearow", "hkswarow"],
  o: ["hoarr", "homtht", "hookleftarrow", "hookrightarrow", "hopf", "horbar"],
  s: ["hscr", "hslash", "hstrok"],
  y: ["hybull", "hyphen"]
};
var I$1 = {
  a: ["Iacute"],
  c: ["Icirc", "Icy"],
  d: ["Idot"],
  E: ["IEcy"],
  f: ["Ifr"],
  g: ["Igrave"],
  J: ["IJlig"],
  m: ["Im", "Imacr", "ImaginaryI", "Implies"],
  n: ["Int", "Integral", "Intersection", "InvisibleComma", "InvisibleTimes"],
  O: ["IOcy"],
  o: ["Iogon", "Iopf", "Iota"],
  s: ["Iscr"],
  t: ["Itilde"],
  u: ["Iukcy", "Iuml"]
};
var i$3 = {
  a: ["iacute"],
  c: ["ic", "icirc", "icy"],
  e: ["iecy", "iexcl"],
  f: ["iff", "ifr"],
  g: ["igrave"],
  i: ["ii", "iiiint", "iiint", "iinfin", "iiota"],
  j: ["ijlig"],
  m: ["imacr", "image", "imagline", "imagpart", "imath", "imof", "imped"],
  n: ["in", "incare", "infin", "infintie", "inodot", "int", "intcal", "integers", "intercal", "intlarhk", "intprod"],
  o: ["iocy", "iogon", "iopf", "iota"],
  p: ["iprod"],
  q: ["iquest"],
  s: ["iscr", "isin", "isindot", "isinE", "isins", "isinsv", "isinv"],
  t: ["it", "itilde"],
  u: ["iukcy", "iuml"]
};
var J = {
  c: ["Jcirc", "Jcy"],
  f: ["Jfr"],
  o: ["Jopf"],
  s: ["Jscr", "Jsercy"],
  u: ["Jukcy"]
};
var j$3 = {
  c: ["jcirc", "jcy"],
  f: ["jfr"],
  m: ["jmath"],
  o: ["jopf"],
  s: ["jscr", "jsercy"],
  u: ["jukcy"]
};
var K = {
  a: ["Kappa"],
  c: ["Kcedil", "Kcy"],
  f: ["Kfr"],
  H: ["KHcy"],
  J: ["KJcy"],
  o: ["Kopf"],
  s: ["Kscr"]
};
var k$3 = {
  a: ["kappa", "kappav"],
  c: ["kcedil", "kcy"],
  f: ["kfr"],
  g: ["kgreen"],
  h: ["khcy"],
  j: ["kjcy"],
  o: ["kopf"],
  s: ["kscr"]
};
var l$3 = {
  A: ["lAarr", "lArr", "lAtail"],
  a: ["lacute", "laemptyv", "lagran", "lambda", "lang", "langd", "langle", "lap", "laquo", "larr", "larrb", "larrbfs", "larrfs", "larrhk", "larrlp", "larrpl", "larrsim", "larrtl", "lat", "latail", "late", "lates"],
  B: ["lBarr"],
  b: ["lbarr", "lbbrk", "lbrace", "lbrack", "lbrke", "lbrksld", "lbrkslu"],
  c: ["lcaron", "lcedil", "lceil", "lcub", "lcy"],
  d: ["ldca", "ldquo", "ldquor", "ldrdhar", "ldrushar", "ldsh"],
  E: ["lE", "lEg"],
  e: ["le", "leftarrow", "leftarrowtail", "leftharpoondown", "leftharpoonup", "leftleftarrows", "leftrightarrow", "leftrightarrows", "leftrightharpoons", "leftrightsquigarrow", "leftthreetimes", "leg", "leq", "leqq", "leqslant", "les", "lescc", "lesdot", "lesdoto", "lesdotor", "lesg", "lesges", "lessapprox", "lessdot", "lesseqgtr", "lesseqqgtr", "lessgtr", "lesssim"],
  f: ["lfisht", "lfloor", "lfr"],
  g: ["lg", "lgE"],
  H: ["lHar"],
  h: ["lhard", "lharu", "lharul", "lhblk"],
  j: ["ljcy"],
  l: ["ll", "llarr", "llcorner", "llhard", "lltri"],
  m: ["lmidot", "lmoust", "lmoustache"],
  n: ["lnap", "lnapprox", "lnE", "lne", "lneq", "lneqq", "lnsim"],
  o: ["loang", "loarr", "lobrk", "longleftarrow", "longleftrightarrow", "longmapsto", "longrightarrow", "looparrowleft", "looparrowright", "lopar", "lopf", "loplus", "lotimes", "lowast", "lowbar", "loz", "lozenge", "lozf"],
  p: ["lpar", "lparlt"],
  r: ["lrarr", "lrcorner", "lrhar", "lrhard", "lrm", "lrtri"],
  s: ["lsaquo", "lscr", "lsh", "lsim", "lsime", "lsimg", "lsqb", "lsquo", "lsquor", "lstrok"],
  t: ["lt", "ltcc", "ltcir", "ltdot", "lthree", "ltimes", "ltlarr", "ltquest", "ltri", "ltrie", "ltrif", "ltrPar"],
  u: ["lurdshar", "luruhar"],
  v: ["lvertneqq", "lvnE"]
};
var L$1 = {
  a: ["Lacute", "Lambda", "Lang", "Laplacetrf", "Larr"],
  c: ["Lcaron", "Lcedil", "Lcy"],
  e: ["LeftAngleBracket", "LeftArrow", "Leftarrow", "LeftArrowBar", "LeftArrowRightArrow", "LeftCeiling", "LeftDoubleBracket", "LeftDownTeeVector", "LeftDownVector", "LeftDownVectorBar", "LeftFloor", "LeftRightArrow", "Leftrightarrow", "LeftRightVector", "LeftTee", "LeftTeeArrow", "LeftTeeVector", "LeftTriangle", "LeftTriangleBar", "LeftTriangleEqual", "LeftUpDownVector", "LeftUpTeeVector", "LeftUpVector", "LeftUpVectorBar", "LeftVector", "LeftVectorBar", "LessEqualGreater", "LessFullEqual", "LessGreater", "LessLess", "LessSlantEqual", "LessTilde"],
  f: ["Lfr"],
  J: ["LJcy"],
  l: ["Ll", "Lleftarrow"],
  m: ["Lmidot"],
  o: ["LongLeftArrow", "Longleftarrow", "LongLeftRightArrow", "Longleftrightarrow", "LongRightArrow", "Longrightarrow", "Lopf", "LowerLeftArrow", "LowerRightArrow"],
  s: ["Lscr", "Lsh", "Lstrok"],
  T: ["LT"],
  t: ["Lt"]
};
var m$3 = {
  a: ["macr", "male", "malt", "maltese", "map", "mapsto", "mapstodown", "mapstoleft", "mapstoup", "marker"],
  c: ["mcomma", "mcy"],
  d: ["mdash"],
  D: ["mDDot"],
  e: ["measuredangle"],
  f: ["mfr"],
  h: ["mho"],
  i: ["micro", "mid", "midast", "midcir", "middot", "minus", "minusb", "minusd", "minusdu"],
  l: ["mlcp", "mldr"],
  n: ["mnplus"],
  o: ["models", "mopf"],
  p: ["mp"],
  s: ["mscr", "mstpos"],
  u: ["mu", "multimap", "mumap"]
};
var M = {
  a: ["Map"],
  c: ["Mcy"],
  e: ["MediumSpace", "Mellintrf"],
  f: ["Mfr"],
  i: ["MinusPlus"],
  o: ["Mopf"],
  s: ["Mscr"],
  u: ["Mu"]
};
var n$3 = {
  a: ["nabla", "nacute", "nang", "nap", "napE", "napid", "napos", "napprox", "natur", "natural", "naturals"],
  b: ["nbsp", "nbump", "nbumpe"],
  c: ["ncap", "ncaron", "ncedil", "ncong", "ncongdot", "ncup", "ncy"],
  d: ["ndash"],
  e: ["ne", "nearhk", "neArr", "nearr", "nearrow", "nedot", "nequiv", "nesear", "nesim", "nexist", "nexists"],
  f: ["nfr"],
  g: ["ngE", "nge", "ngeq", "ngeqq", "ngeqslant", "nges", "ngsim", "ngt", "ngtr"],
  G: ["nGg", "nGt", "nGtv"],
  h: ["nhArr", "nharr", "nhpar"],
  i: ["ni", "nis", "nisd", "niv"],
  j: ["njcy"],
  l: ["nlArr", "nlarr", "nldr", "nlE", "nle", "nleftarrow", "nleftrightarrow", "nleq", "nleqq", "nleqslant", "nles", "nless", "nlsim", "nlt", "nltri", "nltrie"],
  L: ["nLeftarrow", "nLeftrightarrow", "nLl", "nLt", "nLtv"],
  m: ["nmid"],
  o: ["nopf", "not", "notin", "notindot", "notinE", "notinva", "notinvb", "notinvc", "notni", "notniva", "notnivb", "notnivc"],
  p: ["npar", "nparallel", "nparsl", "npart", "npolint", "npr", "nprcue", "npre", "nprec", "npreceq"],
  r: ["nrArr", "nrarr", "nrarrc", "nrarrw", "nrightarrow", "nrtri", "nrtrie"],
  R: ["nRightarrow"],
  s: ["nsc", "nsccue", "nsce", "nscr", "nshortmid", "nshortparallel", "nsim", "nsime", "nsimeq", "nsmid", "nspar", "nsqsube", "nsqsupe", "nsub", "nsubE", "nsube", "nsubset", "nsubseteq", "nsubseteqq", "nsucc", "nsucceq", "nsup", "nsupE", "nsupe", "nsupset", "nsupseteq", "nsupseteqq"],
  t: ["ntgl", "ntilde", "ntlg", "ntriangleleft", "ntrianglelefteq", "ntriangleright", "ntrianglerighteq"],
  u: ["nu", "num", "numero", "numsp"],
  v: ["nvap", "nvDash", "nvdash", "nvge", "nvgt", "nvHarr", "nvinfin", "nvlArr", "nvle", "nvlt", "nvltrie", "nvrArr", "nvrtrie", "nvsim"],
  V: ["nVDash", "nVdash"],
  w: ["nwarhk", "nwArr", "nwarr", "nwarrow", "nwnear"]
};
var N$1 = {
  a: ["Nacute"],
  c: ["Ncaron", "Ncedil", "Ncy"],
  e: ["NegativeMediumSpace", "NegativeThickSpace", "NegativeThinSpace", "NegativeVeryThinSpace", "NestedGreaterGreater", "NestedLessLess", "NewLine"],
  f: ["Nfr"],
  J: ["NJcy"],
  o: ["NoBreak", "NonBreakingSpace", "Nopf", "Not", "NotCongruent", "NotCupCap", "NotDoubleVerticalBar", "NotElement", "NotEqual", "NotEqualTilde", "NotExists", "NotGreater", "NotGreaterEqual", "NotGreaterFullEqual", "NotGreaterGreater", "NotGreaterLess", "NotGreaterSlantEqual", "NotGreaterTilde", "NotHumpDownHump", "NotHumpEqual", "NotLeftTriangle", "NotLeftTriangleBar", "NotLeftTriangleEqual", "NotLess", "NotLessEqual", "NotLessGreater", "NotLessLess", "NotLessSlantEqual", "NotLessTilde", "NotNestedGreaterGreater", "NotNestedLessLess", "NotPrecedes", "NotPrecedesEqual", "NotPrecedesSlantEqual", "NotReverseElement", "NotRightTriangle", "NotRightTriangleBar", "NotRightTriangleEqual", "NotSquareSubset", "NotSquareSubsetEqual", "NotSquareSuperset", "NotSquareSupersetEqual", "NotSubset", "NotSubsetEqual", "NotSucceeds", "NotSucceedsEqual", "NotSucceedsSlantEqual", "NotSucceedsTilde", "NotSuperset", "NotSupersetEqual", "NotTilde", "NotTildeEqual", "NotTildeFullEqual", "NotTildeTilde", "NotVerticalBar"],
  s: ["Nscr"],
  t: ["Ntilde"],
  u: ["Nu"]
};
var O = {
  a: ["Oacute"],
  c: ["Ocirc", "Ocy"],
  d: ["Odblac"],
  E: ["OElig"],
  f: ["Ofr"],
  g: ["Ograve"],
  m: ["Omacr", "Omega", "Omicron"],
  o: ["Oopf"],
  p: ["OpenCurlyDoubleQuote", "OpenCurlyQuote"],
  r: ["Or"],
  s: ["Oscr", "Oslash"],
  t: ["Otilde", "Otimes"],
  u: ["Ouml"],
  v: ["OverBar", "OverBrace", "OverBracket", "OverParenthesis"]
};
var o$3 = {
  a: ["oacute", "oast"],
  c: ["ocir", "ocirc", "ocy"],
  d: ["odash", "odblac", "odiv", "odot", "odsold"],
  e: ["oelig"],
  f: ["ofcir", "ofr"],
  g: ["ogon", "ograve", "ogt"],
  h: ["ohbar", "ohm"],
  i: ["oint"],
  l: ["olarr", "olcir", "olcross", "oline", "olt"],
  m: ["omacr", "omega", "omicron", "omid", "ominus"],
  o: ["oopf"],
  p: ["opar", "operp", "oplus"],
  r: ["or", "orarr", "ord", "order", "orderof", "ordf", "ordm", "origof", "oror", "orslope", "orv"],
  S: ["oS"],
  s: ["oscr", "oslash", "osol"],
  t: ["otilde", "otimes", "otimesas"],
  u: ["ouml"],
  v: ["ovbar"]
};
var p$3 = {
  a: ["par", "para", "parallel", "parsim", "parsl", "part"],
  c: ["pcy"],
  e: ["percnt", "period", "permil", "perp", "pertenk"],
  f: ["pfr"],
  h: ["phi", "phiv", "phmmat", "phone"],
  i: ["pi", "pitchfork", "piv"],
  l: ["planck", "planckh", "plankv", "plus", "plusacir", "plusb", "pluscir", "plusdo", "plusdu", "pluse", "plusmn", "plussim", "plustwo"],
  m: ["pm"],
  o: ["pointint", "popf", "pound"],
  r: ["pr", "prap", "prcue", "prE", "pre", "prec", "precapprox", "preccurlyeq", "preceq", "precnapprox", "precneqq", "precnsim", "precsim", "prime", "primes", "prnap", "prnE", "prnsim", "prod", "profalar", "profline", "profsurf", "prop", "propto", "prsim", "prurel"],
  s: ["pscr", "psi"],
  u: ["puncsp"]
};
var P$1 = {
  a: ["PartialD"],
  c: ["Pcy"],
  f: ["Pfr"],
  h: ["Phi"],
  i: ["Pi"],
  l: ["PlusMinus"],
  o: ["Poincareplane", "Popf"],
  r: ["Pr", "Precedes", "PrecedesEqual", "PrecedesSlantEqual", "PrecedesTilde", "Prime", "Product", "Proportion", "Proportional"],
  s: ["Pscr", "Psi"]
};
var Q = {
  f: ["Qfr"],
  o: ["Qopf"],
  s: ["Qscr"],
  U: ["QUOT"]
};
var q$3 = {
  f: ["qfr"],
  i: ["qint"],
  o: ["qopf"],
  p: ["qprime"],
  s: ["qscr"],
  u: ["quaternions", "quatint", "quest", "questeq", "quot"]
};
var r$3 = {
  A: ["rAarr", "rArr", "rAtail"],
  a: ["race", "racute", "radic", "raemptyv", "rang", "rangd", "range", "rangle", "raquo", "rarr", "rarrap", "rarrb", "rarrbfs", "rarrc", "rarrfs", "rarrhk", "rarrlp", "rarrpl", "rarrsim", "rarrtl", "rarrw", "ratail", "ratio", "rationals"],
  B: ["rBarr"],
  b: ["rbarr", "rbbrk", "rbrace", "rbrack", "rbrke", "rbrksld", "rbrkslu"],
  c: ["rcaron", "rcedil", "rceil", "rcub", "rcy"],
  d: ["rdca", "rdldhar", "rdquo", "rdquor", "rdsh"],
  e: ["real", "realine", "realpart", "reals", "rect", "reg"],
  f: ["rfisht", "rfloor", "rfr"],
  H: ["rHar"],
  h: ["rhard", "rharu", "rharul", "rho", "rhov"],
  i: ["rightarrow", "rightarrowtail", "rightharpoondown", "rightharpoonup", "rightleftarrows", "rightleftharpoons", "rightrightarrows", "rightsquigarrow", "rightthreetimes", "ring", "risingdotseq"],
  l: ["rlarr", "rlhar", "rlm"],
  m: ["rmoust", "rmoustache"],
  n: ["rnmid"],
  o: ["roang", "roarr", "robrk", "ropar", "ropf", "roplus", "rotimes"],
  p: ["rpar", "rpargt", "rppolint"],
  r: ["rrarr"],
  s: ["rsaquo", "rscr", "rsh", "rsqb", "rsquo", "rsquor"],
  t: ["rthree", "rtimes", "rtri", "rtrie", "rtrif", "rtriltri"],
  u: ["ruluhar"],
  x: ["rx"]
};
var R$1 = {
  a: ["Racute", "Rang", "Rarr", "Rarrtl"],
  B: ["RBarr"],
  c: ["Rcaron", "Rcedil", "Rcy"],
  e: ["Re", "ReverseElement", "ReverseEquilibrium", "ReverseUpEquilibrium"],
  E: ["REG"],
  f: ["Rfr"],
  h: ["Rho"],
  i: ["RightAngleBracket", "RightArrow", "Rightarrow", "RightArrowBar", "RightArrowLeftArrow", "RightCeiling", "RightDoubleBracket", "RightDownTeeVector", "RightDownVector", "RightDownVectorBar", "RightFloor", "RightTee", "RightTeeArrow", "RightTeeVector", "RightTriangle", "RightTriangleBar", "RightTriangleEqual", "RightUpDownVector", "RightUpTeeVector", "RightUpVector", "RightUpVectorBar", "RightVector", "RightVectorBar"],
  o: ["Ropf", "RoundImplies"],
  r: ["Rrightarrow"],
  s: ["Rscr", "Rsh"],
  u: ["RuleDelayed"]
};
var S$1 = {
  a: ["Sacute"],
  c: ["Sc", "Scaron", "Scedil", "Scirc", "Scy"],
  f: ["Sfr"],
  H: ["SHCHcy", "SHcy"],
  h: ["ShortDownArrow", "ShortLeftArrow", "ShortRightArrow", "ShortUpArrow"],
  i: ["Sigma"],
  m: ["SmallCircle"],
  O: ["SOFTcy"],
  o: ["Sopf"],
  q: ["Sqrt", "Square", "SquareIntersection", "SquareSubset", "SquareSubsetEqual", "SquareSuperset", "SquareSupersetEqual", "SquareUnion"],
  s: ["Sscr"],
  t: ["Star"],
  u: ["Sub", "Subset", "SubsetEqual", "Succeeds", "SucceedsEqual", "SucceedsSlantEqual", "SucceedsTilde", "SuchThat", "Sum", "Sup", "Superset", "SupersetEqual", "Supset"]
};
var s$3 = {
  a: ["sacute"],
  b: ["sbquo"],
  c: ["sc", "scap", "scaron", "sccue", "scE", "sce", "scedil", "scirc", "scnap", "scnE", "scnsim", "scpolint", "scsim", "scy"],
  d: ["sdot", "sdotb", "sdote"],
  e: ["searhk", "seArr", "searr", "searrow", "sect", "semi", "seswar", "setminus", "setmn", "sext"],
  f: ["sfr", "sfrown"],
  h: ["sharp", "shchcy", "shcy", "shortmid", "shortparallel", "shy"],
  i: ["sigma", "sigmaf", "sigmav", "sim", "simdot", "sime", "simeq", "simg", "simgE", "siml", "simlE", "simne", "simplus", "simrarr"],
  l: ["slarr"],
  m: ["smallsetminus", "smashp", "smeparsl", "smid", "smile", "smt", "smte", "smtes"],
  o: ["softcy", "sol", "solb", "solbar", "sopf"],
  p: ["spades", "spadesuit", "spar"],
  q: ["sqcap", "sqcaps", "sqcup", "sqcups", "sqsub", "sqsube", "sqsubset", "sqsubseteq", "sqsup", "sqsupe", "sqsupset", "sqsupseteq", "squ", "square", "squarf", "squf"],
  r: ["srarr"],
  s: ["sscr", "ssetmn", "ssmile", "sstarf"],
  t: ["star", "starf", "straightepsilon", "straightphi", "strns"],
  u: ["sub", "subdot", "subE", "sube", "subedot", "submult", "subnE", "subne", "subplus", "subrarr", "subset", "subseteq", "subseteqq", "subsetneq", "subsetneqq", "subsim", "subsub", "subsup", "succ", "succapprox", "succcurlyeq", "succeq", "succnapprox", "succneqq", "succnsim", "succsim", "sum", "sung", "sup", "sup1", "sup2", "sup3", "supdot", "supdsub", "supE", "supe", "supedot", "suphsol", "suphsub", "suplarr", "supmult", "supnE", "supne", "supplus", "supset", "supseteq", "supseteqq", "supsetneq", "supsetneqq", "supsim", "supsub", "supsup"],
  w: ["swarhk", "swArr", "swarr", "swarrow", "swnwar"],
  z: ["szlig"]
};
var T$1 = {
  a: ["Tab", "Tau"],
  c: ["Tcaron", "Tcedil", "Tcy"],
  f: ["Tfr"],
  h: ["Therefore", "Theta", "ThickSpace", "ThinSpace"],
  H: ["THORN"],
  i: ["Tilde", "TildeEqual", "TildeFullEqual", "TildeTilde"],
  o: ["Topf"],
  R: ["TRADE"],
  r: ["TripleDot"],
  s: ["Tscr", "Tstrok"],
  S: ["TScy", "TSHcy"]
};
var t$3 = {
  a: ["target", "tau"],
  b: ["tbrk"],
  c: ["tcaron", "tcedil", "tcy"],
  d: ["tdot"],
  e: ["telrec"],
  f: ["tfr"],
  h: ["there4", "therefore", "theta", "thetasym", "thetav", "thickapprox", "thicksim", "thinsp", "thkap", "thksim", "thorn"],
  i: ["tilde", "times", "timesb", "timesbar", "timesd", "tint"],
  o: ["toea", "top", "topbot", "topcir", "topf", "topfork", "tosa"],
  p: ["tprime"],
  r: ["trade", "triangle", "triangledown", "triangleleft", "trianglelefteq", "triangleq", "triangleright", "trianglerighteq", "tridot", "trie", "triminus", "triplus", "trisb", "tritime", "trpezium"],
  s: ["tscr", "tscy", "tshcy", "tstrok"],
  w: ["twixt", "twoheadleftarrow", "twoheadrightarrow"]
};
var U$1 = {
  a: ["Uacute", "Uarr", "Uarrocir"],
  b: ["Ubrcy", "Ubreve"],
  c: ["Ucirc", "Ucy"],
  d: ["Udblac"],
  f: ["Ufr"],
  g: ["Ugrave"],
  m: ["Umacr"],
  n: ["UnderBar", "UnderBrace", "UnderBracket", "UnderParenthesis", "Union", "UnionPlus"],
  o: ["Uogon", "Uopf"],
  p: ["UpArrow", "Uparrow", "UpArrowBar", "UpArrowDownArrow", "UpDownArrow", "Updownarrow", "UpEquilibrium", "UpperLeftArrow", "UpperRightArrow", "Upsi", "Upsilon", "UpTee", "UpTeeArrow"],
  r: ["Uring"],
  s: ["Uscr"],
  t: ["Utilde"],
  u: ["Uuml"]
};
var u$3 = {
  a: ["uacute", "uarr"],
  A: ["uArr"],
  b: ["ubrcy", "ubreve"],
  c: ["ucirc", "ucy"],
  d: ["udarr", "udblac", "udhar"],
  f: ["ufisht", "ufr"],
  g: ["ugrave"],
  H: ["uHar"],
  h: ["uharl", "uharr", "uhblk"],
  l: ["ulcorn", "ulcorner", "ulcrop", "ultri"],
  m: ["umacr", "uml"],
  o: ["uogon", "uopf"],
  p: ["uparrow", "updownarrow", "upharpoonleft", "upharpoonright", "uplus", "upsi", "upsih", "upsilon", "upuparrows"],
  r: ["urcorn", "urcorner", "urcrop", "uring", "urtri"],
  s: ["uscr"],
  t: ["utdot", "utilde", "utri", "utrif"],
  u: ["uuarr", "uuml"],
  w: ["uwangle"]
};
var v$3 = {
  a: ["vangrt", "varepsilon", "varkappa", "varnothing", "varphi", "varpi", "varpropto", "varr", "varrho", "varsigma", "varsubsetneq", "varsubsetneqq", "varsupsetneq", "varsupsetneqq", "vartheta", "vartriangleleft", "vartriangleright"],
  A: ["vArr"],
  B: ["vBar", "vBarv"],
  c: ["vcy"],
  D: ["vDash"],
  d: ["vdash"],
  e: ["vee", "veebar", "veeeq", "vellip", "verbar", "vert"],
  f: ["vfr"],
  l: ["vltri"],
  n: ["vnsub", "vnsup"],
  o: ["vopf"],
  p: ["vprop"],
  r: ["vrtri"],
  s: ["vscr", "vsubnE", "vsubne", "vsupnE", "vsupne"],
  z: ["vzigzag"]
};
var V$1 = {
  b: ["Vbar"],
  c: ["Vcy"],
  D: ["VDash"],
  d: ["Vdash", "Vdashl"],
  e: ["Vee", "Verbar", "Vert", "VerticalBar", "VerticalLine", "VerticalSeparator", "VerticalTilde", "VeryThinSpace"],
  f: ["Vfr"],
  o: ["Vopf"],
  s: ["Vscr"],
  v: ["Vvdash"]
};
var W = {
  c: ["Wcirc"],
  e: ["Wedge"],
  f: ["Wfr"],
  o: ["Wopf"],
  s: ["Wscr"]
};
var w$3 = {
  c: ["wcirc"],
  e: ["wedbar", "wedge", "wedgeq", "weierp"],
  f: ["wfr"],
  o: ["wopf"],
  p: ["wp"],
  r: ["wr", "wreath"],
  s: ["wscr"]
};
var x$3 = {
  c: ["xcap", "xcirc", "xcup"],
  d: ["xdtri"],
  f: ["xfr"],
  h: ["xhArr", "xharr"],
  i: ["xi"],
  l: ["xlArr", "xlarr"],
  m: ["xmap"],
  n: ["xnis"],
  o: ["xodot", "xopf", "xoplus", "xotime"],
  r: ["xrArr", "xrarr"],
  s: ["xscr", "xsqcup"],
  u: ["xuplus", "xutri"],
  v: ["xvee"],
  w: ["xwedge"]
};
var X = {
  f: ["Xfr"],
  i: ["Xi"],
  o: ["Xopf"],
  s: ["Xscr"]
};
var Y$1 = {
  a: ["Yacute"],
  A: ["YAcy"],
  c: ["Ycirc", "Ycy"],
  f: ["Yfr"],
  I: ["YIcy"],
  o: ["Yopf"],
  s: ["Yscr"],
  U: ["YUcy"],
  u: ["Yuml"]
};
var y$3 = {
  a: ["yacute", "yacy"],
  c: ["ycirc", "ycy"],
  e: ["yen"],
  f: ["yfr"],
  i: ["yicy"],
  o: ["yopf"],
  s: ["yscr"],
  u: ["yucy", "yuml"]
};
var Z = {
  a: ["Zacute"],
  c: ["Zcaron", "Zcy"],
  d: ["Zdot"],
  e: ["ZeroWidthSpace", "Zeta"],
  f: ["Zfr"],
  H: ["ZHcy"],
  o: ["Zopf"],
  s: ["Zscr"]
};
var z$3 = {
  a: ["zacute"],
  c: ["zcaron", "zcy"],
  d: ["zdot"],
  e: ["zeetrf", "zeta"],
  f: ["zfr"],
  h: ["zhcy"],
  i: ["zigrarr"],
  o: ["zopf"],
  s: ["zscr"],
  w: ["zwj", "zwnj"]
};
var entStartsWithJson = {
  A: A,
  a: a$3,
  b: b$3,
  B: B,
  C: C,
  c: c$3,
  D: D$1,
  d: d$3,
  E: E$1,
  e: e$3,
  f: f$3,
  F: F,
  g: g$3,
  G: G$1,
  H: H$1,
  h: h$3,
  I: I$1,
  i: i$3,
  J: J,
  j: j$3,
  K: K,
  k: k$3,
  l: l$3,
  L: L$1,
  m: m$3,
  M: M,
  n: n$3,
  N: N$1,
  O: O,
  o: o$3,
  p: p$3,
  P: P$1,
  Q: Q,
  q: q$3,
  r: r$3,
  R: R$1,
  S: S$1,
  s: s$3,
  T: T$1,
  t: t$3,
  U: U$1,
  u: u$3,
  v: v$3,
  V: V$1,
  W: W,
  w: w$3,
  x: x$3,
  X: X,
  Y: Y$1,
  y: y$3,
  Z: Z,
  z: z$3
};
var e$2 = {
  t: ["Aacute", "aacute", "acute", "Cacute", "cacute", "CloseCurlyDoubleQuote", "CloseCurlyQuote", "DiacriticalAcute", "DiacriticalDoubleAcute", "Eacute", "eacute", "gacute", "Iacute", "iacute", "Lacute", "lacute", "late", "Nacute", "nacute", "Oacute", "oacute", "OpenCurlyDoubleQuote", "OpenCurlyQuote", "Racute", "racute", "Sacute", "sacute", "sdote", "smte", "Uacute", "uacute", "Yacute", "yacute", "Zacute", "zacute"],
  v: ["Abreve", "abreve", "Agrave", "agrave", "Breve", "breve", "DiacriticalGrave", "DownBreve", "Egrave", "egrave", "Gbreve", "gbreve", "grave", "Igrave", "igrave", "Ograve", "ograve", "Ubreve", "ubreve", "Ugrave", "ugrave"],
  p: ["andslope", "ape", "bumpe", "csupe", "nbumpe", "nsqsupe", "nsupe", "orslope", "sqsupe", "supe"],
  g: ["ange", "barwedge", "bigwedge", "blacklozenge", "curlywedge", "doublebarwedge", "ge", "image", "lozenge", "nge", "nvge", "range", "Wedge", "wedge", "xwedge"],
  l: ["angle", "blacktriangle", "dwangle", "exponentiale", "female", "langle", "le", "LeftTriangle", "male", "measuredangle", "nle", "NotLeftTriangle", "NotRightTriangle", "nvle", "rangle", "RightTriangle", "SmallCircle", "smile", "ssmile", "triangle", "uwangle"],
  a: ["angmsdae"],
  d: ["Atilde", "atilde", "DiacriticalTilde", "divide", "EqualTilde", "GreaterTilde", "Itilde", "itilde", "LessTilde", "NotEqualTilde", "NotGreaterTilde", "NotLessTilde", "NotSucceedsTilde", "NotTilde", "NotTildeTilde", "Ntilde", "ntilde", "Otilde", "otilde", "PrecedesTilde", "SucceedsTilde", "Tilde", "tilde", "TildeTilde", "trade", "Utilde", "utilde", "VerticalTilde"],
  m: ["backprime", "bprime", "bsime", "gsime", "lsime", "nsime", "Prime", "prime", "qprime", "sime", "tprime", "tritime", "xotime"],
  e: ["barvee", "bigvee", "curlyvee", "cuvee", "DoubleLeftTee", "DoubleRightTee", "DownTee", "ee", "LeftTee", "lthree", "RightTee", "rthree", "UpTee", "Vee", "vee", "xvee"],
  s: ["Because", "because", "maltese", "pluse"],
  r: ["blacksquare", "cire", "dotsquare", "EmptySmallSquare", "EmptyVerySmallSquare", "FilledSmallSquare", "FilledVerySmallSquare", "incare", "npre", "pre", "Square", "square", "Therefore", "therefore"],
  n: ["bne", "Colone", "colone", "gne", "HorizontalLine", "imagline", "lne", "ne", "NewLine", "oline", "phone", "Poincareplane", "profline", "realine", "simne", "subne", "supne", "VerticalLine", "vsubne", "vsupne"],
  i: ["bowtie", "die", "infintie", "ltrie", "nltrie", "nrtrie", "nvltrie", "nvrtrie", "rtrie", "trie"],
  b: ["csube", "nsqsube", "nsube", "sqsube", "sube"],
  c: ["HilbertSpace", "lbrace", "MediumSpace", "NegativeMediumSpace", "NegativeThickSpace", "NegativeThinSpace", "NegativeVeryThinSpace", "NonBreakingSpace", "nsce", "OverBrace", "race", "rbrace", "sce", "ThickSpace", "ThinSpace", "UnderBrace", "VeryThinSpace", "ZeroWidthSpace"],
  k: ["lbrke", "rbrke"],
  h: ["lmoustache", "rmoustache"],
  u: ["nprcue", "nsccue", "prcue", "sccue"],
  R: ["Re"]
};
var c$2 = {
  a: ["ac", "angmsdac", "dblac", "Odblac", "odblac", "Udblac", "udblac"],
  r: ["Acirc", "acirc", "bigcirc", "Ccirc", "ccirc", "circ", "circledcirc", "Ecirc", "ecirc", "eqcirc", "Gcirc", "gcirc", "Hcirc", "hcirc", "Icirc", "icirc", "Jcirc", "jcirc", "nrarrc", "Ocirc", "ocirc", "rarrc", "Scirc", "scirc", "Ucirc", "ucirc", "Wcirc", "wcirc", "xcirc", "Ycirc", "ycirc"],
  s: ["cuesc", "nsc", "sc"],
  e: ["curlyeqprec", "nprec", "prec", "telrec"],
  c: ["curlyeqsucc", "gescc", "gtcc", "lescc", "ltcc", "nsucc", "succ"],
  i: ["ic", "radic"],
  v: ["notinvc", "notnivc"],
  S: ["Sc"]
};
var d$2 = {
  c: ["acd"],
  n: ["And", "and", "andand", "capand", "Diamond", "diamond", "pound"],
  d: ["andd", "dd"],
  s: ["angmsd", "minusd", "nisd", "timesd"],
  a: ["angmsdad", "Gammad", "gammad"],
  b: ["angrtvbd"],
  i: ["apid", "cirmid", "mid", "napid", "nmid", "nshortmid", "nsmid", "omid", "rnmid", "shortmid", "smid"],
  e: ["Barwed", "barwed", "cuwed", "imped", "RuleDelayed"],
  H: ["boxHd"],
  h: ["boxhd", "DDotrahd"],
  o: ["coprod", "intprod", "iprod", "period", "prod"],
  g: ["langd", "rangd"],
  l: ["lbrksld", "odsold", "rbrksld"],
  r: ["lhard", "llhard", "lrhard", "ord", "rhard"]
};
var E = {
  c: ["acE", "scE"],
  p: ["apE", "bumpE", "napE", "nsupE", "supE"],
  r: ["cirE", "prE"],
  l: ["ExponentialE", "glE", "lE", "nlE", "simlE"],
  g: ["gE", "lgE", "ngE", "simgE"],
  n: ["gnE", "gvnE", "isinE", "lnE", "lvnE", "notinE", "prnE", "scnE", "subnE", "supnE", "vsubnE", "vsupnE"],
  b: ["nsubE", "subE"],
  D: ["TRADE"]
};
var y$2 = {
  c: ["Acy", "acy", "Bcy", "bcy", "CHcy", "chcy", "Dcy", "dcy", "DJcy", "djcy", "DScy", "dscy", "DZcy", "dzcy", "Ecy", "ecy", "Fcy", "fcy", "Gcy", "gcy", "GJcy", "gjcy", "HARDcy", "hardcy", "Icy", "icy", "IEcy", "iecy", "IOcy", "iocy", "Iukcy", "iukcy", "Jcy", "jcy", "Jsercy", "jsercy", "Jukcy", "jukcy", "Kcy", "kcy", "KHcy", "khcy", "KJcy", "kjcy", "Lcy", "lcy", "LJcy", "ljcy", "Mcy", "mcy", "Ncy", "ncy", "NJcy", "njcy", "Ocy", "ocy", "Pcy", "pcy", "Rcy", "rcy", "Scy", "scy", "SHCHcy", "shchcy", "SHcy", "shcy", "SOFTcy", "softcy", "Tcy", "tcy", "TScy", "tscy", "TSHcy", "tshcy", "Ubrcy", "ubrcy", "Ucy", "ucy", "Vcy", "vcy", "YAcy", "yacy", "Ycy", "ycy", "YIcy", "yicy", "YUcy", "yucy", "Zcy", "zcy", "ZHcy", "zhcy"],
  p: ["copy"],
  t: ["cylcty", "empty"],
  h: ["shy"]
};
var g$2 = {
  i: ["AElig", "aelig", "ffilig", "fflig", "ffllig", "filig", "fjlig", "fllig", "IJlig", "ijlig", "OElig", "oelig", "szlig"],
  l: ["amalg", "lg", "ntlg"],
  n: ["ang", "Aring", "aring", "backcong", "bcong", "cong", "eng", "Lang", "lang", "LeftCeiling", "loang", "nang", "ncong", "Rang", "rang", "RightCeiling", "ring", "roang", "sung", "Uring", "uring", "varnothing"],
  a: ["angmsdag", "vzigzag"],
  e: ["deg", "eg", "leg", "reg"],
  G: ["Gg", "nGg"],
  g: ["gg", "ggg"],
  E: ["lEg"],
  s: ["lesg"],
  m: ["lsimg", "simg"]
};
var f$2 = {
  a: ["af", "angmsdaf", "sigmaf"],
  p: ["Aopf", "aopf", "Bopf", "bopf", "Copf", "copf", "Dopf", "dopf", "Eopf", "eopf", "Fopf", "fopf", "Gopf", "gopf", "Hopf", "hopf", "Iopf", "iopf", "Jopf", "jopf", "Kopf", "kopf", "Lopf", "lopf", "Mopf", "mopf", "Nopf", "nopf", "Oopf", "oopf", "Popf", "popf", "Qopf", "qopf", "Ropf", "ropf", "Sopf", "sopf", "Topf", "topf", "Uopf", "uopf", "Vopf", "vopf", "Wopf", "wopf", "Xopf", "xopf", "Yopf", "yopf", "Zopf", "zopf"],
  i: ["dtrif", "ltrif", "rtrif", "utrif"],
  o: ["fnof", "imof", "orderof", "origof"],
  r: ["Fouriertrf", "Laplacetrf", "Mellintrf", "profsurf", "squarf", "sstarf", "starf", "zeetrf"],
  l: ["half"],
  f: ["iff"],
  z: ["lozf"],
  d: ["ordf"],
  u: ["squf"]
};
var r$2 = {
  f: ["Afr", "afr", "Bfr", "bfr", "Cfr", "cfr", "Dfr", "dfr", "Efr", "efr", "Ffr", "ffr", "Gfr", "gfr", "Hfr", "hfr", "Ifr", "ifr", "Jfr", "jfr", "Kfr", "kfr", "Lfr", "lfr", "Mfr", "mfr", "Nfr", "nfr", "Ofr", "ofr", "Pfr", "pfr", "Qfr", "qfr", "Rfr", "rfr", "Sfr", "sfr", "Tfr", "tfr", "Ufr", "ufr", "Vfr", "vfr", "Wfr", "wfr", "Xfr", "xfr", "Yfr", "yfr", "Zfr", "zfr"],
  c: ["Amacr", "amacr", "Ascr", "ascr", "Bscr", "bscr", "Cscr", "cscr", "Dscr", "dscr", "Emacr", "emacr", "Escr", "escr", "Fscr", "fscr", "Gscr", "gscr", "Hscr", "hscr", "Imacr", "imacr", "Iscr", "iscr", "Jscr", "jscr", "Kscr", "kscr", "Lscr", "lscr", "macr", "Mscr", "mscr", "Nscr", "nscr", "Omacr", "omacr", "Oscr", "oscr", "Pscr", "pscr", "Qscr", "qscr", "Rscr", "rscr", "Sscr", "sscr", "Tscr", "tscr", "Umacr", "umacr", "Uscr", "uscr", "Vscr", "vscr", "Wscr", "wscr", "Xscr", "xscr", "Yscr", "yscr", "Zscr", "zscr"],
  r: ["angzarr", "crarr", "cudarrr", "cularr", "curarr", "Darr", "dArr", "darr", "ddarr", "dharr", "duarr", "dzigrarr", "erarr", "gtrarr", "hArr", "harr", "hoarr", "lAarr", "Larr", "lArr", "larr", "lBarr", "lbarr", "llarr", "loarr", "lrarr", "ltlarr", "neArr", "nearr", "nhArr", "nharr", "nlArr", "nlarr", "nrArr", "nrarr", "nvHarr", "nvlArr", "nvrArr", "nwArr", "nwarr", "olarr", "orarr", "rAarr", "Rarr", "rArr", "rarr", "RBarr", "rBarr", "rbarr", "rlarr", "roarr", "rrarr", "seArr", "searr", "simrarr", "slarr", "srarr", "subrarr", "suplarr", "swArr", "swarr", "Uarr", "uArr", "uarr", "udarr", "uharr", "uuarr", "vArr", "varr", "xhArr", "xharr", "xlArr", "xlarr", "xrArr", "xrarr", "zigrarr"],
  i: ["apacir", "cir", "cirscir", "ecir", "gtcir", "harrcir", "ltcir", "midcir", "ocir", "ofcir", "olcir", "plusacir", "pluscir", "topcir", "Uarrocir"],
  a: ["bigstar", "brvbar", "dHar", "dollar", "DoubleVerticalBar", "DownArrowBar", "DownLeftVectorBar", "DownRightVectorBar", "duhar", "epar", "gtlPar", "hbar", "horbar", "ldrdhar", "ldrushar", "LeftArrowBar", "LeftDownVectorBar", "LeftTriangleBar", "LeftUpVectorBar", "LeftVectorBar", "lHar", "lopar", "lowbar", "lpar", "lrhar", "ltrPar", "lurdshar", "luruhar", "nesear", "nhpar", "NotDoubleVerticalBar", "NotLeftTriangleBar", "NotRightTriangleBar", "NotVerticalBar", "npar", "nspar", "nwnear", "ohbar", "opar", "ovbar", "OverBar", "par", "profalar", "rdldhar", "rHar", "RightArrowBar", "RightDownVectorBar", "RightTriangleBar", "RightUpVectorBar", "RightVectorBar", "rlhar", "ropar", "rpar", "ruluhar", "seswar", "solbar", "spar", "Star", "star", "swnwar", "timesbar", "udhar", "uHar", "UnderBar", "UpArrowBar", "Vbar", "vBar", "veebar", "Verbar", "verbar", "VerticalBar", "wedbar"],
  D: ["boxDr"],
  d: ["boxdr", "mldr", "nldr"],
  U: ["boxUr"],
  u: ["boxur", "natur"],
  V: ["boxVr"],
  v: ["boxvr"],
  s: ["copysr"],
  p: ["cuepr", "npr", "pr"],
  o: ["cupor", "DownLeftRightVector", "DownLeftTeeVector", "DownLeftVector", "DownRightTeeVector", "DownRightVector", "ldquor", "LeftDownTeeVector", "LeftDownVector", "LeftFloor", "LeftRightVector", "LeftTeeVector", "LeftUpDownVector", "LeftUpTeeVector", "LeftUpVector", "LeftVector", "lesdotor", "lfloor", "lsquor", "or", "oror", "rdquor", "rfloor", "RightDownTeeVector", "RightDownVector", "RightFloor", "RightTeeVector", "RightUpDownVector", "RightUpTeeVector", "RightUpVector", "RightVector", "rsquor", "VerticalSeparator"],
  e: ["Dagger", "dagger", "ddagger", "easter", "GreaterGreater", "LessEqualGreater", "LessGreater", "llcorner", "lrcorner", "marker", "NestedGreaterGreater", "NotGreater", "NotGreaterGreater", "NotLessGreater", "NotNestedGreaterGreater", "order", "ulcorner", "urcorner"],
  t: ["eqslantgtr", "lesseqgtr", "lesseqqgtr", "lessgtr", "ngtr"],
  O: ["Or"],
  P: ["Pr"],
  w: ["wr"]
};
var m$2 = {
  y: ["alefsym", "thetasym"],
  i: ["backsim", "bsim", "eqsim", "Esim", "esim", "gnsim", "gsim", "gtrsim", "larrsim", "lesssim", "lnsim", "lsim", "nesim", "ngsim", "nlsim", "nsim", "nvsim", "parsim", "plussim", "precnsim", "precsim", "prnsim", "prsim", "rarrsim", "scnsim", "scsim", "sim", "subsim", "succnsim", "succsim", "supsim", "thicksim", "thksim"],
  o: ["bottom"],
  s: ["ccupssm"],
  r: ["curarrm", "lrm"],
  a: ["diam"],
  u: ["Equilibrium", "num", "ReverseEquilibrium", "ReverseUpEquilibrium", "Sum", "sum", "trpezium", "UpEquilibrium"],
  I: ["Im"],
  h: ["ohm"],
  d: ["ordm"],
  p: ["pm"],
  l: ["rlm"]
};
var h$2 = {
  p: ["aleph", "angsph"],
  a: ["angmsdah"],
  s: ["Backslash", "circleddash", "dash", "hslash", "ldsh", "Lsh", "lsh", "mdash", "ndash", "nVDash", "nVdash", "nvDash", "nvdash", "odash", "Oslash", "oslash", "rdsh", "Rsh", "rsh", "VDash", "Vdash", "vDash", "vdash", "Vvdash"],
  t: ["beth", "daleth", "eth", "imath", "jmath", "wreath"],
  x: ["boxh"],
  V: ["boxVh"],
  v: ["boxvh"],
  k: ["planckh"],
  i: ["upsih"]
};
var a$2 = {
  h: ["Alpha", "alpha"],
  a: ["angmsdaa"],
  t: ["Beta", "beta", "Delta", "delta", "Eta", "eta", "iiota", "Iota", "iota", "Theta", "theta", "vartheta", "Zeta", "zeta"],
  l: ["Cedilla", "gla", "nabla"],
  m: ["comma", "digamma", "Gamma", "gamma", "InvisibleComma", "mcomma", "Sigma", "sigma", "varsigma"],
  p: ["Kappa", "kappa", "varkappa"],
  d: ["Lambda", "lambda"],
  c: ["ldca", "rdca"],
  v: ["notinva", "notniva"],
  g: ["Omega", "omega"],
  r: ["para"],
  e: ["toea"],
  s: ["tosa"]
};
var P = {
  M: ["AMP"]
};
var p$2 = {
  m: ["amp", "asymp", "bump", "comp", "HumpDownHump", "mp", "nbump", "NotHumpDownHump"],
  a: ["ap", "bigcap", "Cap", "cap", "capcap", "cupbrcap", "CupCap", "cupcap", "gap", "gnap", "lap", "lnap", "Map", "map", "multimap", "mumap", "nap", "ncap", "NotCupCap", "nvap", "prap", "prnap", "rarrap", "scap", "scnap", "sqcap", "thkap", "xcap", "xmap"],
  u: ["bigcup", "bigsqcup", "bigtriangleup", "capbrcup", "capcup", "csup", "Cup", "cup", "cupcup", "leftharpoonup", "mapstoup", "ncup", "nsup", "rightharpoonup", "sqcup", "sqsup", "subsup", "Sup", "sup", "supsup", "vnsup", "xcup", "xsqcup"],
  r: ["cularrp", "operp", "perp", "sharp", "weierp"],
  o: ["dlcrop", "drcrop", "prop", "top", "ulcrop", "urcrop", "vprop"],
  s: ["emsp", "ensp", "hairsp", "nbsp", "numsp", "puncsp", "thinsp"],
  i: ["hellip", "vellip"],
  l: ["larrlp", "rarrlp"],
  c: ["mlcp"],
  h: ["smashp"],
  w: ["wp"]
};
var v$2 = {
  d: ["andv"],
  r: ["Barv", "orv", "vBarv"],
  y: ["bemptyv", "cemptyv", "demptyv", "emptyv", "laemptyv", "raemptyv"],
  i: ["bnequiv", "div", "epsiv", "equiv", "nequiv", "niv", "odiv", "phiv", "piv"],
  x: ["boxv"],
  h: ["Dashv", "dashv"],
  k: ["forkv", "plankv"],
  s: ["isinsv"],
  n: ["isinv"],
  a: ["kappav", "sigmav", "thetav"],
  t: ["nGtv", "nLtv"],
  o: ["rhov"]
};
var b$2 = {
  a: ["angmsdab", "Tab"],
  v: ["angrtvb", "notinvb", "notnivb"],
  l: ["bsolb", "solb"],
  u: ["bsolhsub", "csub", "lcub", "nsub", "rcub", "sqsub", "Sub", "sub", "subsub", "supdsub", "suphsub", "supsub", "vnsub"],
  r: ["larrb", "rarrb"],
  q: ["lsqb", "rsqb"],
  s: ["minusb", "plusb", "timesb", "trisb"],
  t: ["sdotb"]
};
var t$2 = {
  r: ["angrt", "imagpart", "npart", "part", "realpart", "Sqrt", "vangrt", "Vert", "vert"],
  s: ["angst", "ast", "circledast", "equest", "exist", "gtquest", "iquest", "lmoust", "lowast", "ltquest", "midast", "nexist", "oast", "quest", "rmoust"],
  n: ["awconint", "awint", "Cconint", "cent", "cirfnint", "complement", "Congruent", "Conint", "conint", "cwconint", "cwint", "Element", "fpartint", "geqslant", "iiiint", "iiint", "Int", "int", "leqslant", "ngeqslant", "nleqslant", "NotCongruent", "NotElement", "NotReverseElement", "npolint", "oint", "percnt", "pointint", "qint", "quatint", "ReverseElement", "rppolint", "scpolint", "tint"],
  o: ["bigodot", "bNot", "bnot", "bot", "capdot", "Cdot", "cdot", "CenterDot", "centerdot", "CircleDot", "congdot", "ctdot", "cupdot", "DiacriticalDot", "Dot", "dot", "DotDot", "doteqdot", "DoubleDot", "dtdot", "eDDot", "Edot", "eDot", "edot", "efDot", "egsdot", "elsdot", "erDot", "esdot", "Gdot", "gdot", "gesdot", "gtdot", "gtrdot", "Idot", "inodot", "isindot", "lesdot", "lessdot", "Lmidot", "lmidot", "ltdot", "mDDot", "middot", "ncongdot", "nedot", "Not", "not", "notindot", "odot", "quot", "sdot", "simdot", "subdot", "subedot", "supdot", "supedot", "tdot", "topbot", "tridot", "TripleDot", "utdot", "xodot", "Zdot", "zdot"],
  f: ["blacktriangleleft", "circlearrowleft", "curvearrowleft", "downharpoonleft", "looparrowleft", "mapstoleft", "ntriangleleft", "triangleleft", "upharpoonleft", "vartriangleleft"],
  h: ["blacktriangleright", "circlearrowright", "curvearrowright", "dfisht", "downharpoonright", "homtht", "lfisht", "looparrowright", "ntriangleright", "rfisht", "triangleright", "ufisht", "upharpoonright", "vartriangleright"],
  e: ["bullet", "caret", "emptyset", "LeftAngleBracket", "LeftDoubleBracket", "NotSquareSubset", "NotSquareSuperset", "NotSubset", "NotSuperset", "nsubset", "nsupset", "OverBracket", "RightAngleBracket", "RightDoubleBracket", "sqsubset", "sqsupset", "SquareSubset", "SquareSuperset", "Subset", "subset", "Superset", "Supset", "supset", "target", "UnderBracket"],
  i: ["clubsuit", "diamondsuit", "heartsuit", "it", "spadesuit"],
  a: ["commat", "flat", "Hat", "lat", "phmmat", "SuchThat"],
  c: ["Coproduct", "Product", "rect", "sect"],
  G: ["Gt", "nGt"],
  g: ["gt", "ngt", "nvgt", "ogt", "rpargt"],
  l: ["hamilt", "lparlt", "lt", "malt", "nlt", "nvlt", "olt", "submult", "supmult"],
  L: ["Lt", "nLt"],
  x: ["sext", "twixt"],
  m: ["smt"]
};
var n$2 = {
  o: ["Aogon", "aogon", "ApplyFunction", "backepsilon", "caron", "Ccaron", "ccaron", "Colon", "colon", "Dcaron", "dcaron", "Ecaron", "ecaron", "ecolon", "Eogon", "eogon", "Epsilon", "epsilon", "eqcolon", "expectation", "hercon", "Intersection", "Iogon", "iogon", "Lcaron", "lcaron", "Ncaron", "ncaron", "ogon", "Omicron", "omicron", "Proportion", "Rcaron", "rcaron", "Scaron", "scaron", "SquareIntersection", "SquareUnion", "straightepsilon", "Tcaron", "tcaron", "Union", "Uogon", "uogon", "Upsilon", "upsilon", "varepsilon", "Zcaron", "zcaron"],
  g: ["Assign"],
  e: ["between", "curren", "hyphen", "kgreen", "yen"],
  w: ["bigtriangledown", "blacktriangledown", "frown", "leftharpoondown", "mapstodown", "rightharpoondown", "sfrown", "triangledown"],
  f: ["compfn"],
  i: ["disin", "iinfin", "in", "infin", "isin", "notin", "nvinfin"],
  r: ["dlcorn", "drcorn", "thorn", "ulcorn", "urcorn"],
  a: ["lagran"],
  m: ["plusmn", "setmn", "ssetmn"]
};
var s$2 = {
  o: ["apos", "mstpos", "napos"],
  u: ["becaus", "bigoplus", "biguplus", "boxminus", "boxplus", "CircleMinus", "CirclePlus", "dotminus", "dotplus", "eplus", "loplus", "minus", "MinusPlus", "mnplus", "ominus", "oplus", "plus", "PlusMinus", "roplus", "setminus", "simplus", "smallsetminus", "subplus", "supplus", "triminus", "triplus", "UnionPlus", "uplus", "xoplus", "xuplus"],
  i: ["Bernoullis", "nis", "OverParenthesis", "UnderParenthesis", "xnis"],
  e: ["bigotimes", "boxtimes", "CircleTimes", "complexes", "divideontimes", "ges", "gesles", "Implies", "InvisibleTimes", "lates", "leftthreetimes", "les", "lesges", "lotimes", "ltimes", "nges", "nles", "NotPrecedes", "Otimes", "otimes", "Precedes", "primes", "rightthreetimes", "rotimes", "RoundImplies", "rtimes", "smtes", "spades", "times"],
  p: ["caps", "ccaps", "ccups", "cups", "sqcaps", "sqcups"],
  y: ["Cayleys"],
  b: ["clubs"],
  s: ["Cross", "cross", "eqslantless", "GreaterEqualLess", "GreaterLess", "gtreqless", "gtreqqless", "gtrless", "LessLess", "NestedLessLess", "nless", "NotGreaterLess", "NotLess", "NotLessLess", "NotNestedLessLess", "olcross"],
  m: ["diams"],
  w: ["downdownarrows", "leftleftarrows", "leftrightarrows", "rightleftarrows", "rightrightarrows", "upuparrows"],
  g: ["egs"],
  r: ["elinters", "integers"],
  l: ["els", "equals", "models", "naturals", "rationals", "reals"],
  t: ["Exists", "hearts", "nexists", "NotExists"],
  n: ["fltns", "isins", "leftrightharpoons", "quaternions", "rightleftharpoons", "strns"],
  f: ["larrbfs", "larrfs", "rarrbfs", "rarrfs"],
  d: ["NotSucceeds", "Succeeds"],
  a: ["otimesas"]
};
var x$2 = {
  o: ["approx", "boxbox", "gnapprox", "gtrapprox", "lessapprox", "lnapprox", "napprox", "precapprox", "precnapprox", "succapprox", "succnapprox", "thickapprox"],
  n: ["divonx"],
  r: ["rx"]
};
var q$2 = {
  e: ["approxeq", "asympeq", "backsimeq", "Bumpeq", "bumpeq", "circeq", "coloneq", "ddotseq", "doteq", "fallingdotseq", "geq", "gneq", "leq", "lneq", "ngeq", "nleq", "npreceq", "nsimeq", "nsubseteq", "nsucceq", "nsupseteq", "ntrianglelefteq", "ntrianglerighteq", "preccurlyeq", "preceq", "questeq", "risingdotseq", "simeq", "sqsubseteq", "sqsupseteq", "subseteq", "subsetneq", "succcurlyeq", "succeq", "supseteq", "supsetneq", "trianglelefteq", "triangleq", "trianglerighteq", "varsubsetneq", "varsupsetneq", "veeeq", "wedgeq"],
  q: ["geqq", "gneqq", "gvertneqq", "leqq", "lneqq", "lvertneqq", "ngeqq", "nleqq", "nsubseteqq", "nsupseteqq", "precneqq", "subseteqq", "subsetneqq", "succneqq", "supseteqq", "supsetneqq", "varsubsetneqq", "varsupsetneqq"]
};
var l$2 = {
  m: ["Auml", "auml", "Euml", "euml", "gsiml", "Iuml", "iuml", "Ouml", "ouml", "siml", "uml", "Uuml", "uuml", "Yuml", "yuml"],
  D: ["boxDl"],
  d: ["boxdl"],
  U: ["boxUl"],
  u: ["boxul", "lharul", "rharul"],
  V: ["boxVl"],
  v: ["boxvl"],
  o: ["bsol", "dsol", "gesdotol", "osol", "sol", "suphsol"],
  l: ["bull", "ell", "ForAll", "forall", "hybull", "ll"],
  i: ["Ccedil", "ccedil", "cedil", "Gcedil", "Kcedil", "kcedil", "lAtail", "latail", "Lcedil", "lcedil", "lceil", "leftarrowtail", "Ncedil", "ncedil", "permil", "rAtail", "ratail", "Rcedil", "rcedil", "rceil", "rightarrowtail", "Scedil", "scedil", "Tcedil", "tcedil"],
  a: ["ClockwiseContourIntegral", "ContourIntegral", "CounterClockwiseContourIntegral", "DotEqual", "DoubleContourIntegral", "Equal", "GreaterEqual", "GreaterFullEqual", "GreaterSlantEqual", "HumpEqual", "intcal", "Integral", "intercal", "LeftTriangleEqual", "LessFullEqual", "LessSlantEqual", "natural", "NotEqual", "NotGreaterEqual", "NotGreaterFullEqual", "NotGreaterSlantEqual", "NotHumpEqual", "NotLeftTriangleEqual", "NotLessEqual", "NotLessSlantEqual", "NotPrecedesEqual", "NotPrecedesSlantEqual", "NotRightTriangleEqual", "NotSquareSubsetEqual", "NotSquareSupersetEqual", "NotSubsetEqual", "NotSucceedsEqual", "NotSucceedsSlantEqual", "NotSupersetEqual", "NotTildeEqual", "NotTildeFullEqual", "PrecedesEqual", "PrecedesSlantEqual", "Proportional", "real", "RightTriangleEqual", "SquareSubsetEqual", "SquareSupersetEqual", "SubsetEqual", "SucceedsEqual", "SucceedsSlantEqual", "SupersetEqual", "TildeEqual", "TildeFullEqual"],
  r: ["cudarrl", "dharl", "uharl"],
  e: ["Del", "el", "gel", "gimel", "nparallel", "nshortparallel", "parallel", "prurel", "shortparallel"],
  s: ["eparsl", "eqvparsl", "frasl", "gesl", "nparsl", "parsl", "smeparsl"],
  c: ["excl", "iexcl"],
  E: ["gEl"],
  g: ["gl", "ntgl"],
  p: ["larrpl", "rarrpl"],
  t: ["larrtl", "Rarrtl", "rarrtl"],
  L: ["Ll", "nLl"],
  h: ["Vdashl"]
};
var k$2 = {
  r: ["bbrk", "bbrktbrk", "checkmark", "fork", "lbbrk", "lobrk", "pitchfork", "rbbrk", "robrk", "tbrk", "topfork"],
  n: ["blank", "pertenk"],
  c: ["block", "check", "lbrack", "planck", "rbrack"],
  o: ["Dstrok", "dstrok", "Hstrok", "hstrok", "Lstrok", "lstrok", "Tstrok", "tstrok"],
  e: ["Hacek"],
  h: ["intlarhk", "larrhk", "nearhk", "nwarhk", "rarrhk", "searhk", "swarhk"],
  l: ["lhblk", "uhblk"],
  a: ["NoBreak"]
};
var o$2 = {
  u: ["bdquo", "laquo", "ldquo", "lsaquo", "lsquo", "raquo", "rdquo", "rsaquo", "rsquo", "sbquo"],
  r: ["euro", "micro", "numero"],
  t: ["gesdoto", "lesdoto", "longmapsto", "mapsto", "propto", "varpropto"],
  h: ["mho", "Rho", "rho", "varrho"],
  d: ["plusdo"],
  w: ["plustwo"],
  i: ["ratio"]
};
var i$2 = {
  s: ["bepsi", "epsi", "Psi", "psi", "Upsi", "upsi"],
  m: ["bsemi", "semi"],
  h: ["Chi", "chi", "Phi", "phi", "straightphi", "varphi"],
  r: ["dtri", "lltri", "lrtri", "ltri", "nltri", "nrtri", "rtri", "rtriltri", "ultri", "urtri", "utri", "vltri", "vrtri", "xdtri", "xutri"],
  i: ["ii"],
  n: ["ni", "notni"],
  P: ["Pi"],
  p: ["pi", "varpi"],
  X: ["Xi"],
  x: ["xi"]
};
var u$2 = {
  o: ["bernou"],
  H: ["boxHu"],
  h: ["boxhu"],
  l: ["lbrkslu", "rbrkslu"],
  r: ["lharu", "rharu"],
  d: ["minusdu", "plusdu"],
  M: ["Mu"],
  m: ["mu"],
  N: ["Nu"],
  n: ["nu"],
  q: ["squ"],
  a: ["Tau", "tau"]
};
var w$2 = {
  o: ["bkarow", "dbkarow", "DoubleDownArrow", "DoubleLeftArrow", "DoubleLeftRightArrow", "DoubleLongLeftArrow", "DoubleLongLeftRightArrow", "DoubleLongRightArrow", "DoubleRightArrow", "DoubleUpArrow", "DoubleUpDownArrow", "DownArrow", "Downarrow", "downarrow", "DownArrowUpArrow", "DownTeeArrow", "drbkarow", "hksearow", "hkswarow", "hookleftarrow", "hookrightarrow", "LeftArrow", "Leftarrow", "leftarrow", "LeftArrowRightArrow", "LeftRightArrow", "Leftrightarrow", "leftrightarrow", "leftrightsquigarrow", "LeftTeeArrow", "Lleftarrow", "LongLeftArrow", "Longleftarrow", "longleftarrow", "LongLeftRightArrow", "Longleftrightarrow", "longleftrightarrow", "LongRightArrow", "Longrightarrow", "longrightarrow", "LowerLeftArrow", "LowerRightArrow", "nearrow", "nLeftarrow", "nleftarrow", "nLeftrightarrow", "nleftrightarrow", "nRightarrow", "nrightarrow", "nwarrow", "RightArrow", "Rightarrow", "rightarrow", "RightArrowLeftArrow", "rightsquigarrow", "RightTeeArrow", "Rrightarrow", "searrow", "ShortDownArrow", "ShortLeftArrow", "ShortRightArrow", "ShortUpArrow", "swarrow", "twoheadleftarrow", "twoheadrightarrow", "UpArrow", "Uparrow", "uparrow", "UpArrowDownArrow", "UpDownArrow", "Updownarrow", "updownarrow", "UpperLeftArrow", "UpperRightArrow", "UpTeeArrow"],
  r: ["harrw", "nrarrw", "rarrw"]
};
var L = {
  D: ["boxDL"],
  d: ["boxdL"],
  U: ["boxUL"],
  u: ["boxuL"],
  V: ["boxVL"],
  v: ["boxvL"]
};
var R = {
  D: ["boxDR"],
  d: ["boxdR", "circledR"],
  U: ["boxUR"],
  u: ["boxuR"],
  V: ["boxVR"],
  v: ["boxvR"]
};
var H = {
  x: ["boxH"],
  V: ["boxVH"],
  v: ["boxvH"],
  T: ["ETH"]
};
var D = {
  H: ["boxHD"],
  h: ["boxhD"],
  l: ["CapitalDifferentialD", "DifferentialD", "PartialD"],
  D: ["DD", "equivDD"]
};
var U = {
  H: ["boxHU"],
  h: ["boxhU"]
};
var V = {
  x: ["boxV"]
};
var S = {
  d: ["circledS"],
  o: ["oS"]
};
var Y = {
  P: ["COPY"]
};
var G = {
  N: ["ENG"],
  E: ["REG"]
};
var j$2 = {
  l: ["glj"],
  w: ["zwj"],
  n: ["zwnj"]
};
var T = {
  G: ["GT"],
  L: ["LT"],
  O: ["QUOT"]
};
var I = {
  y: ["ImaginaryI"]
};
var z$2 = {
  o: ["loz"]
};
var N = {
  R: ["THORN"]
};
var entEndsWithJson = {
  "1": {
    p: ["sup1"]
  },
  "2": {
    "1": ["blk12", "frac12"],
    p: ["sup2"]
  },
  "3": {
    "1": ["emsp13", "frac13"],
    "2": ["frac23"],
    p: ["sup3"]
  },
  "4": {
    "1": ["blk14", "emsp14", "frac14"],
    "3": ["blk34", "frac34"],
    e: ["there4"]
  },
  "5": {
    "1": ["frac15"],
    "2": ["frac25"],
    "3": ["frac35"],
    "4": ["frac45"]
  },
  "6": {
    "1": ["frac16"],
    "5": ["frac56"]
  },
  "8": {
    "1": ["frac18"],
    "3": ["frac38"],
    "5": ["frac58"],
    "7": ["frac78"]
  },
  e: e$2,
  c: c$2,
  d: d$2,
  E: E,
  y: y$2,
  g: g$2,
  f: f$2,
  r: r$2,
  m: m$2,
  h: h$2,
  a: a$2,
  P: P,
  p: p$2,
  v: v$2,
  b: b$2,
  t: t$2,
  n: n$2,
  s: s$2,
  x: x$2,
  q: q$2,
  l: l$2,
  k: k$2,
  o: o$2,
  i: i$2,
  u: u$2,
  w: w$2,
  L: L,
  R: R,
  H: H,
  D: D,
  U: U,
  V: V,
  S: S,
  Y: Y,
  G: G,
  j: j$2,
  T: T,
  I: I,
  z: z$2,
  N: N
};
var ac = {
  addAmpIfSemiPresent: "edge only",
  addSemiIfAmpPresent: false
};
var acute = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var Alpha = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var alpha = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var amp = {
  addAmpIfSemiPresent: "edge only",
  addSemiIfAmpPresent: true
};
var And = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: true
};
var and = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: true
};
var ange = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: true
};
var angle = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var angst = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: true
};
var ap = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ape = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var approx = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Aring = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: true
};
var aring = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: true
};
var Ascr = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ascr = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var Assign = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ast = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var atilde = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: true
};
var Backslash = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var barwedge = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var becaus = {
  addAmpIfSemiPresent: true,
  addSemiIfAmpPresent: "edge only"
};
var Because = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var because = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var bepsi = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var Bernoullis = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var Beta = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var beta = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var beth = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var between = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var blank = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var block = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var bot = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var bottom = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var bowtie = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var breve = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var bull = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var bullet = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var bump = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var cacute = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var Cap = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var cap = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var capand = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var caps = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var caret = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var caron = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var cedil = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Cedilla = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var cent = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: true
};
var check = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var checkmark = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Chi = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var chi = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var cir = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var circ = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var clubs = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var clubsuit = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Colon = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var colon = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Colone = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var colone = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var comma = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var commat = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var comp = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var complement = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var complexes = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var cong = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Congruent = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var conint = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var copf = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var coprod = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var COPY = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var copy = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var Cross = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var cross = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Cup = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var cup = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var cups = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Dagger = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var dagger = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var daleth = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var darr = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var dash = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var DD = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var dd = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var deg = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var Del = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var Delta = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var delta = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var dharr = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var diam = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var Diamond = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var diamond = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var diams = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var die = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var digamma = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var disin = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var div = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var divide = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var dollar = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var dopf = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var Dot = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var dot = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var dsol = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var dtri = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var easter = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var ecir = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ecolon = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ecy = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var edot = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ee = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var efr = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var eg = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var egrave = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var egs = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var el = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ell = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var els = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var empty = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var ENG = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var eng = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var epsi = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Epsilon = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var epsilon = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Equal = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var equals = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var equest = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var Equilibrium = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var equiv = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var escr = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var esim = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var Eta = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var eta = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ETH = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var eth = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var euro = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var excl = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var exist = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Exists = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var expectation = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var female = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var flat = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var fork = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var frown = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Gamma = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var gamma = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var gap = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var gcy = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ge = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var gel = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var geq = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ges = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var gesl = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var gg = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var gl = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var gla = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var gne = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var grave = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var GT = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var gt = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var half = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Hat = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var hearts = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var hopf = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var hyphen = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var ic = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var icy = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var iff = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ii = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var image = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var imped = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var int = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var integers = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var iocy = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var iogon = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var iota = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var isin = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var it = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Kappa = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var kappa = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var kopf = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Lambda = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var lambda = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var lang = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var lap = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var lat = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var late = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var lates = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var le = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var leg = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var leq = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var les = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var lg = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ll = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var lne = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var lozenge = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var lsh = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var LT = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var lt = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ltimes = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: true
};
var male = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var malt = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var map = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var marker = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var mid = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var minus = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var models = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var mp = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var mu = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var nang = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var nap = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var natural = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var naturals = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var ncy = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ne = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var nge = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ngt = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ni = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var nis = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var nle = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var nles = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var nless = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var nlt = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var nopf = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var Not = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var not = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var nsc = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var nsce = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var nu = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var num = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var ogt = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ohm = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var oline = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var olt = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var Omega = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var omega = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Omicron = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var omicron = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var oopf = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var opar = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var or = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var order = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var oror = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var orv = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var osol = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var par = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var para = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var parallel = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var part = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var phi = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var phone = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Pi = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var pi = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var pitchfork = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var plus = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var pm = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var popf = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var pound = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var pr = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var prime = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var primes = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var prod = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Product = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var prop = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Proportion = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Proportional = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var psi = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var quest = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var QUOT = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var quot = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var race = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var rang = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var range = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var ratio = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Re = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var real = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var reals = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var rect = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var REG = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: true
};
var reg = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ring = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var rsh = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var sc = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var scap = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var sce = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var scy = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var sdot = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var sect = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var semi = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var sharp = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var shy = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Sigma = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var sigma = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var sim = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var sol = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var spades = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var square = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Star = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var star = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Sub = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var sub = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var sube = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Sum = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var sum = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Tab = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var target = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Tau = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var tau = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var therefore = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Theta = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var theta = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var THORN = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var thorn = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Tilde = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var tilde = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var times = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var tint = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var top = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var tosa = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var TRADE = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var trade = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var triangle = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var trie = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ucy = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var uml = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Union = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var uplus = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var Upsi = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var upsi = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var uring = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var vee = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var Vert = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var vert = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var wedge = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Wedge = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var wreath = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Xi = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var xi = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Ycirc = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ycirc = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var ycy = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var yen = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var Zacute = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var zacute = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: "edge only"
};
var Zeta = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var zeta = {
  addAmpIfSemiPresent: false,
  addSemiIfAmpPresent: false
};
var uncertainJson = {
  ac: ac,
  acute: acute,
  Alpha: Alpha,
  alpha: alpha,
  amp: amp,
  And: And,
  and: and,
  ange: ange,
  angle: angle,
  angst: angst,
  ap: ap,
  ape: ape,
  approx: approx,
  Aring: Aring,
  aring: aring,
  Ascr: Ascr,
  ascr: ascr,
  Assign: Assign,
  ast: ast,
  atilde: atilde,
  Backslash: Backslash,
  barwedge: barwedge,
  becaus: becaus,
  Because: Because,
  because: because,
  bepsi: bepsi,
  Bernoullis: Bernoullis,
  Beta: Beta,
  beta: beta,
  beth: beth,
  between: between,
  blank: blank,
  block: block,
  bot: bot,
  bottom: bottom,
  bowtie: bowtie,
  breve: breve,
  bull: bull,
  bullet: bullet,
  bump: bump,
  cacute: cacute,
  Cap: Cap,
  cap: cap,
  capand: capand,
  caps: caps,
  caret: caret,
  caron: caron,
  cedil: cedil,
  Cedilla: Cedilla,
  cent: cent,
  check: check,
  checkmark: checkmark,
  Chi: Chi,
  chi: chi,
  cir: cir,
  circ: circ,
  clubs: clubs,
  clubsuit: clubsuit,
  Colon: Colon,
  colon: colon,
  Colone: Colone,
  colone: colone,
  comma: comma,
  commat: commat,
  comp: comp,
  complement: complement,
  complexes: complexes,
  cong: cong,
  Congruent: Congruent,
  conint: conint,
  copf: copf,
  coprod: coprod,
  COPY: COPY,
  copy: copy,
  Cross: Cross,
  cross: cross,
  Cup: Cup,
  cup: cup,
  cups: cups,
  Dagger: Dagger,
  dagger: dagger,
  daleth: daleth,
  darr: darr,
  dash: dash,
  DD: DD,
  dd: dd,
  deg: deg,
  Del: Del,
  Delta: Delta,
  delta: delta,
  dharr: dharr,
  diam: diam,
  Diamond: Diamond,
  diamond: diamond,
  diams: diams,
  die: die,
  digamma: digamma,
  disin: disin,
  div: div,
  divide: divide,
  dollar: dollar,
  dopf: dopf,
  Dot: Dot,
  dot: dot,
  dsol: dsol,
  dtri: dtri,
  easter: easter,
  ecir: ecir,
  ecolon: ecolon,
  ecy: ecy,
  edot: edot,
  ee: ee,
  efr: efr,
  eg: eg,
  egrave: egrave,
  egs: egs,
  el: el,
  ell: ell,
  els: els,
  empty: empty,
  ENG: ENG,
  eng: eng,
  epsi: epsi,
  Epsilon: Epsilon,
  epsilon: epsilon,
  Equal: Equal,
  equals: equals,
  equest: equest,
  Equilibrium: Equilibrium,
  equiv: equiv,
  escr: escr,
  esim: esim,
  Eta: Eta,
  eta: eta,
  ETH: ETH,
  eth: eth,
  euro: euro,
  excl: excl,
  exist: exist,
  Exists: Exists,
  expectation: expectation,
  female: female,
  flat: flat,
  fork: fork,
  frown: frown,
  Gamma: Gamma,
  gamma: gamma,
  gap: gap,
  gcy: gcy,
  ge: ge,
  gel: gel,
  geq: geq,
  ges: ges,
  gesl: gesl,
  gg: gg,
  gl: gl,
  gla: gla,
  gne: gne,
  grave: grave,
  GT: GT,
  gt: gt,
  half: half,
  Hat: Hat,
  hearts: hearts,
  hopf: hopf,
  hyphen: hyphen,
  ic: ic,
  icy: icy,
  iff: iff,
  ii: ii,
  image: image,
  imped: imped,
  "in": {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  },
  int: int,
  integers: integers,
  iocy: iocy,
  iogon: iogon,
  iota: iota,
  isin: isin,
  it: it,
  Kappa: Kappa,
  kappa: kappa,
  kopf: kopf,
  Lambda: Lambda,
  lambda: lambda,
  lang: lang,
  lap: lap,
  lat: lat,
  late: late,
  lates: lates,
  le: le,
  leg: leg,
  leq: leq,
  les: les,
  lg: lg,
  ll: ll,
  lne: lne,
  lozenge: lozenge,
  lsh: lsh,
  LT: LT,
  lt: lt,
  ltimes: ltimes,
  male: male,
  malt: malt,
  map: map,
  marker: marker,
  mid: mid,
  minus: minus,
  models: models,
  mp: mp,
  mu: mu,
  nang: nang,
  nap: nap,
  natural: natural,
  naturals: naturals,
  ncy: ncy,
  ne: ne,
  nge: nge,
  ngt: ngt,
  ni: ni,
  nis: nis,
  nle: nle,
  nles: nles,
  nless: nless,
  nlt: nlt,
  nopf: nopf,
  Not: Not,
  not: not,
  nsc: nsc,
  nsce: nsce,
  nu: nu,
  num: num,
  ogt: ogt,
  ohm: ohm,
  oline: oline,
  olt: olt,
  Omega: Omega,
  omega: omega,
  Omicron: Omicron,
  omicron: omicron,
  oopf: oopf,
  opar: opar,
  or: or,
  order: order,
  oror: oror,
  orv: orv,
  osol: osol,
  par: par,
  para: para,
  parallel: parallel,
  part: part,
  phi: phi,
  phone: phone,
  Pi: Pi,
  pi: pi,
  pitchfork: pitchfork,
  plus: plus,
  pm: pm,
  popf: popf,
  pound: pound,
  pr: pr,
  prime: prime,
  primes: primes,
  prod: prod,
  Product: Product,
  prop: prop,
  Proportion: Proportion,
  Proportional: Proportional,
  psi: psi,
  quest: quest,
  QUOT: QUOT,
  quot: quot,
  race: race,
  rang: rang,
  range: range,
  ratio: ratio,
  Re: Re,
  real: real,
  reals: reals,
  rect: rect,
  REG: REG,
  reg: reg,
  ring: ring,
  rsh: rsh,
  sc: sc,
  scap: scap,
  sce: sce,
  scy: scy,
  sdot: sdot,
  sect: sect,
  semi: semi,
  sharp: sharp,
  shy: shy,
  Sigma: Sigma,
  sigma: sigma,
  sim: sim,
  sol: sol,
  spades: spades,
  square: square,
  Star: Star,
  star: star,
  Sub: Sub,
  sub: sub,
  sube: sube,
  Sum: Sum,
  sum: sum,
  Tab: Tab,
  target: target,
  Tau: Tau,
  tau: tau,
  therefore: therefore,
  Theta: Theta,
  theta: theta,
  THORN: THORN,
  thorn: thorn,
  Tilde: Tilde,
  tilde: tilde,
  times: times,
  tint: tint,
  top: top,
  tosa: tosa,
  TRADE: TRADE,
  trade: trade,
  triangle: triangle,
  trie: trie,
  ucy: ucy,
  uml: uml,
  Union: Union,
  uplus: uplus,
  Upsi: Upsi,
  upsi: upsi,
  uring: uring,
  vee: vee,
  Vert: Vert,
  vert: vert,
  wedge: wedge,
  Wedge: Wedge,
  wreath: wreath,
  Xi: Xi,
  xi: xi,
  Ycirc: Ycirc,
  ycirc: ycirc,
  ycy: ycy,
  yen: yen,
  Zacute: Zacute,
  zacute: zacute,
  Zeta: Zeta,
  zeta: zeta
};
var allNamedEntities = allNamedEntitiesJson;
var brokenNamedEntities = brokenNamedEntitiesJson;
var entStartsWith = entStartsWithJson;
var entEndsWith = entEndsWithJson;
var uncertain = uncertainJson;
var allNamedEntitiesSetOnly = new Set(["Aacute", "aacute", "Abreve", "abreve", "ac", "acd", "acE", "Acirc", "acirc", "acute", "Acy", "acy", "AElig", "aelig", "af", "Afr", "afr", "Agrave", "agrave", "alefsym", "aleph", "Alpha", "alpha", "Amacr", "amacr", "amalg", "AMP", "amp", "And", "and", "andand", "andd", "andslope", "andv", "ang", "ange", "angle", "angmsd", "angmsdaa", "angmsdab", "angmsdac", "angmsdad", "angmsdae", "angmsdaf", "angmsdag", "angmsdah", "angrt", "angrtvb", "angrtvbd", "angsph", "angst", "angzarr", "Aogon", "aogon", "Aopf", "aopf", "ap", "apacir", "apE", "ape", "apid", "apos", "ApplyFunction", "approx", "approxeq", "Aring", "aring", "Ascr", "ascr", "Assign", "ast", "asymp", "asympeq", "Atilde", "atilde", "Auml", "auml", "awconint", "awint", "backcong", "backepsilon", "backprime", "backsim", "backsimeq", "Backslash", "Barv", "barvee", "Barwed", "barwed", "barwedge", "bbrk", "bbrktbrk", "bcong", "Bcy", "bcy", "bdquo", "becaus", "Because", "because", "bemptyv", "bepsi", "bernou", "Bernoullis", "Beta", "beta", "beth", "between", "Bfr", "bfr", "bigcap", "bigcirc", "bigcup", "bigodot", "bigoplus", "bigotimes", "bigsqcup", "bigstar", "bigtriangledown", "bigtriangleup", "biguplus", "bigvee", "bigwedge", "bkarow", "blacklozenge", "blacksquare", "blacktriangle", "blacktriangledown", "blacktriangleleft", "blacktriangleright", "blank", "blk12", "blk14", "blk34", "block", "bne", "bnequiv", "bNot", "bnot", "Bopf", "bopf", "bot", "bottom", "bowtie", "boxbox", "boxDL", "boxDl", "boxdL", "boxdl", "boxDR", "boxDr", "boxdR", "boxdr", "boxH", "boxh", "boxHD", "boxHd", "boxhD", "boxhd", "boxHU", "boxHu", "boxhU", "boxhu", "boxminus", "boxplus", "boxtimes", "boxUL", "boxUl", "boxuL", "boxul", "boxUR", "boxUr", "boxuR", "boxur", "boxV", "boxv", "boxVH", "boxVh", "boxvH", "boxvh", "boxVL", "boxVl", "boxvL", "boxvl", "boxVR", "boxVr", "boxvR", "boxvr", "bprime", "Breve", "breve", "brvbar", "Bscr", "bscr", "bsemi", "bsim", "bsime", "bsol", "bsolb", "bsolhsub", "bull", "bullet", "bump", "bumpE", "bumpe", "Bumpeq", "bumpeq", "Cacute", "cacute", "Cap", "cap", "capand", "capbrcup", "capcap", "capcup", "capdot", "CapitalDifferentialD", "caps", "caret", "caron", "Cayleys", "ccaps", "Ccaron", "ccaron", "Ccedil", "ccedil", "Ccirc", "ccirc", "Cconint", "ccups", "ccupssm", "Cdot", "cdot", "cedil", "Cedilla", "cemptyv", "cent", "CenterDot", "centerdot", "Cfr", "cfr", "CHcy", "chcy", "check", "checkmark", "Chi", "chi", "cir", "circ", "circeq", "circlearrowleft", "circlearrowright", "circledast", "circledcirc", "circleddash", "CircleDot", "circledR", "circledS", "CircleMinus", "CirclePlus", "CircleTimes", "cirE", "cire", "cirfnint", "cirmid", "cirscir", "ClockwiseContourIntegral", "CloseCurlyDoubleQuote", "CloseCurlyQuote", "clubs", "clubsuit", "Colon", "colon", "Colone", "colone", "coloneq", "comma", "commat", "comp", "compfn", "complement", "complexes", "cong", "congdot", "Congruent", "Conint", "conint", "ContourIntegral", "Copf", "copf", "coprod", "Coproduct", "COPY", "copy", "copysr", "CounterClockwiseContourIntegral", "crarr", "Cross", "cross", "Cscr", "cscr", "csub", "csube", "csup", "csupe", "ctdot", "cudarrl", "cudarrr", "cuepr", "cuesc", "cularr", "cularrp", "Cup", "cup", "cupbrcap", "CupCap", "cupcap", "cupcup", "cupdot", "cupor", "cups", "curarr", "curarrm", "curlyeqprec", "curlyeqsucc", "curlyvee", "curlywedge", "curren", "curvearrowleft", "curvearrowright", "cuvee", "cuwed", "cwconint", "cwint", "cylcty", "Dagger", "dagger", "daleth", "Darr", "dArr", "darr", "dash", "Dashv", "dashv", "dbkarow", "dblac", "Dcaron", "dcaron", "Dcy", "dcy", "DD", "dd", "ddagger", "ddarr", "DDotrahd", "ddotseq", "deg", "Del", "Delta", "delta", "demptyv", "dfisht", "Dfr", "dfr", "dHar", "dharl", "dharr", "DiacriticalAcute", "DiacriticalDot", "DiacriticalDoubleAcute", "DiacriticalGrave", "DiacriticalTilde", "diam", "Diamond", "diamond", "diamondsuit", "diams", "die", "DifferentialD", "digamma", "disin", "div", "divide", "divideontimes", "divonx", "DJcy", "djcy", "dlcorn", "dlcrop", "dollar", "Dopf", "dopf", "Dot", "dot", "DotDot", "doteq", "doteqdot", "DotEqual", "dotminus", "dotplus", "dotsquare", "doublebarwedge", "DoubleContourIntegral", "DoubleDot", "DoubleDownArrow", "DoubleLeftArrow", "DoubleLeftRightArrow", "DoubleLeftTee", "DoubleLongLeftArrow", "DoubleLongLeftRightArrow", "DoubleLongRightArrow", "DoubleRightArrow", "DoubleRightTee", "DoubleUpArrow", "DoubleUpDownArrow", "DoubleVerticalBar", "DownArrow", "Downarrow", "downarrow", "DownArrowBar", "DownArrowUpArrow", "DownBreve", "downdownarrows", "downharpoonleft", "downharpoonright", "DownLeftRightVector", "DownLeftTeeVector", "DownLeftVector", "DownLeftVectorBar", "DownRightTeeVector", "DownRightVector", "DownRightVectorBar", "DownTee", "DownTeeArrow", "drbkarow", "drcorn", "drcrop", "Dscr", "dscr", "DScy", "dscy", "dsol", "Dstrok", "dstrok", "dtdot", "dtri", "dtrif", "duarr", "duhar", "dwangle", "DZcy", "dzcy", "dzigrarr", "Eacute", "eacute", "easter", "Ecaron", "ecaron", "ecir", "Ecirc", "ecirc", "ecolon", "Ecy", "ecy", "eDDot", "Edot", "eDot", "edot", "ee", "efDot", "Efr", "efr", "eg", "Egrave", "egrave", "egs", "egsdot", "el", "Element", "elinters", "ell", "els", "elsdot", "Emacr", "emacr", "empty", "emptyset", "EmptySmallSquare", "emptyv", "EmptyVerySmallSquare", "emsp", "emsp13", "emsp14", "ENG", "eng", "ensp", "Eogon", "eogon", "Eopf", "eopf", "epar", "eparsl", "eplus", "epsi", "Epsilon", "epsilon", "epsiv", "eqcirc", "eqcolon", "eqsim", "eqslantgtr", "eqslantless", "Equal", "equals", "EqualTilde", "equest", "Equilibrium", "equiv", "equivDD", "eqvparsl", "erarr", "erDot", "Escr", "escr", "esdot", "Esim", "esim", "Eta", "eta", "ETH", "eth", "Euml", "euml", "euro", "excl", "exist", "Exists", "expectation", "ExponentialE", "exponentiale", "fallingdotseq", "Fcy", "fcy", "female", "ffilig", "fflig", "ffllig", "Ffr", "ffr", "filig", "FilledSmallSquare", "FilledVerySmallSquare", "fjlig", "flat", "fllig", "fltns", "fnof", "Fopf", "fopf", "ForAll", "forall", "fork", "forkv", "Fouriertrf", "fpartint", "frac12", "frac13", "frac14", "frac15", "frac16", "frac18", "frac23", "frac25", "frac34", "frac35", "frac38", "frac45", "frac56", "frac58", "frac78", "frasl", "frown", "Fscr", "fscr", "gacute", "Gamma", "gamma", "Gammad", "gammad", "gap", "Gbreve", "gbreve", "Gcedil", "Gcirc", "gcirc", "Gcy", "gcy", "Gdot", "gdot", "gE", "ge", "gEl", "gel", "geq", "geqq", "geqslant", "ges", "gescc", "gesdot", "gesdoto", "gesdotol", "gesl", "gesles", "Gfr", "gfr", "Gg", "gg", "ggg", "gimel", "GJcy", "gjcy", "gl", "gla", "glE", "glj", "gnap", "gnapprox", "gnE", "gne", "gneq", "gneqq", "gnsim", "Gopf", "gopf", "grave", "GreaterEqual", "GreaterEqualLess", "GreaterFullEqual", "GreaterGreater", "GreaterLess", "GreaterSlantEqual", "GreaterTilde", "Gscr", "gscr", "gsim", "gsime", "gsiml", "GT", "Gt", "gt", "gtcc", "gtcir", "gtdot", "gtlPar", "gtquest", "gtrapprox", "gtrarr", "gtrdot", "gtreqless", "gtreqqless", "gtrless", "gtrsim", "gvertneqq", "gvnE", "Hacek", "hairsp", "half", "hamilt", "HARDcy", "hardcy", "hArr", "harr", "harrcir", "harrw", "Hat", "hbar", "Hcirc", "hcirc", "hearts", "heartsuit", "hellip", "hercon", "Hfr", "hfr", "HilbertSpace", "hksearow", "hkswarow", "hoarr", "homtht", "hookleftarrow", "hookrightarrow", "Hopf", "hopf", "horbar", "HorizontalLine", "Hscr", "hscr", "hslash", "Hstrok", "hstrok", "HumpDownHump", "HumpEqual", "hybull", "hyphen", "Iacute", "iacute", "ic", "Icirc", "icirc", "Icy", "icy", "Idot", "IEcy", "iecy", "iexcl", "iff", "Ifr", "ifr", "Igrave", "igrave", "ii", "iiiint", "iiint", "iinfin", "iiota", "IJlig", "ijlig", "Im", "Imacr", "imacr", "image", "ImaginaryI", "imagline", "imagpart", "imath", "imof", "imped", "Implies", "in", "incare", "infin", "infintie", "inodot", "Int", "int", "intcal", "integers", "Integral", "intercal", "Intersection", "intlarhk", "intprod", "InvisibleComma", "InvisibleTimes", "IOcy", "iocy", "Iogon", "iogon", "Iopf", "iopf", "Iota", "iota", "iprod", "iquest", "Iscr", "iscr", "isin", "isindot", "isinE", "isins", "isinsv", "isinv", "it", "Itilde", "itilde", "Iukcy", "iukcy", "Iuml", "iuml", "Jcirc", "jcirc", "Jcy", "jcy", "Jfr", "jfr", "jmath", "Jopf", "jopf", "Jscr", "jscr", "Jsercy", "jsercy", "Jukcy", "jukcy", "Kappa", "kappa", "kappav", "Kcedil", "kcedil", "Kcy", "kcy", "Kfr", "kfr", "kgreen", "KHcy", "khcy", "KJcy", "kjcy", "Kopf", "kopf", "Kscr", "kscr", "lAarr", "Lacute", "lacute", "laemptyv", "lagran", "Lambda", "lambda", "Lang", "lang", "langd", "langle", "lap", "Laplacetrf", "laquo", "Larr", "lArr", "larr", "larrb", "larrbfs", "larrfs", "larrhk", "larrlp", "larrpl", "larrsim", "larrtl", "lat", "lAtail", "latail", "late", "lates", "lBarr", "lbarr", "lbbrk", "lbrace", "lbrack", "lbrke", "lbrksld", "lbrkslu", "Lcaron", "lcaron", "Lcedil", "lcedil", "lceil", "lcub", "Lcy", "lcy", "ldca", "ldquo", "ldquor", "ldrdhar", "ldrushar", "ldsh", "lE", "le", "LeftAngleBracket", "LeftArrow", "Leftarrow", "leftarrow", "LeftArrowBar", "LeftArrowRightArrow", "leftarrowtail", "LeftCeiling", "LeftDoubleBracket", "LeftDownTeeVector", "LeftDownVector", "LeftDownVectorBar", "LeftFloor", "leftharpoondown", "leftharpoonup", "leftleftarrows", "LeftRightArrow", "Leftrightarrow", "leftrightarrow", "leftrightarrows", "leftrightharpoons", "leftrightsquigarrow", "LeftRightVector", "LeftTee", "LeftTeeArrow", "LeftTeeVector", "leftthreetimes", "LeftTriangle", "LeftTriangleBar", "LeftTriangleEqual", "LeftUpDownVector", "LeftUpTeeVector", "LeftUpVector", "LeftUpVectorBar", "LeftVector", "LeftVectorBar", "lEg", "leg", "leq", "leqq", "leqslant", "les", "lescc", "lesdot", "lesdoto", "lesdotor", "lesg", "lesges", "lessapprox", "lessdot", "lesseqgtr", "lesseqqgtr", "LessEqualGreater", "LessFullEqual", "LessGreater", "lessgtr", "LessLess", "lesssim", "LessSlantEqual", "LessTilde", "lfisht", "lfloor", "Lfr", "lfr", "lg", "lgE", "lHar", "lhard", "lharu", "lharul", "lhblk", "LJcy", "ljcy", "Ll", "ll", "llarr", "llcorner", "Lleftarrow", "llhard", "lltri", "Lmidot", "lmidot", "lmoust", "lmoustache", "lnap", "lnapprox", "lnE", "lne", "lneq", "lneqq", "lnsim", "loang", "loarr", "lobrk", "LongLeftArrow", "Longleftarrow", "longleftarrow", "LongLeftRightArrow", "Longleftrightarrow", "longleftrightarrow", "longmapsto", "LongRightArrow", "Longrightarrow", "longrightarrow", "looparrowleft", "looparrowright", "lopar", "Lopf", "lopf", "loplus", "lotimes", "lowast", "lowbar", "LowerLeftArrow", "LowerRightArrow", "loz", "lozenge", "lozf", "lpar", "lparlt", "lrarr", "lrcorner", "lrhar", "lrhard", "lrm", "lrtri", "lsaquo", "Lscr", "lscr", "Lsh", "lsh", "lsim", "lsime", "lsimg", "lsqb", "lsquo", "lsquor", "Lstrok", "lstrok", "LT", "Lt", "lt", "ltcc", "ltcir", "ltdot", "lthree", "ltimes", "ltlarr", "ltquest", "ltri", "ltrie", "ltrif", "ltrPar", "lurdshar", "luruhar", "lvertneqq", "lvnE", "macr", "male", "malt", "maltese", "Map", "map", "mapsto", "mapstodown", "mapstoleft", "mapstoup", "marker", "mcomma", "Mcy", "mcy", "mdash", "mDDot", "measuredangle", "MediumSpace", "Mellintrf", "Mfr", "mfr", "mho", "micro", "mid", "midast", "midcir", "middot", "minus", "minusb", "minusd", "minusdu", "MinusPlus", "mlcp", "mldr", "mnplus", "models", "Mopf", "mopf", "mp", "Mscr", "mscr", "mstpos", "Mu", "mu", "multimap", "mumap", "nabla", "Nacute", "nacute", "nang", "nap", "napE", "napid", "napos", "napprox", "natur", "natural", "naturals", "nbsp", "nbump", "nbumpe", "ncap", "Ncaron", "ncaron", "Ncedil", "ncedil", "ncong", "ncongdot", "ncup", "Ncy", "ncy", "ndash", "ne", "nearhk", "neArr", "nearr", "nearrow", "nedot", "NegativeMediumSpace", "NegativeThickSpace", "NegativeThinSpace", "NegativeVeryThinSpace", "nequiv", "nesear", "nesim", "NestedGreaterGreater", "NestedLessLess", "NewLine", "nexist", "nexists", "Nfr", "nfr", "ngE", "nge", "ngeq", "ngeqq", "ngeqslant", "nges", "nGg", "ngsim", "nGt", "ngt", "ngtr", "nGtv", "nhArr", "nharr", "nhpar", "ni", "nis", "nisd", "niv", "NJcy", "njcy", "nlArr", "nlarr", "nldr", "nlE", "nle", "nLeftarrow", "nleftarrow", "nLeftrightarrow", "nleftrightarrow", "nleq", "nleqq", "nleqslant", "nles", "nless", "nLl", "nlsim", "nLt", "nlt", "nltri", "nltrie", "nLtv", "nmid", "NoBreak", "NonBreakingSpace", "Nopf", "nopf", "Not", "not", "NotCongruent", "NotCupCap", "NotDoubleVerticalBar", "NotElement", "NotEqual", "NotEqualTilde", "NotExists", "NotGreater", "NotGreaterEqual", "NotGreaterFullEqual", "NotGreaterGreater", "NotGreaterLess", "NotGreaterSlantEqual", "NotGreaterTilde", "NotHumpDownHump", "NotHumpEqual", "notin", "notindot", "notinE", "notinva", "notinvb", "notinvc", "NotLeftTriangle", "NotLeftTriangleBar", "NotLeftTriangleEqual", "NotLess", "NotLessEqual", "NotLessGreater", "NotLessLess", "NotLessSlantEqual", "NotLessTilde", "NotNestedGreaterGreater", "NotNestedLessLess", "notni", "notniva", "notnivb", "notnivc", "NotPrecedes", "NotPrecedesEqual", "NotPrecedesSlantEqual", "NotReverseElement", "NotRightTriangle", "NotRightTriangleBar", "NotRightTriangleEqual", "NotSquareSubset", "NotSquareSubsetEqual", "NotSquareSuperset", "NotSquareSupersetEqual", "NotSubset", "NotSubsetEqual", "NotSucceeds", "NotSucceedsEqual", "NotSucceedsSlantEqual", "NotSucceedsTilde", "NotSuperset", "NotSupersetEqual", "NotTilde", "NotTildeEqual", "NotTildeFullEqual", "NotTildeTilde", "NotVerticalBar", "npar", "nparallel", "nparsl", "npart", "npolint", "npr", "nprcue", "npre", "nprec", "npreceq", "nrArr", "nrarr", "nrarrc", "nrarrw", "nRightarrow", "nrightarrow", "nrtri", "nrtrie", "nsc", "nsccue", "nsce", "Nscr", "nscr", "nshortmid", "nshortparallel", "nsim", "nsime", "nsimeq", "nsmid", "nspar", "nsqsube", "nsqsupe", "nsub", "nsubE", "nsube", "nsubset", "nsubseteq", "nsubseteqq", "nsucc", "nsucceq", "nsup", "nsupE", "nsupe", "nsupset", "nsupseteq", "nsupseteqq", "ntgl", "Ntilde", "ntilde", "ntlg", "ntriangleleft", "ntrianglelefteq", "ntriangleright", "ntrianglerighteq", "Nu", "nu", "num", "numero", "numsp", "nvap", "nVDash", "nVdash", "nvDash", "nvdash", "nvge", "nvgt", "nvHarr", "nvinfin", "nvlArr", "nvle", "nvlt", "nvltrie", "nvrArr", "nvrtrie", "nvsim", "nwarhk", "nwArr", "nwarr", "nwarrow", "nwnear", "Oacute", "oacute", "oast", "ocir", "Ocirc", "ocirc", "Ocy", "ocy", "odash", "Odblac", "odblac", "odiv", "odot", "odsold", "OElig", "oelig", "ofcir", "Ofr", "ofr", "ogon", "Ograve", "ograve", "ogt", "ohbar", "ohm", "oint", "olarr", "olcir", "olcross", "oline", "olt", "Omacr", "omacr", "Omega", "omega", "Omicron", "omicron", "omid", "ominus", "Oopf", "oopf", "opar", "OpenCurlyDoubleQuote", "OpenCurlyQuote", "operp", "oplus", "Or", "or", "orarr", "ord", "order", "orderof", "ordf", "ordm", "origof", "oror", "orslope", "orv", "oS", "Oscr", "oscr", "Oslash", "oslash", "osol", "Otilde", "otilde", "Otimes", "otimes", "otimesas", "Ouml", "ouml", "ovbar", "OverBar", "OverBrace", "OverBracket", "OverParenthesis", "par", "para", "parallel", "parsim", "parsl", "part", "PartialD", "Pcy", "pcy", "percnt", "period", "permil", "perp", "pertenk", "Pfr", "pfr", "Phi", "phi", "phiv", "phmmat", "phone", "Pi", "pi", "pitchfork", "piv", "planck", "planckh", "plankv", "plus", "plusacir", "plusb", "pluscir", "plusdo", "plusdu", "pluse", "PlusMinus", "plusmn", "plussim", "plustwo", "pm", "Poincareplane", "pointint", "Popf", "popf", "pound", "Pr", "pr", "prap", "prcue", "prE", "pre", "prec", "precapprox", "preccurlyeq", "Precedes", "PrecedesEqual", "PrecedesSlantEqual", "PrecedesTilde", "preceq", "precnapprox", "precneqq", "precnsim", "precsim", "Prime", "prime", "primes", "prnap", "prnE", "prnsim", "prod", "Product", "profalar", "profline", "profsurf", "prop", "Proportion", "Proportional", "propto", "prsim", "prurel", "Pscr", "pscr", "Psi", "psi", "puncsp", "Qfr", "qfr", "qint", "Qopf", "qopf", "qprime", "Qscr", "qscr", "quaternions", "quatint", "quest", "questeq", "QUOT", "quot", "rAarr", "race", "Racute", "racute", "radic", "raemptyv", "Rang", "rang", "rangd", "range", "rangle", "raquo", "Rarr", "rArr", "rarr", "rarrap", "rarrb", "rarrbfs", "rarrc", "rarrfs", "rarrhk", "rarrlp", "rarrpl", "rarrsim", "Rarrtl", "rarrtl", "rarrw", "rAtail", "ratail", "ratio", "rationals", "RBarr", "rBarr", "rbarr", "rbbrk", "rbrace", "rbrack", "rbrke", "rbrksld", "rbrkslu", "Rcaron", "rcaron", "Rcedil", "rcedil", "rceil", "rcub", "Rcy", "rcy", "rdca", "rdldhar", "rdquo", "rdquor", "rdsh", "Re", "real", "realine", "realpart", "reals", "rect", "REG", "reg", "ReverseElement", "ReverseEquilibrium", "ReverseUpEquilibrium", "rfisht", "rfloor", "Rfr", "rfr", "rHar", "rhard", "rharu", "rharul", "Rho", "rho", "rhov", "RightAngleBracket", "RightArrow", "Rightarrow", "rightarrow", "RightArrowBar", "RightArrowLeftArrow", "rightarrowtail", "RightCeiling", "RightDoubleBracket", "RightDownTeeVector", "RightDownVector", "RightDownVectorBar", "RightFloor", "rightharpoondown", "rightharpoonup", "rightleftarrows", "rightleftharpoons", "rightrightarrows", "rightsquigarrow", "RightTee", "RightTeeArrow", "RightTeeVector", "rightthreetimes", "RightTriangle", "RightTriangleBar", "RightTriangleEqual", "RightUpDownVector", "RightUpTeeVector", "RightUpVector", "RightUpVectorBar", "RightVector", "RightVectorBar", "ring", "risingdotseq", "rlarr", "rlhar", "rlm", "rmoust", "rmoustache", "rnmid", "roang", "roarr", "robrk", "ropar", "Ropf", "ropf", "roplus", "rotimes", "RoundImplies", "rpar", "rpargt", "rppolint", "rrarr", "Rrightarrow", "rsaquo", "Rscr", "rscr", "Rsh", "rsh", "rsqb", "rsquo", "rsquor", "rthree", "rtimes", "rtri", "rtrie", "rtrif", "rtriltri", "RuleDelayed", "ruluhar", "rx", "Sacute", "sacute", "sbquo", "Sc", "sc", "scap", "Scaron", "scaron", "sccue", "scE", "sce", "Scedil", "scedil", "Scirc", "scirc", "scnap", "scnE", "scnsim", "scpolint", "scsim", "Scy", "scy", "sdot", "sdotb", "sdote", "searhk", "seArr", "searr", "searrow", "sect", "semi", "seswar", "setminus", "setmn", "sext", "Sfr", "sfr", "sfrown", "sharp", "SHCHcy", "shchcy", "SHcy", "shcy", "ShortDownArrow", "ShortLeftArrow", "shortmid", "shortparallel", "ShortRightArrow", "ShortUpArrow", "shy", "Sigma", "sigma", "sigmaf", "sigmav", "sim", "simdot", "sime", "simeq", "simg", "simgE", "siml", "simlE", "simne", "simplus", "simrarr", "slarr", "SmallCircle", "smallsetminus", "smashp", "smeparsl", "smid", "smile", "smt", "smte", "smtes", "SOFTcy", "softcy", "sol", "solb", "solbar", "Sopf", "sopf", "spades", "spadesuit", "spar", "sqcap", "sqcaps", "sqcup", "sqcups", "Sqrt", "sqsub", "sqsube", "sqsubset", "sqsubseteq", "sqsup", "sqsupe", "sqsupset", "sqsupseteq", "squ", "Square", "square", "SquareIntersection", "SquareSubset", "SquareSubsetEqual", "SquareSuperset", "SquareSupersetEqual", "SquareUnion", "squarf", "squf", "srarr", "Sscr", "sscr", "ssetmn", "ssmile", "sstarf", "Star", "star", "starf", "straightepsilon", "straightphi", "strns", "Sub", "sub", "subdot", "subE", "sube", "subedot", "submult", "subnE", "subne", "subplus", "subrarr", "Subset", "subset", "subseteq", "subseteqq", "SubsetEqual", "subsetneq", "subsetneqq", "subsim", "subsub", "subsup", "succ", "succapprox", "succcurlyeq", "Succeeds", "SucceedsEqual", "SucceedsSlantEqual", "SucceedsTilde", "succeq", "succnapprox", "succneqq", "succnsim", "succsim", "SuchThat", "Sum", "sum", "sung", "Sup", "sup", "sup1", "sup2", "sup3", "supdot", "supdsub", "supE", "supe", "supedot", "Superset", "SupersetEqual", "suphsol", "suphsub", "suplarr", "supmult", "supnE", "supne", "supplus", "Supset", "supset", "supseteq", "supseteqq", "supsetneq", "supsetneqq", "supsim", "supsub", "supsup", "swarhk", "swArr", "swarr", "swarrow", "swnwar", "szlig", "Tab", "target", "Tau", "tau", "tbrk", "Tcaron", "tcaron", "Tcedil", "tcedil", "Tcy", "tcy", "tdot", "telrec", "Tfr", "tfr", "there4", "Therefore", "therefore", "Theta", "theta", "thetasym", "thetav", "thickapprox", "thicksim", "ThickSpace", "thinsp", "ThinSpace", "thkap", "thksim", "THORN", "thorn", "Tilde", "tilde", "TildeEqual", "TildeFullEqual", "TildeTilde", "times", "timesb", "timesbar", "timesd", "tint", "toea", "top", "topbot", "topcir", "Topf", "topf", "topfork", "tosa", "tprime", "TRADE", "trade", "triangle", "triangledown", "triangleleft", "trianglelefteq", "triangleq", "triangleright", "trianglerighteq", "tridot", "trie", "triminus", "TripleDot", "triplus", "trisb", "tritime", "trpezium", "Tscr", "tscr", "TScy", "tscy", "TSHcy", "tshcy", "Tstrok", "tstrok", "twixt", "twoheadleftarrow", "twoheadrightarrow", "Uacute", "uacute", "Uarr", "uArr", "uarr", "Uarrocir", "Ubrcy", "ubrcy", "Ubreve", "ubreve", "Ucirc", "ucirc", "Ucy", "ucy", "udarr", "Udblac", "udblac", "udhar", "ufisht", "Ufr", "ufr", "Ugrave", "ugrave", "uHar", "uharl", "uharr", "uhblk", "ulcorn", "ulcorner", "ulcrop", "ultri", "Umacr", "umacr", "uml", "UnderBar", "UnderBrace", "UnderBracket", "UnderParenthesis", "Union", "UnionPlus", "Uogon", "uogon", "Uopf", "uopf", "UpArrow", "Uparrow", "uparrow", "UpArrowBar", "UpArrowDownArrow", "UpDownArrow", "Updownarrow", "updownarrow", "UpEquilibrium", "upharpoonleft", "upharpoonright", "uplus", "UpperLeftArrow", "UpperRightArrow", "Upsi", "upsi", "upsih", "Upsilon", "upsilon", "UpTee", "UpTeeArrow", "upuparrows", "urcorn", "urcorner", "urcrop", "Uring", "uring", "urtri", "Uscr", "uscr", "utdot", "Utilde", "utilde", "utri", "utrif", "uuarr", "Uuml", "uuml", "uwangle", "vangrt", "varepsilon", "varkappa", "varnothing", "varphi", "varpi", "varpropto", "vArr", "varr", "varrho", "varsigma", "varsubsetneq", "varsubsetneqq", "varsupsetneq", "varsupsetneqq", "vartheta", "vartriangleleft", "vartriangleright", "Vbar", "vBar", "vBarv", "Vcy", "vcy", "VDash", "Vdash", "vDash", "vdash", "Vdashl", "Vee", "vee", "veebar", "veeeq", "vellip", "Verbar", "verbar", "Vert", "vert", "VerticalBar", "VerticalLine", "VerticalSeparator", "VerticalTilde", "VeryThinSpace", "Vfr", "vfr", "vltri", "vnsub", "vnsup", "Vopf", "vopf", "vprop", "vrtri", "Vscr", "vscr", "vsubnE", "vsubne", "vsupnE", "vsupne", "Vvdash", "vzigzag", "Wcirc", "wcirc", "wedbar", "Wedge", "wedge", "wedgeq", "weierp", "Wfr", "wfr", "Wopf", "wopf", "wp", "wr", "wreath", "Wscr", "wscr", "xcap", "xcirc", "xcup", "xdtri", "Xfr", "xfr", "xhArr", "xharr", "Xi", "xi", "xlArr", "xlarr", "xmap", "xnis", "xodot", "Xopf", "xopf", "xoplus", "xotime", "xrArr", "xrarr", "Xscr", "xscr", "xsqcup", "xuplus", "xutri", "xvee", "xwedge", "Yacute", "yacute", "YAcy", "yacy", "Ycirc", "ycirc", "Ycy", "ycy", "yen", "Yfr", "yfr", "YIcy", "yicy", "Yopf", "yopf", "Yscr", "yscr", "YUcy", "yucy", "Yuml", "yuml", "Zacute", "zacute", "Zcaron", "zcaron", "Zcy", "zcy", "Zdot", "zdot", "zeetrf", "ZeroWidthSpace", "Zeta", "zeta", "Zfr", "zfr", "ZHcy", "zhcy", "zigrarr", "Zopf", "zopf", "Zscr", "zscr", "zwj", "zwnj"]);
var allNamedEntitiesSetOnlyCaseInsensitive = new Set(["aacute", "abreve", "ac", "acd", "ace", "acirc", "acute", "acy", "aelig", "af", "afr", "agrave", "alefsym", "aleph", "alpha", "amacr", "amalg", "amp", "and", "andand", "andd", "andslope", "andv", "ang", "ange", "angle", "angmsd", "angmsdaa", "angmsdab", "angmsdac", "angmsdad", "angmsdae", "angmsdaf", "angmsdag", "angmsdah", "angrt", "angrtvb", "angrtvbd", "angsph", "angst", "angzarr", "aogon", "aopf", "ap", "apacir", "ape", "apid", "apos", "applyfunction", "approx", "approxeq", "aring", "ascr", "assign", "ast", "asymp", "asympeq", "atilde", "auml", "awconint", "awint", "backcong", "backepsilon", "backprime", "backsim", "backsimeq", "backslash", "barv", "barvee", "barwed", "barwedge", "bbrk", "bbrktbrk", "bcong", "bcy", "bdquo", "becaus", "because", "bemptyv", "bepsi", "bernou", "bernoullis", "beta", "beth", "between", "bfr", "bigcap", "bigcirc", "bigcup", "bigodot", "bigoplus", "bigotimes", "bigsqcup", "bigstar", "bigtriangledown", "bigtriangleup", "biguplus", "bigvee", "bigwedge", "bkarow", "blacklozenge", "blacksquare", "blacktriangle", "blacktriangledown", "blacktriangleleft", "blacktriangleright", "blank", "blk12", "blk14", "blk34", "block", "bne", "bnequiv", "bnot", "bopf", "bot", "bottom", "bowtie", "boxbox", "boxdl", "boxdr", "boxh", "boxhd", "boxhu", "boxminus", "boxplus", "boxtimes", "boxul", "boxur", "boxv", "boxvh", "boxvl", "boxvr", "bprime", "breve", "brvbar", "bscr", "bsemi", "bsim", "bsime", "bsol", "bsolb", "bsolhsub", "bull", "bullet", "bump", "bumpe", "bumpeq", "cacute", "cap", "capand", "capbrcup", "capcap", "capcup", "capdot", "capitaldifferentiald", "caps", "caret", "caron", "cayleys", "ccaps", "ccaron", "ccedil", "ccirc", "cconint", "ccups", "ccupssm", "cdot", "cedil", "cedilla", "cemptyv", "cent", "centerdot", "cfr", "chcy", "check", "checkmark", "chi", "cir", "circ", "circeq", "circlearrowleft", "circlearrowright", "circledast", "circledcirc", "circleddash", "circledot", "circledr", "circleds", "circleminus", "circleplus", "circletimes", "cire", "cirfnint", "cirmid", "cirscir", "clockwisecontourintegral", "closecurlydoublequote", "closecurlyquote", "clubs", "clubsuit", "colon", "colone", "coloneq", "comma", "commat", "comp", "compfn", "complement", "complexes", "cong", "congdot", "congruent", "conint", "contourintegral", "copf", "coprod", "coproduct", "copy", "copysr", "counterclockwisecontourintegral", "crarr", "cross", "cscr", "csub", "csube", "csup", "csupe", "ctdot", "cudarrl", "cudarrr", "cuepr", "cuesc", "cularr", "cularrp", "cup", "cupbrcap", "cupcap", "cupcup", "cupdot", "cupor", "cups", "curarr", "curarrm", "curlyeqprec", "curlyeqsucc", "curlyvee", "curlywedge", "curren", "curvearrowleft", "curvearrowright", "cuvee", "cuwed", "cwconint", "cwint", "cylcty", "dagger", "daleth", "darr", "dash", "dashv", "dbkarow", "dblac", "dcaron", "dcy", "dd", "ddagger", "ddarr", "ddotrahd", "ddotseq", "deg", "del", "delta", "demptyv", "dfisht", "dfr", "dhar", "dharl", "dharr", "diacriticalacute", "diacriticaldot", "diacriticaldoubleacute", "diacriticalgrave", "diacriticaltilde", "diam", "diamond", "diamondsuit", "diams", "die", "differentiald", "digamma", "disin", "div", "divide", "divideontimes", "divonx", "djcy", "dlcorn", "dlcrop", "dollar", "dopf", "dot", "dotdot", "doteq", "doteqdot", "dotequal", "dotminus", "dotplus", "dotsquare", "doublebarwedge", "doublecontourintegral", "doubledot", "doubledownarrow", "doubleleftarrow", "doubleleftrightarrow", "doublelefttee", "doublelongleftarrow", "doublelongleftrightarrow", "doublelongrightarrow", "doublerightarrow", "doublerighttee", "doubleuparrow", "doubleupdownarrow", "doubleverticalbar", "downarrow", "downarrowbar", "downarrowuparrow", "downbreve", "downdownarrows", "downharpoonleft", "downharpoonright", "downleftrightvector", "downleftteevector", "downleftvector", "downleftvectorbar", "downrightteevector", "downrightvector", "downrightvectorbar", "downtee", "downteearrow", "drbkarow", "drcorn", "drcrop", "dscr", "dscy", "dsol", "dstrok", "dtdot", "dtri", "dtrif", "duarr", "duhar", "dwangle", "dzcy", "dzigrarr", "eacute", "easter", "ecaron", "ecir", "ecirc", "ecolon", "ecy", "eddot", "edot", "ee", "efdot", "efr", "eg", "egrave", "egs", "egsdot", "el", "element", "elinters", "ell", "els", "elsdot", "emacr", "empty", "emptyset", "emptysmallsquare", "emptyv", "emptyverysmallsquare", "emsp", "emsp13", "emsp14", "eng", "ensp", "eogon", "eopf", "epar", "eparsl", "eplus", "epsi", "epsilon", "epsiv", "eqcirc", "eqcolon", "eqsim", "eqslantgtr", "eqslantless", "equal", "equals", "equaltilde", "equest", "equilibrium", "equiv", "equivdd", "eqvparsl", "erarr", "erdot", "escr", "esdot", "esim", "eta", "eth", "euml", "euro", "excl", "exist", "exists", "expectation", "exponentiale", "fallingdotseq", "fcy", "female", "ffilig", "fflig", "ffllig", "ffr", "filig", "filledsmallsquare", "filledverysmallsquare", "fjlig", "flat", "fllig", "fltns", "fnof", "fopf", "forall", "fork", "forkv", "fouriertrf", "fpartint", "frac12", "frac13", "frac14", "frac15", "frac16", "frac18", "frac23", "frac25", "frac34", "frac35", "frac38", "frac45", "frac56", "frac58", "frac78", "frasl", "frown", "fscr", "gacute", "gamma", "gammad", "gap", "gbreve", "gcedil", "gcirc", "gcy", "gdot", "ge", "gel", "geq", "geqq", "geqslant", "ges", "gescc", "gesdot", "gesdoto", "gesdotol", "gesl", "gesles", "gfr", "gg", "ggg", "gimel", "gjcy", "gl", "gla", "gle", "glj", "gnap", "gnapprox", "gne", "gneq", "gneqq", "gnsim", "gopf", "grave", "greaterequal", "greaterequalless", "greaterfullequal", "greatergreater", "greaterless", "greaterslantequal", "greatertilde", "gscr", "gsim", "gsime", "gsiml", "gt", "gtcc", "gtcir", "gtdot", "gtlpar", "gtquest", "gtrapprox", "gtrarr", "gtrdot", "gtreqless", "gtreqqless", "gtrless", "gtrsim", "gvertneqq", "gvne", "hacek", "hairsp", "half", "hamilt", "hardcy", "harr", "harrcir", "harrw", "hat", "hbar", "hcirc", "hearts", "heartsuit", "hellip", "hercon", "hfr", "hilbertspace", "hksearow", "hkswarow", "hoarr", "homtht", "hookleftarrow", "hookrightarrow", "hopf", "horbar", "horizontalline", "hscr", "hslash", "hstrok", "humpdownhump", "humpequal", "hybull", "hyphen", "iacute", "ic", "icirc", "icy", "idot", "iecy", "iexcl", "iff", "ifr", "igrave", "ii", "iiiint", "iiint", "iinfin", "iiota", "ijlig", "im", "imacr", "image", "imaginaryi", "imagline", "imagpart", "imath", "imof", "imped", "implies", "in", "incare", "infin", "infintie", "inodot", "int", "intcal", "integers", "integral", "intercal", "intersection", "intlarhk", "intprod", "invisiblecomma", "invisibletimes", "iocy", "iogon", "iopf", "iota", "iprod", "iquest", "iscr", "isin", "isindot", "isine", "isins", "isinsv", "isinv", "it", "itilde", "iukcy", "iuml", "jcirc", "jcy", "jfr", "jmath", "jopf", "jscr", "jsercy", "jukcy", "kappa", "kappav", "kcedil", "kcy", "kfr", "kgreen", "khcy", "kjcy", "kopf", "kscr", "laarr", "lacute", "laemptyv", "lagran", "lambda", "lang", "langd", "langle", "lap", "laplacetrf", "laquo", "larr", "larrb", "larrbfs", "larrfs", "larrhk", "larrlp", "larrpl", "larrsim", "larrtl", "lat", "latail", "late", "lates", "lbarr", "lbbrk", "lbrace", "lbrack", "lbrke", "lbrksld", "lbrkslu", "lcaron", "lcedil", "lceil", "lcub", "lcy", "ldca", "ldquo", "ldquor", "ldrdhar", "ldrushar", "ldsh", "le", "leftanglebracket", "leftarrow", "leftarrowbar", "leftarrowrightarrow", "leftarrowtail", "leftceiling", "leftdoublebracket", "leftdownteevector", "leftdownvector", "leftdownvectorbar", "leftfloor", "leftharpoondown", "leftharpoonup", "leftleftarrows", "leftrightarrow", "leftrightarrows", "leftrightharpoons", "leftrightsquigarrow", "leftrightvector", "lefttee", "leftteearrow", "leftteevector", "leftthreetimes", "lefttriangle", "lefttrianglebar", "lefttriangleequal", "leftupdownvector", "leftupteevector", "leftupvector", "leftupvectorbar", "leftvector", "leftvectorbar", "leg", "leq", "leqq", "leqslant", "les", "lescc", "lesdot", "lesdoto", "lesdotor", "lesg", "lesges", "lessapprox", "lessdot", "lesseqgtr", "lesseqqgtr", "lessequalgreater", "lessfullequal", "lessgreater", "lessgtr", "lessless", "lesssim", "lessslantequal", "lesstilde", "lfisht", "lfloor", "lfr", "lg", "lge", "lhar", "lhard", "lharu", "lharul", "lhblk", "ljcy", "ll", "llarr", "llcorner", "lleftarrow", "llhard", "lltri", "lmidot", "lmoust", "lmoustache", "lnap", "lnapprox", "lne", "lneq", "lneqq", "lnsim", "loang", "loarr", "lobrk", "longleftarrow", "longleftrightarrow", "longmapsto", "longrightarrow", "looparrowleft", "looparrowright", "lopar", "lopf", "loplus", "lotimes", "lowast", "lowbar", "lowerleftarrow", "lowerrightarrow", "loz", "lozenge", "lozf", "lpar", "lparlt", "lrarr", "lrcorner", "lrhar", "lrhard", "lrm", "lrtri", "lsaquo", "lscr", "lsh", "lsim", "lsime", "lsimg", "lsqb", "lsquo", "lsquor", "lstrok", "lt", "ltcc", "ltcir", "ltdot", "lthree", "ltimes", "ltlarr", "ltquest", "ltri", "ltrie", "ltrif", "ltrpar", "lurdshar", "luruhar", "lvertneqq", "lvne", "macr", "male", "malt", "maltese", "map", "mapsto", "mapstodown", "mapstoleft", "mapstoup", "marker", "mcomma", "mcy", "mdash", "mddot", "measuredangle", "mediumspace", "mellintrf", "mfr", "mho", "micro", "mid", "midast", "midcir", "middot", "minus", "minusb", "minusd", "minusdu", "minusplus", "mlcp", "mldr", "mnplus", "models", "mopf", "mp", "mscr", "mstpos", "mu", "multimap", "mumap", "nabla", "nacute", "nang", "nap", "nape", "napid", "napos", "napprox", "natur", "natural", "naturals", "nbsp", "nbump", "nbumpe", "ncap", "ncaron", "ncedil", "ncong", "ncongdot", "ncup", "ncy", "ndash", "ne", "nearhk", "nearr", "nearrow", "nedot", "negativemediumspace", "negativethickspace", "negativethinspace", "negativeverythinspace", "nequiv", "nesear", "nesim", "nestedgreatergreater", "nestedlessless", "newline", "nexist", "nexists", "nfr", "nge", "ngeq", "ngeqq", "ngeqslant", "nges", "ngg", "ngsim", "ngt", "ngtr", "ngtv", "nharr", "nhpar", "ni", "nis", "nisd", "niv", "njcy", "nlarr", "nldr", "nle", "nleftarrow", "nleftrightarrow", "nleq", "nleqq", "nleqslant", "nles", "nless", "nll", "nlsim", "nlt", "nltri", "nltrie", "nltv", "nmid", "nobreak", "nonbreakingspace", "nopf", "not", "notcongruent", "notcupcap", "notdoubleverticalbar", "notelement", "notequal", "notequaltilde", "notexists", "notgreater", "notgreaterequal", "notgreaterfullequal", "notgreatergreater", "notgreaterless", "notgreaterslantequal", "notgreatertilde", "nothumpdownhump", "nothumpequal", "notin", "notindot", "notine", "notinva", "notinvb", "notinvc", "notlefttriangle", "notlefttrianglebar", "notlefttriangleequal", "notless", "notlessequal", "notlessgreater", "notlessless", "notlessslantequal", "notlesstilde", "notnestedgreatergreater", "notnestedlessless", "notni", "notniva", "notnivb", "notnivc", "notprecedes", "notprecedesequal", "notprecedesslantequal", "notreverseelement", "notrighttriangle", "notrighttrianglebar", "notrighttriangleequal", "notsquaresubset", "notsquaresubsetequal", "notsquaresuperset", "notsquaresupersetequal", "notsubset", "notsubsetequal", "notsucceeds", "notsucceedsequal", "notsucceedsslantequal", "notsucceedstilde", "notsuperset", "notsupersetequal", "nottilde", "nottildeequal", "nottildefullequal", "nottildetilde", "notverticalbar", "npar", "nparallel", "nparsl", "npart", "npolint", "npr", "nprcue", "npre", "nprec", "npreceq", "nrarr", "nrarrc", "nrarrw", "nrightarrow", "nrtri", "nrtrie", "nsc", "nsccue", "nsce", "nscr", "nshortmid", "nshortparallel", "nsim", "nsime", "nsimeq", "nsmid", "nspar", "nsqsube", "nsqsupe", "nsub", "nsube", "nsubset", "nsubseteq", "nsubseteqq", "nsucc", "nsucceq", "nsup", "nsupe", "nsupset", "nsupseteq", "nsupseteqq", "ntgl", "ntilde", "ntlg", "ntriangleleft", "ntrianglelefteq", "ntriangleright", "ntrianglerighteq", "nu", "num", "numero", "numsp", "nvap", "nvdash", "nvge", "nvgt", "nvharr", "nvinfin", "nvlarr", "nvle", "nvlt", "nvltrie", "nvrarr", "nvrtrie", "nvsim", "nwarhk", "nwarr", "nwarrow", "nwnear", "oacute", "oast", "ocir", "ocirc", "ocy", "odash", "odblac", "odiv", "odot", "odsold", "oelig", "ofcir", "ofr", "ogon", "ograve", "ogt", "ohbar", "ohm", "oint", "olarr", "olcir", "olcross", "oline", "olt", "omacr", "omega", "omicron", "omid", "ominus", "oopf", "opar", "opencurlydoublequote", "opencurlyquote", "operp", "oplus", "or", "orarr", "ord", "order", "orderof", "ordf", "ordm", "origof", "oror", "orslope", "orv", "os", "oscr", "oslash", "osol", "otilde", "otimes", "otimesas", "ouml", "ovbar", "overbar", "overbrace", "overbracket", "overparenthesis", "par", "para", "parallel", "parsim", "parsl", "part", "partiald", "pcy", "percnt", "period", "permil", "perp", "pertenk", "pfr", "phi", "phiv", "phmmat", "phone", "pi", "pitchfork", "piv", "planck", "planckh", "plankv", "plus", "plusacir", "plusb", "pluscir", "plusdo", "plusdu", "pluse", "plusminus", "plusmn", "plussim", "plustwo", "pm", "poincareplane", "pointint", "popf", "pound", "pr", "prap", "prcue", "pre", "prec", "precapprox", "preccurlyeq", "precedes", "precedesequal", "precedesslantequal", "precedestilde", "preceq", "precnapprox", "precneqq", "precnsim", "precsim", "prime", "primes", "prnap", "prne", "prnsim", "prod", "product", "profalar", "profline", "profsurf", "prop", "proportion", "proportional", "propto", "prsim", "prurel", "pscr", "psi", "puncsp", "qfr", "qint", "qopf", "qprime", "qscr", "quaternions", "quatint", "quest", "questeq", "quot", "raarr", "race", "racute", "radic", "raemptyv", "rang", "rangd", "range", "rangle", "raquo", "rarr", "rarrap", "rarrb", "rarrbfs", "rarrc", "rarrfs", "rarrhk", "rarrlp", "rarrpl", "rarrsim", "rarrtl", "rarrw", "ratail", "ratio", "rationals", "rbarr", "rbbrk", "rbrace", "rbrack", "rbrke", "rbrksld", "rbrkslu", "rcaron", "rcedil", "rceil", "rcub", "rcy", "rdca", "rdldhar", "rdquo", "rdquor", "rdsh", "re", "real", "realine", "realpart", "reals", "rect", "reg", "reverseelement", "reverseequilibrium", "reverseupequilibrium", "rfisht", "rfloor", "rfr", "rhar", "rhard", "rharu", "rharul", "rho", "rhov", "rightanglebracket", "rightarrow", "rightarrowbar", "rightarrowleftarrow", "rightarrowtail", "rightceiling", "rightdoublebracket", "rightdownteevector", "rightdownvector", "rightdownvectorbar", "rightfloor", "rightharpoondown", "rightharpoonup", "rightleftarrows", "rightleftharpoons", "rightrightarrows", "rightsquigarrow", "righttee", "rightteearrow", "rightteevector", "rightthreetimes", "righttriangle", "righttrianglebar", "righttriangleequal", "rightupdownvector", "rightupteevector", "rightupvector", "rightupvectorbar", "rightvector", "rightvectorbar", "ring", "risingdotseq", "rlarr", "rlhar", "rlm", "rmoust", "rmoustache", "rnmid", "roang", "roarr", "robrk", "ropar", "ropf", "roplus", "rotimes", "roundimplies", "rpar", "rpargt", "rppolint", "rrarr", "rrightarrow", "rsaquo", "rscr", "rsh", "rsqb", "rsquo", "rsquor", "rthree", "rtimes", "rtri", "rtrie", "rtrif", "rtriltri", "ruledelayed", "ruluhar", "rx", "sacute", "sbquo", "sc", "scap", "scaron", "sccue", "sce", "scedil", "scirc", "scnap", "scne", "scnsim", "scpolint", "scsim", "scy", "sdot", "sdotb", "sdote", "searhk", "searr", "searrow", "sect", "semi", "seswar", "setminus", "setmn", "sext", "sfr", "sfrown", "sharp", "shchcy", "shcy", "shortdownarrow", "shortleftarrow", "shortmid", "shortparallel", "shortrightarrow", "shortuparrow", "shy", "sigma", "sigmaf", "sigmav", "sim", "simdot", "sime", "simeq", "simg", "simge", "siml", "simle", "simne", "simplus", "simrarr", "slarr", "smallcircle", "smallsetminus", "smashp", "smeparsl", "smid", "smile", "smt", "smte", "smtes", "softcy", "sol", "solb", "solbar", "sopf", "spades", "spadesuit", "spar", "sqcap", "sqcaps", "sqcup", "sqcups", "sqrt", "sqsub", "sqsube", "sqsubset", "sqsubseteq", "sqsup", "sqsupe", "sqsupset", "sqsupseteq", "squ", "square", "squareintersection", "squaresubset", "squaresubsetequal", "squaresuperset", "squaresupersetequal", "squareunion", "squarf", "squf", "srarr", "sscr", "ssetmn", "ssmile", "sstarf", "star", "starf", "straightepsilon", "straightphi", "strns", "sub", "subdot", "sube", "subedot", "submult", "subne", "subplus", "subrarr", "subset", "subseteq", "subseteqq", "subsetequal", "subsetneq", "subsetneqq", "subsim", "subsub", "subsup", "succ", "succapprox", "succcurlyeq", "succeeds", "succeedsequal", "succeedsslantequal", "succeedstilde", "succeq", "succnapprox", "succneqq", "succnsim", "succsim", "suchthat", "sum", "sung", "sup", "sup1", "sup2", "sup3", "supdot", "supdsub", "supe", "supedot", "superset", "supersetequal", "suphsol", "suphsub", "suplarr", "supmult", "supne", "supplus", "supset", "supseteq", "supseteqq", "supsetneq", "supsetneqq", "supsim", "supsub", "supsup", "swarhk", "swarr", "swarrow", "swnwar", "szlig", "tab", "target", "tau", "tbrk", "tcaron", "tcedil", "tcy", "tdot", "telrec", "tfr", "there4", "therefore", "theta", "thetasym", "thetav", "thickapprox", "thicksim", "thickspace", "thinsp", "thinspace", "thkap", "thksim", "thorn", "tilde", "tildeequal", "tildefullequal", "tildetilde", "times", "timesb", "timesbar", "timesd", "tint", "toea", "top", "topbot", "topcir", "topf", "topfork", "tosa", "tprime", "trade", "triangle", "triangledown", "triangleleft", "trianglelefteq", "triangleq", "triangleright", "trianglerighteq", "tridot", "trie", "triminus", "tripledot", "triplus", "trisb", "tritime", "trpezium", "tscr", "tscy", "tshcy", "tstrok", "twixt", "twoheadleftarrow", "twoheadrightarrow", "uacute", "uarr", "uarrocir", "ubrcy", "ubreve", "ucirc", "ucy", "udarr", "udblac", "udhar", "ufisht", "ufr", "ugrave", "uhar", "uharl", "uharr", "uhblk", "ulcorn", "ulcorner", "ulcrop", "ultri", "umacr", "uml", "underbar", "underbrace", "underbracket", "underparenthesis", "union", "unionplus", "uogon", "uopf", "uparrow", "uparrowbar", "uparrowdownarrow", "updownarrow", "upequilibrium", "upharpoonleft", "upharpoonright", "uplus", "upperleftarrow", "upperrightarrow", "upsi", "upsih", "upsilon", "uptee", "upteearrow", "upuparrows", "urcorn", "urcorner", "urcrop", "uring", "urtri", "uscr", "utdot", "utilde", "utri", "utrif", "uuarr", "uuml", "uwangle", "vangrt", "varepsilon", "varkappa", "varnothing", "varphi", "varpi", "varpropto", "varr", "varrho", "varsigma", "varsubsetneq", "varsubsetneqq", "varsupsetneq", "varsupsetneqq", "vartheta", "vartriangleleft", "vartriangleright", "vbar", "vbarv", "vcy", "vdash", "vdashl", "vee", "veebar", "veeeq", "vellip", "verbar", "vert", "verticalbar", "verticalline", "verticalseparator", "verticaltilde", "verythinspace", "vfr", "vltri", "vnsub", "vnsup", "vopf", "vprop", "vrtri", "vscr", "vsubne", "vsupne", "vvdash", "vzigzag", "wcirc", "wedbar", "wedge", "wedgeq", "weierp", "wfr", "wopf", "wp", "wr", "wreath", "wscr", "xcap", "xcirc", "xcup", "xdtri", "xfr", "xharr", "xi", "xlarr", "xmap", "xnis", "xodot", "xopf", "xoplus", "xotime", "xrarr", "xscr", "xsqcup", "xuplus", "xutri", "xvee", "xwedge", "yacute", "yacy", "ycirc", "ycy", "yen", "yfr", "yicy", "yopf", "yscr", "yucy", "yuml", "zacute", "zcaron", "zcy", "zdot", "zeetrf", "zerowidthspace", "zeta", "zfr", "zhcy", "zigrarr", "zopf", "zscr", "zwj", "zwnj"]);

function decode(ent) {
  if (typeof ent !== "string" || !ent.length || !ent.startsWith("&") || !ent.endsWith(";")) {
    throw new Error("all-named-html-entities/decode(): [THROW_ID_01] Input must be an HTML entity with leading ampersand and trailing semicolon, but \"" + ent + "\" was given");
  }

  var val = ent.slice(1, ent.length - 1);
  return allNamedEntities[val] ? allNamedEntities[val] : null;
}
var maxLength = 31;

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** `Object#toString` result references. */
var objectTag = '[object Object]';
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */

function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;

  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }

  return result;
}
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */


function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}
/** Used for built-in method references. */


var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString.call(Object);
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var objectToString = objectProto.toString;
/** Built-in value references. */

var getPrototype = overArg(Object.getPrototypeOf, Object);
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */

function isObjectLike(value) {
  return !!value && typeof value == 'object';
}
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */


function isPlainObject(value) {
  if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
    return false;
  }

  var proto = getPrototype(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

var lodash_isplainobject = isPlainObject;

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash_clonedeep = createCommonjsModule(function (module, exports) {
  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;
  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  /** Used as references for various `Number` constants. */

  var MAX_SAFE_INTEGER = 9007199254740991;
  /** `Object#toString` result references. */

  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */

  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  /** Used to match `RegExp` flags from their coerced string values. */

  var reFlags = /\w*$/;
  /** Used to detect host constructors (Safari). */

  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  /** Used to detect unsigned integer values. */

  var reIsUint = /^(?:0|[1-9]\d*)$/;
  /** Used to identify `toStringTag` values supported by `_.clone`. */

  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  /** Detect free variable `global` from Node.js. */

  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  /** Detect free variable `self`. */

  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root = freeGlobal || freeSelf || Function('return this')();
  /** Detect free variable `exports`. */

  var freeExports = exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports = freeModule && freeModule.exports === freeExports;
  /**
   * Adds the key-value `pair` to `map`.
   *
   * @private
   * @param {Object} map The map to modify.
   * @param {Array} pair The key-value pair to add.
   * @returns {Object} Returns `map`.
   */

  function addMapEntry(map, pair) {
    // Don't return `map.set` because it's not chainable in IE 11.
    map.set(pair[0], pair[1]);
    return map;
  }
  /**
   * Adds `value` to `set`.
   *
   * @private
   * @param {Object} set The set to modify.
   * @param {*} value The value to add.
   * @returns {Object} Returns `set`.
   */


  function addSetEntry(set, value) {
    // Don't return `set.add` because it's not chainable in IE 11.
    set.add(value);
    return set;
  }
  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */


  function arrayEach(array, iteratee) {
    var index = -1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }

    return array;
  }
  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */


  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }

    return array;
  }
  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */


  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array ? array.length : 0;

    if (initAccum && length) {
      accumulator = array[++index];
    }

    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }

    return accumulator;
  }
  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */


  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }
  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */


  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }
  /**
   * Checks if `value` is a host object in IE < 9.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
   */


  function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;

    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }

    return result;
  }
  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */


  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);
    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */


  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }
  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */


  function setToArray(set) {
    var index = -1,
        result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }
  /** Used for built-in method references. */


  var arrayProto = Array.prototype,
      funcProto = Function.prototype,
      objectProto = Object.prototype;
  /** Used to detect overreaching core-js shims. */

  var coreJsData = root['__core-js_shared__'];
  /** Used to detect methods masquerading as native. */

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();
  /** Used to resolve the decompiled source of functions. */


  var funcToString = funcProto.toString;
  /** Used to check objects for own properties. */

  var hasOwnProperty = objectProto.hasOwnProperty;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var objectToString = objectProto.toString;
  /** Used to detect if a method is native. */

  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  /** Built-in value references. */

  var Buffer = moduleExports ? root.Buffer : undefined,
      Symbol = root.Symbol,
      Uint8Array = root.Uint8Array,
      getPrototype = overArg(Object.getPrototypeOf, Object),
      objectCreate = Object.create,
      propertyIsEnumerable = objectProto.propertyIsEnumerable,
      splice = arrayProto.splice;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeGetSymbols = Object.getOwnPropertySymbols,
      nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
      nativeKeys = overArg(Object.keys, Object);
  /* Built-in method references that are verified to be native. */

  var DataView = getNative(root, 'DataView'),
      Map = getNative(root, 'Map'),
      Promise = getNative(root, 'Promise'),
      Set = getNative(root, 'Set'),
      WeakMap = getNative(root, 'WeakMap'),
      nativeCreate = getNative(Object, 'create');
  /** Used to detect maps, sets, and weakmaps. */

  var dataViewCtorString = toSource(DataView),
      mapCtorString = toSource(Map),
      promiseCtorString = toSource(Promise),
      setCtorString = toSource(Set),
      weakMapCtorString = toSource(WeakMap);
  /** Used to convert symbols to primitives and strings. */

  var symbolProto = Symbol ? Symbol.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Hash(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */


  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function hashGet(key) {
    var data = this.__data__;

    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }

    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }
  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }
  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */


  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  } // Add methods to `Hash`.


  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function ListCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */


  function listCacheClear() {
    this.__data__ = [];
  }
  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    return true;
  }
  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }
  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */


  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  } // Add methods to `ListCache`.


  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function MapCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */


  function mapCacheClear() {
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map || ListCache)(),
      'string': new Hash()
    };
  }
  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
  }
  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */


  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  } // Add methods to `MapCache`.


  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Stack(entries) {
    this.__data__ = new ListCache(entries);
  }
  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */


  function stackClear() {
    this.__data__ = new ListCache();
  }
  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function stackDelete(key) {
    return this.__data__['delete'](key);
  }
  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function stackGet(key) {
    return this.__data__.get(key);
  }
  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function stackHas(key) {
    return this.__data__.has(key);
  }
  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */


  function stackSet(key, value) {
    var cache = this.__data__;

    if (cache instanceof ListCache) {
      var pairs = cache.__data__;

      if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        return this;
      }

      cache = this.__data__ = new MapCache(pairs);
    }

    cache.set(key, value);
    return this;
  } // Add methods to `Stack`.


  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */

  function arrayLikeKeys(value, inherited) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    // Safari 9 makes `arguments.length` enumerable in strict mode.
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length,
        skipIndexes = !!length;

    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
        result.push(key);
      }
    }

    return result;
  }
  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */


  function assignValue(object, key, value) {
    var objValue = object[key];

    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
      object[key] = value;
    }
  }
  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */


  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }
  /**
   * The base implementation of `_.assign` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */


  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }
  /**
   * The base implementation of `_.clone` and `_.cloneDeep` which tracks
   * traversed objects.
   *
   * @private
   * @param {*} value The value to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @param {boolean} [isFull] Specify a clone including symbols.
   * @param {Function} [customizer] The function to customize cloning.
   * @param {string} [key] The key of `value`.
   * @param {Object} [object] The parent object of `value`.
   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
   * @returns {*} Returns the cloned value.
   */


  function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
    var result;

    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }

    if (result !== undefined) {
      return result;
    }

    if (!isObject(value)) {
      return value;
    }

    var isArr = isArray(value);

    if (isArr) {
      result = initCloneArray(value);

      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value),
          isFunc = tag == funcTag || tag == genTag;

      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }

      if (tag == objectTag || tag == argsTag || isFunc && !object) {
        if (isHostObject(value)) {
          return object ? value : {};
        }

        result = initCloneObject(isFunc ? {} : value);

        if (!isDeep) {
          return copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }

        result = initCloneByTag(value, tag, baseClone, isDeep);
      }
    } // Check for circular references and return its corresponding clone.


    stack || (stack = new Stack());
    var stacked = stack.get(value);

    if (stacked) {
      return stacked;
    }

    stack.set(value, result);

    if (!isArr) {
      var props = isFull ? getAllKeys(value) : keys(value);
    }

    arrayEach(props || value, function (subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      } // Recursively populate clone (susceptible to call stack limits).


      assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
    });
    return result;
  }
  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} prototype The object to inherit from.
   * @returns {Object} Returns the new object.
   */


  function baseCreate(proto) {
    return isObject(proto) ? objectCreate(proto) : {};
  }
  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */


  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  /**
   * The base implementation of `getTag`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */


  function baseGetTag(value) {
    return objectToString.call(value);
  }
  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */


  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }

    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */


  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }

    var result = [];

    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }

    return result;
  }
  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */


  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }

    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
  }
  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */


  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }
  /**
   * Creates a clone of `dataView`.
   *
   * @private
   * @param {Object} dataView The data view to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned data view.
   */


  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  /**
   * Creates a clone of `map`.
   *
   * @private
   * @param {Object} map The map to clone.
   * @param {Function} cloneFunc The function to clone values.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned map.
   */


  function cloneMap(map, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
    return arrayReduce(array, addMapEntry, new map.constructor());
  }
  /**
   * Creates a clone of `regexp`.
   *
   * @private
   * @param {Object} regexp The regexp to clone.
   * @returns {Object} Returns the cloned regexp.
   */


  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  /**
   * Creates a clone of `set`.
   *
   * @private
   * @param {Object} set The set to clone.
   * @param {Function} cloneFunc The function to clone values.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned set.
   */


  function cloneSet(set, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
    return arrayReduce(array, addSetEntry, new set.constructor());
  }
  /**
   * Creates a clone of the `symbol` object.
   *
   * @private
   * @param {Object} symbol The symbol object to clone.
   * @returns {Object} Returns the cloned symbol object.
   */


  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */


  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */


  function copyArray(source, array) {
    var index = -1,
        length = source.length;
    array || (array = Array(length));

    while (++index < length) {
      array[index] = source[index];
    }

    return array;
  }
  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */


  function copyObject(source, props, object, customizer) {
    object || (object = {});
    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
      assignValue(object, key, newValue === undefined ? source[key] : newValue);
    }

    return object;
  }
  /**
   * Copies own symbol properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */


  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }
  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */


  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */


  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }
  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */


  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }
  /**
   * Creates an array of the own enumerable symbol properties of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */


  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */

  var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11,
  // for data views in Edge < 14, and promises in Node.js.

  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function getTag(value) {
      var result = objectToString.call(value),
          Ctor = result == objectTag ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : undefined;

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;

          case mapCtorString:
            return mapTag;

          case promiseCtorString:
            return promiseTag;

          case setCtorString:
            return setTag;

          case weakMapCtorString:
            return weakMapTag;
        }
      }

      return result;
    };
  }
  /**
   * Initializes an array clone.
   *
   * @private
   * @param {Array} array The array to clone.
   * @returns {Array} Returns the initialized clone.
   */


  function initCloneArray(array) {
    var length = array.length,
        result = array.constructor(length); // Add properties assigned by `RegExp#exec`.

    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }

    return result;
  }
  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */


  function initCloneObject(object) {
    return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  /**
   * Initializes an object clone based on its `toStringTag`.
   *
   * **Note:** This function only supports cloning values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {string} tag The `toStringTag` of the object to clone.
   * @param {Function} cloneFunc The function to clone values.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the initialized clone.
   */


  function initCloneByTag(object, tag, cloneFunc, isDeep) {
    var Ctor = object.constructor;

    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);

      case boolTag:
      case dateTag:
        return new Ctor(+object);

      case dataViewTag:
        return cloneDataView(object, isDeep);

      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);

      case mapTag:
        return cloneMap(object, isDeep, cloneFunc);

      case numberTag:
      case stringTag:
        return new Ctor(object);

      case regexpTag:
        return cloneRegExp(object);

      case setTag:
        return cloneSet(object, isDeep, cloneFunc);

      case symbolTag:
        return cloneSymbol(object);
    }
  }
  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */


  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }
  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */


  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }
  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */


  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */


  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
  }
  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to process.
   * @returns {string} Returns the source code.
   */


  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }
  /**
   * This method is like `_.clone` except that it recursively clones `value`.
   *
   * @static
   * @memberOf _
   * @since 1.0.0
   * @category Lang
   * @param {*} value The value to recursively clone.
   * @returns {*} Returns the deep cloned value.
   * @see _.clone
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var deep = _.cloneDeep(objects);
   * console.log(deep[0] === objects[0]);
   * // => false
   */


  function cloneDeep(value) {
    return baseClone(value, true, true);
  }
  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */


  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */


  function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
  }
  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */


  var isArray = Array.isArray;
  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */

  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */


  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */


  var isBuffer = nativeIsBuffer || stubFalse;
  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */

  function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
  }
  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */


  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */


  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }
  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */


  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */


  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */


  function stubArray() {
    return [];
  }
  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */


  function stubFalse() {
    return false;
  }

  module.exports = cloneDeep;
});

var RAWNBSP = "\xA0";

function x(something) {
  var res = {
    value: something,
    hungry: false,
    optional: false
  };

  if ((res.value.endsWith("?*") || res.value.endsWith("*?")) && res.value.length > 2) {
    res.value = res.value.slice(0, res.value.length - 2);
    res.optional = true;
    res.hungry = true;
  } else if (res.value.endsWith("?") && res.value.length > 1) {
    res.value = res.value.slice(0, ~-res.value.length);
    res.optional = true;
  } else if (res.value.endsWith("*") && res.value.length > 1) {
    res.value = res.value.slice(0, ~-res.value.length);
    res.hungry = true;
  }

  return res;
}

function isStr$3(something) {
  return typeof something === "string";
}

function rightMain(_ref) {
  var str = _ref.str,
      _ref$idx = _ref.idx,
      idx = _ref$idx === void 0 ? 0 : _ref$idx,
      _ref$stopAtNewlines = _ref.stopAtNewlines,
      stopAtNewlines = _ref$stopAtNewlines === void 0 ? false : _ref$stopAtNewlines,
      _ref$stopAtRawNbsp = _ref.stopAtRawNbsp,
      stopAtRawNbsp = _ref$stopAtRawNbsp === void 0 ? false : _ref$stopAtRawNbsp;

  if (typeof str !== "string" || !str.length) {
    return null;
  }

  if (!idx || typeof idx !== "number") {
    idx = 0;
  }

  if (!str[idx + 1]) {
    return null;
  }

  if (str[idx + 1] && (str[idx + 1].trim() || stopAtNewlines && "\n\r".includes(str[idx + 1]) || stopAtRawNbsp && str[idx + 1] === RAWNBSP)) {
    return idx + 1;
  }

  if (str[idx + 2] && (str[idx + 2].trim() || stopAtNewlines && "\n\r".includes(str[idx + 2]) || stopAtRawNbsp && str[idx + 2] === RAWNBSP)) {
    return idx + 2;
  }

  for (var i = idx + 1, len = str.length; i < len; i++) {
    if (str[i].trim() || stopAtNewlines && "\n\r".includes(str[i]) || stopAtRawNbsp && str[i] === RAWNBSP) {
      return i;
    }
  }

  return null;
}

function right(str, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return rightMain({
    str: str,
    idx: idx,
    stopAtNewlines: false,
    stopAtRawNbsp: false
  });
}

function leftMain(_ref2) {
  var str = _ref2.str,
      idx = _ref2.idx,
      stopAtNewlines = _ref2.stopAtNewlines,
      stopAtRawNbsp = _ref2.stopAtRawNbsp;

  if (typeof str !== "string" || !str.length) {
    return null;
  }

  if (!idx || typeof idx !== "number") {
    idx = 0;
  }

  if (idx < 1) {
    return null;
  }

  if (str[~-idx] && (str[~-idx].trim() || stopAtNewlines && "\n\r".includes(str[~-idx]) || stopAtRawNbsp && str[~-idx] === RAWNBSP)) {
    return ~-idx;
  }

  if (str[idx - 2] && (str[idx - 2].trim() || stopAtNewlines && "\n\r".includes(str[idx - 2]) || stopAtRawNbsp && str[idx - 2] === RAWNBSP)) {
    return idx - 2;
  }

  for (var i = idx; i--;) {
    if (str[i] && (str[i].trim() || stopAtNewlines && "\n\r".includes(str[i]) || stopAtRawNbsp && str[i] === RAWNBSP)) {
      return i;
    }
  }

  return null;
}

function left(str, idx) {
  if (idx === void 0) {
    idx = 0;
  }

  return leftMain({
    str: str,
    idx: idx,
    stopAtNewlines: false,
    stopAtRawNbsp: false
  });
}

function leftStopAtNewLines(str, idx) {
  return leftMain({
    str: str,
    idx: idx,
    stopAtNewlines: true,
    stopAtRawNbsp: false
  });
}

function seq(direction, str, idx, opts, args) {
  if (typeof str !== "string" || !str.length) {
    return null;
  }

  if (typeof idx !== "number") {
    idx = 0;
  }

  if (direction === "right" && !str[idx + 1] || direction === "left" && !str[~-idx]) {
    return null;
  }

  var lastFinding = idx;
  var gaps = [];
  var leftmostChar;
  var rightmostChar;
  var satiated;
  var i = 0;

  while (i < args.length) {
    if (!isStr$3(args[i]) || !args[i].length) {
      i += 1;
      continue;
    }

    var _x = x(args[i]),
        value = _x.value,
        optional = _x.optional,
        hungry = _x.hungry;

    var whattsOnTheSide = direction === "right" ? right(str, lastFinding) : left(str, lastFinding);

    if (opts.i && str[whattsOnTheSide].toLowerCase() === value.toLowerCase() || !opts.i && str[whattsOnTheSide] === value) {
      var temp = direction === "right" ? right(str, whattsOnTheSide) : left(str, whattsOnTheSide);

      if (hungry && (opts.i && str[temp].toLowerCase() === value.toLowerCase() || !opts.i && str[temp] === value)) {
        satiated = true;
      } else {
        i += 1;
      }

      if (typeof whattsOnTheSide === "number" && direction === "right" && whattsOnTheSide > lastFinding + 1) {
        gaps.push([lastFinding + 1, whattsOnTheSide]);
      } else if (direction === "left" && typeof whattsOnTheSide === "number" && whattsOnTheSide < ~-lastFinding) {
        gaps.unshift([whattsOnTheSide + 1, lastFinding]);
      }

      lastFinding = whattsOnTheSide;

      if (direction === "right") {
        if (leftmostChar === undefined) {
          leftmostChar = whattsOnTheSide;
        }

        rightmostChar = whattsOnTheSide;
      } else {
        if (rightmostChar === undefined) {
          rightmostChar = whattsOnTheSide;
        }

        leftmostChar = whattsOnTheSide;
      }
    } else if (optional) {
      i += 1;
      continue;
    } else if (satiated) {
      i += 1;
      satiated = undefined;
      continue;
    } else {
      return null;
    }
  }

  if (leftmostChar === undefined || rightmostChar === undefined) {
    return null;
  }

  return {
    gaps: gaps,
    leftmostChar: leftmostChar,
    rightmostChar: rightmostChar
  };
}

var seqDefaults = {
  i: false
};

function leftSeq(str, idx) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  if (!args || !args.length) {
    throw new Error("string-left-right/leftSeq(): only two input arguments were passed! Did you intend to use left() method instead?");
  }

  var opts;

  if (lodash_isplainobject(args[0])) {
    opts = _objectSpread2(_objectSpread2({}, seqDefaults), args.shift());
  } else {
    opts = seqDefaults;
  }

  return seq("left", str, idx, opts, Array.from(args).reverse());
}

function rightSeq(str, idx) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    args[_key2 - 2] = arguments[_key2];
  }

  if (!args || !args.length) {
    throw new Error("string-left-right/rightSeq(): only two input arguments were passed! Did you intend to use right() method instead?");
  }

  var opts;

  if (lodash_isplainobject(args[0])) {
    opts = _objectSpread2(_objectSpread2({}, seqDefaults), args.shift());
  } else {
    opts = seqDefaults;
  }

  return seq("right", str, idx, opts, args);
}

function isObj$5(something) {
  return something && typeof something === "object" && !Array.isArray(something);
}

function isLatinLetterOrNumberOrHash(char) {
  return isStr$2(char) && char.length === 1 && (char.charCodeAt(0) > 96 && char.charCodeAt(0) < 123 || char.charCodeAt(0) > 47 && char.charCodeAt(0) < 58 || char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91 || char.charCodeAt(0) === 35);
}

function isNumeric(something) {
  return isStr$2(something) && something.charCodeAt(0) > 47 && something.charCodeAt(0) < 58;
}

function isStr$2(something) {
  return typeof something === "string";
}

function isLatinLetter$1(something) {
  return typeof something === "string" && (something.charCodeAt(0) > 96 && something.charCodeAt(0) < 123 || something.charCodeAt(0) > 64 && something.charCodeAt(0) < 91);
}

function resemblesNumericEntity(str2, from, to) {
  var lettersCount = 0;
  var numbersCount = 0;
  var othersCount = 0;
  var hashesCount = 0;
  var whitespaceCount = 0;
  var numbersValue = "";
  var charTrimmed = "";

  for (var i = from; i < to; i++) {
    if (str2[i].trim().length) {
      charTrimmed += str2[i];
    } else {
      whitespaceCount += 1;
    }

    if (isLatinLetter$1(str2[i])) {
      lettersCount += 1;
    } else if (isNumeric(str2[i])) {
      numbersCount += 1;
      numbersValue += String(str2[i]);
    } else if (str2[i] === "#") {
      hashesCount += 1;
    } else {
      othersCount += 1;
    }
  }

  var probablyNumeric = false;

  if (!lettersCount && numbersCount > othersCount) {
    probablyNumeric = "deci";
  } else if ((numbersCount || lettersCount) && (charTrimmed[0] === "#" && charTrimmed[1].toLowerCase() === "x" && (isNumeric(charTrimmed[2]) || isLatinLetter$1(charTrimmed[2])) || charTrimmed[0].toLowerCase() === "x" && numbersCount && !othersCount)) {
    probablyNumeric = "hexi";
  }

  return {
    probablyNumeric: probablyNumeric,
    lettersCount: lettersCount,
    numbersCount: numbersCount,
    numbersValue: numbersValue,
    hashesCount: hashesCount,
    othersCount: othersCount,
    charTrimmed: charTrimmed,
    whitespaceCount: whitespaceCount
  };
}

function findLongest(temp1) {
  if (Array.isArray(temp1) && temp1.length) {
    if (temp1.length === 1) {
      return temp1[0];
    }

    return temp1.reduce(function (accum, tempObj) {
      if (tempObj.tempEnt.length > accum.tempEnt.length) {
        return tempObj;
      }

      return accum;
    });
  }

  return temp1;
}

function removeGappedFromMixedCases(str, temp1) {
  /* istanbul ignore if */
  if (arguments.length !== 2) {
    throw new Error("removeGappedFromMixedCases(): wrong amount of inputs!");
  }

  var copy;

  if (Array.isArray(temp1) && temp1.length) {
    copy = Array.from(temp1);
    /* istanbul ignore if */

    if (copy.length > 1 && copy.some(function (entityObj) {
      return str[right(str, entityObj.tempRes.rightmostChar)] === ";";
    }) && copy.some(function (entityObj) {
      return str[right(str, entityObj.tempRes.rightmostChar)] !== ";";
    })) {
      copy = copy.filter(function (entityObj) {
        return str[right(str, entityObj.tempRes.rightmostChar)] === ";";
      });
    }

    if (!(copy.every(function (entObj) {
      return !entObj || !entObj.tempRes || !entObj.tempRes.gaps || !Array.isArray(entObj.tempRes.gaps) || !entObj.tempRes.gaps.length;
    }) || copy.every(function (entObj) {
      return entObj && entObj.tempRes && entObj.tempRes.gaps && Array.isArray(entObj.tempRes.gaps) && entObj.tempRes.gaps.length;
    }))) {
      return findLongest(copy.filter(function (entObj) {
        return !entObj.tempRes.gaps || !Array.isArray(entObj.tempRes.gaps) || !entObj.tempRes.gaps.length;
      }));
    }
  }

  return findLongest(temp1);
}

function fixEnt(str, originalOpts) {
  if (typeof str !== "string") {
    throw new Error("string-fix-broken-named-entities: [THROW_ID_01] the first input argument must be string! It was given as:\n" + JSON.stringify(str, null, 4) + " (" + typeof str + "-type)");
  }

  var defaults = {
    decode: false,
    cb: function cb(_ref) {
      var rangeFrom = _ref.rangeFrom,
          rangeTo = _ref.rangeTo,
          rangeValEncoded = _ref.rangeValEncoded,
          rangeValDecoded = _ref.rangeValDecoded;
      return rangeValDecoded || rangeValEncoded ? [rangeFrom, rangeTo, isObj$5(originalOpts) && originalOpts.decode ? rangeValDecoded : rangeValEncoded] : [rangeFrom, rangeTo];
    },
    progressFn: null,
    entityCatcherCb: null
  };

  if (originalOpts && !isObj$5(originalOpts)) {
    throw new Error("string-fix-broken-named-entities: [THROW_ID_02] the second input argument must be a plain object! I was given as:\n" + JSON.stringify(originalOpts, null, 4) + " (" + typeof originalOpts + "-type)");
  }

  var opts = _objectSpread2(_objectSpread2({}, defaults), originalOpts);

  if (opts.cb && typeof opts.cb !== "function") {
    throw new TypeError("string-fix-broken-named-entities: [THROW_ID_03] opts.cb must be a function (or falsey)! Currently it's: " + typeof opts.cb + ", equal to: " + JSON.stringify(opts.cb, null, 4));
  }

  if (opts.entityCatcherCb && typeof opts.entityCatcherCb !== "function") {
    throw new TypeError("string-fix-broken-named-entities: [THROW_ID_04] opts.entityCatcherCb must be a function (or falsey)! Currently it's: " + typeof opts.entityCatcherCb + ", equal to: " + JSON.stringify(opts.entityCatcherCb, null, 4));
  }

  if (opts.progressFn && typeof opts.progressFn !== "function") {
    throw new TypeError("string-fix-broken-named-entities: [THROW_ID_05] opts.progressFn must be a function (or falsey)! Currently it's: " + typeof opts.progressFn + ", equal to: " + JSON.stringify(opts.progressFn, null, 4));
  }

  var rangesArr2 = [];
  var percentageDone;
  var lastPercentageDone;
  var len = str.length + 1;
  var counter = 0;
  var doNothingUntil = null;
  var letterSeqStartAt = null;
  var brokenNumericEntityStartAt = null;

  var _loop = function _loop(i) {
    if (opts.progressFn) {
      percentageDone = Math.floor(counter / len * 100);
      /* istanbul ignore else */

      if (percentageDone !== lastPercentageDone) {
        lastPercentageDone = percentageDone;
        opts.progressFn(percentageDone);
      }
    }

    if (doNothingUntil) {
      if (typeof doNothingUntil === "number" && i >= doNothingUntil) {
        doNothingUntil = null;
      } else {
        counter += 1;
        return "continue";
      }
    }

    if (letterSeqStartAt !== null && i - letterSeqStartAt > 50) {
      letterSeqStartAt = null;
    }

    if (letterSeqStartAt !== null && (!str[i] || str[i].trim().length && !isLatinLetterOrNumberOrHash(str[i]))) {
      if (i > letterSeqStartAt + 1) {
        var potentialEntity = str.slice(letterSeqStartAt, i);
        var whatsOnTheLeft = left(str, letterSeqStartAt);
        var whatsEvenMoreToTheLeft = whatsOnTheLeft ? left(str, whatsOnTheLeft) : "";

        if (str[whatsOnTheLeft] === "&" && (!str[i] || str[i] !== ";")) {
          var firstChar = letterSeqStartAt;
          /* istanbul ignore next */

          var secondChar = letterSeqStartAt ? right(str, letterSeqStartAt) : null;
          /* istanbul ignore else */

          if (Object.prototype.hasOwnProperty.call(entStartsWith, str[firstChar]) && Object.prototype.hasOwnProperty.call(entStartsWith[str[firstChar]], str[secondChar])) {
            var tempEnt = "";
            var tempRes;
            var temp1 = entStartsWith[str[firstChar]][str[secondChar]].reduce(function (gatheredSoFar, oneOfKnownEntities) {
              tempRes = rightSeq.apply(void 0, [str, letterSeqStartAt - 1].concat(oneOfKnownEntities.split("")));

              if (tempRes) {
                return gatheredSoFar.concat([{
                  tempEnt: oneOfKnownEntities,
                  tempRes: tempRes
                }]);
              }

              return gatheredSoFar;
            }, []);
            temp1 = removeGappedFromMixedCases(str, temp1);
            /* istanbul ignore else */

            if (temp1) {
              var _temp = temp1;
              tempEnt = _temp.tempEnt;
              tempRes = _temp.tempRes;
            }

            if (tempEnt && (!Object.keys(uncertain).includes(tempEnt) || !str[tempRes.rightmostChar + 1] || ["&"].includes(str[tempRes.rightmostChar + 1]) || (uncertain[tempEnt].addSemiIfAmpPresent === true || uncertain[tempEnt].addSemiIfAmpPresent && (!str[tempRes.rightmostChar + 1] || !str[tempRes.rightmostChar + 1].trim().length)) && str[tempRes.leftmostChar - 1] === "&")) {
              var decodedEntity = decode("&" + tempEnt + ";");
              rangesArr2.push({
                ruleName: "bad-named-html-entity-malformed-" + tempEnt,
                entityName: tempEnt,
                rangeFrom: whatsOnTheLeft || 0,
                rangeTo: tempRes.rightmostChar + 1,
                rangeValEncoded: "&" + tempEnt + ";",
                rangeValDecoded: decodedEntity
              });
            }
          }
        } else if (str[whatsOnTheLeft] !== "&" && str[whatsEvenMoreToTheLeft] !== "&" && str[i] === ";") {
          var lastChar = left(str, i);
          var secondToLast = left(str, lastChar);

          if (secondToLast !== null && Object.prototype.hasOwnProperty.call(entEndsWith, str[lastChar]) && Object.prototype.hasOwnProperty.call(entEndsWith[str[lastChar]], str[secondToLast])) {
            var _tempEnt = "";

            var _tempRes;

            var _temp2 = entEndsWith[str[lastChar]][str[secondToLast]].reduce(function (gatheredSoFar, oneOfKnownEntities) {
              _tempRes = leftSeq.apply(void 0, [str, i].concat(oneOfKnownEntities.split("")));

              if (_tempRes && !(oneOfKnownEntities === "block" && str[left(str, letterSeqStartAt)] === ":")) {
                return gatheredSoFar.concat([{
                  tempEnt: oneOfKnownEntities,
                  tempRes: _tempRes
                }]);
              }

              return gatheredSoFar;
            }, []);

            _temp2 = removeGappedFromMixedCases(str, _temp2);
            /* istanbul ignore else */

            if (_temp2) {
              var _temp3 = _temp2;
              _tempEnt = _temp3.tempEnt;
              _tempRes = _temp3.tempRes;
            }

            if (_tempEnt && (!Object.keys(uncertain).includes(_tempEnt) || uncertain[_tempEnt].addAmpIfSemiPresent === true || uncertain[_tempEnt].addAmpIfSemiPresent && (!_tempRes.leftmostChar || isStr$2(str[_tempRes.leftmostChar - 1]) && !str[_tempRes.leftmostChar - 1].trim().length))) {
              var _decodedEntity = decode("&" + _tempEnt + ";");

              rangesArr2.push({
                ruleName: "bad-named-html-entity-malformed-" + _tempEnt,
                entityName: _tempEnt,
                rangeFrom: _tempRes.leftmostChar,
                rangeTo: i + 1,
                rangeValEncoded: "&" + _tempEnt + ";",
                rangeValDecoded: _decodedEntity
              });
            }
          } else if (brokenNumericEntityStartAt !== null) {
            rangesArr2.push({
              ruleName: "bad-malformed-numeric-character-entity",
              entityName: null,
              rangeFrom: brokenNumericEntityStartAt,
              rangeTo: i + 1,
              rangeValEncoded: null,
              rangeValDecoded: null
            });
            brokenNumericEntityStartAt = null;
          }
        } else if ((str[whatsOnTheLeft] === "&" || str[whatsOnTheLeft] === ";" && str[whatsEvenMoreToTheLeft] === "&") && str[i] === ";") {
          /* istanbul ignore else */
          if (str.slice(whatsOnTheLeft + 1, i).trim().length > 1) {
            var situation = resemblesNumericEntity(str, whatsOnTheLeft + 1, i);

            if (situation.probablyNumeric) {
              if (
              /* istanbul ignore next */
              situation.probablyNumeric && situation.charTrimmed[0] === "#" && !situation.whitespaceCount && (!situation.lettersCount && situation.numbersCount > 0 && !situation.othersCount || (situation.numbersCount || situation.lettersCount) && situation.charTrimmed[1] === "x" && !situation.othersCount)) {
                var decodedEntitysValue = String.fromCharCode(parseInt(situation.charTrimmed.slice(situation.probablyNumeric === "deci" ? 1 : 2), situation.probablyNumeric === "deci" ? 10 : 16));

                if (situation.probablyNumeric === "deci" && parseInt(situation.numbersValue, 10) > 918015) {
                  rangesArr2.push({
                    ruleName: "bad-malformed-numeric-character-entity",
                    entityName: null,
                    rangeFrom: whatsOnTheLeft || 0,
                    rangeTo: i + 1,
                    rangeValEncoded: null,
                    rangeValDecoded: null
                  });
                } else if (opts.decode) {
                  rangesArr2.push({
                    ruleName: "encoded-numeric-html-entity-reference",
                    entityName: situation.charTrimmed,
                    rangeFrom: whatsOnTheLeft || 0,
                    rangeTo: i + 1,
                    rangeValEncoded: "&" + situation.charTrimmed + ";",
                    rangeValDecoded: decodedEntitysValue
                  });
                }
              } else {
                rangesArr2.push({
                  ruleName: "bad-malformed-numeric-character-entity",
                  entityName: null,
                  rangeFrom: whatsOnTheLeft || 0,
                  rangeTo: i + 1,
                  rangeValEncoded: null,
                  rangeValDecoded: null
                });
              }

              if (opts.entityCatcherCb) {
                opts.entityCatcherCb(whatsOnTheLeft, i + 1);
              }
            } else {
              var potentialEntityOnlyNonWhitespaceChars = Array.from(potentialEntity).filter(function (char) {
                return char.trim().length;
              }).join("");

              if (potentialEntityOnlyNonWhitespaceChars.length <= maxLength && allNamedEntitiesSetOnlyCaseInsensitive.has(potentialEntityOnlyNonWhitespaceChars.toLowerCase())) {
                if (!allNamedEntitiesSetOnly.has(potentialEntityOnlyNonWhitespaceChars)) {
                  var matchingEntitiesOfCorrectCaseArr = [].concat(allNamedEntitiesSetOnly).filter(function (ent) {
                    return ent.toLowerCase() === potentialEntityOnlyNonWhitespaceChars.toLowerCase();
                  });

                  if (matchingEntitiesOfCorrectCaseArr.length === 1) {
                    rangesArr2.push({
                      ruleName: "bad-named-html-entity-malformed-" + matchingEntitiesOfCorrectCaseArr[0],
                      entityName: matchingEntitiesOfCorrectCaseArr[0],
                      rangeFrom: whatsOnTheLeft,
                      rangeTo: i + 1,
                      rangeValEncoded: "&" + matchingEntitiesOfCorrectCaseArr[0] + ";",
                      rangeValDecoded: decode("&" + matchingEntitiesOfCorrectCaseArr[0] + ";")
                    });
                  } else {
                    rangesArr2.push({
                      ruleName: "bad-named-html-entity-unrecognised",
                      entityName: null,
                      rangeFrom: whatsOnTheLeft,
                      rangeTo: i + 1,
                      rangeValEncoded: null,
                      rangeValDecoded: null
                    });
                  }
                } else if (i - whatsOnTheLeft - 1 !== potentialEntityOnlyNonWhitespaceChars.length || str[whatsOnTheLeft] !== "&") {
                  var rangeFrom = str[whatsOnTheLeft] === "&" ? whatsOnTheLeft : whatsEvenMoreToTheLeft;

                  if (Object.keys(uncertain).includes(potentialEntityOnlyNonWhitespaceChars) && !str[rangeFrom + 1].trim().length) {
                    letterSeqStartAt = null;
                    return "continue";
                  }

                  rangesArr2.push({
                    ruleName: "bad-named-html-entity-malformed-" + potentialEntityOnlyNonWhitespaceChars,
                    entityName: potentialEntityOnlyNonWhitespaceChars,
                    rangeFrom: rangeFrom,
                    rangeTo: i + 1,
                    rangeValEncoded: "&" + potentialEntityOnlyNonWhitespaceChars + ";",
                    rangeValDecoded: decode("&" + potentialEntityOnlyNonWhitespaceChars + ";")
                  });
                } else if (opts.decode) {
                  rangesArr2.push({
                    ruleName: "encoded-html-entity-" + potentialEntityOnlyNonWhitespaceChars,
                    entityName: potentialEntityOnlyNonWhitespaceChars,
                    rangeFrom: whatsOnTheLeft,
                    rangeTo: i + 1,
                    rangeValEncoded: "&" + potentialEntityOnlyNonWhitespaceChars + ";",
                    rangeValDecoded: decode("&" + potentialEntityOnlyNonWhitespaceChars + ";")
                  });
                } else if (opts.entityCatcherCb) {
                  opts.entityCatcherCb(whatsOnTheLeft, i + 1);
                }

                letterSeqStartAt = null;
                return "continue";
              }
              /* istanbul ignore next */


              letterSeqStartAt ? right(str, letterSeqStartAt) : null;
              var _tempEnt2 = "";
              var temp;

              if (Object.prototype.hasOwnProperty.call(brokenNamedEntities, situation.charTrimmed.toLowerCase())) {
                _tempEnt2 = situation.charTrimmed;

                var _decodedEntity2 = decode("&" + brokenNamedEntities[situation.charTrimmed.toLowerCase()] + ";");

                rangesArr2.push({
                  ruleName: "bad-named-html-entity-malformed-" + brokenNamedEntities[situation.charTrimmed.toLowerCase()],
                  entityName: brokenNamedEntities[situation.charTrimmed.toLowerCase()],
                  rangeFrom: whatsOnTheLeft,
                  rangeTo: i + 1,
                  rangeValEncoded: "&" + brokenNamedEntities[situation.charTrimmed.toLowerCase()] + ";",
                  rangeValDecoded: _decodedEntity2
                });
              } else if (potentialEntity.length < maxLength + 2 && ((temp = [].concat(allNamedEntitiesSetOnly).filter(function (curr) {
                return leven_1(curr, potentialEntity) === 1;
              })) && temp.length || (temp = [].concat(allNamedEntitiesSetOnly).filter(function (curr) {
                return (
                  /* istanbul ignore next */
                  leven_1(curr, potentialEntity) === 2 && potentialEntity.length > 3
                );
              })) && temp.length)) {
                if (temp.length === 1) {
                  var _temp4 = temp;
                  _tempEnt2 = _temp4[0];
                  rangesArr2.push({
                    ruleName: "bad-named-html-entity-malformed-" + _tempEnt2,
                    entityName: _tempEnt2,
                    rangeFrom: whatsOnTheLeft,
                    rangeTo: i + 1,
                    rangeValEncoded: "&" + _tempEnt2 + ";",
                    rangeValDecoded: decode("&" + _tempEnt2 + ";")
                  });
                }
              }

              if (!_tempEnt2) {
                rangesArr2.push({
                  ruleName: "bad-named-html-entity-unrecognised",
                  entityName: null,
                  rangeFrom: whatsOnTheLeft,
                  rangeTo: i + 1,
                  rangeValEncoded: null,
                  rangeValDecoded: null
                });
              }
            }
          }
        } else if (str[whatsEvenMoreToTheLeft] === "&" && str[i] === ";" && i - whatsEvenMoreToTheLeft < maxLength) {
          var _situation = resemblesNumericEntity(str, whatsEvenMoreToTheLeft + 1, i);

          rangesArr2.push({
            ruleName: "" + (
            /* istanbul ignore next */
            _situation.probablyNumeric ? "bad-malformed-numeric-character-entity" : "bad-named-html-entity-unrecognised"),
            entityName: null,
            rangeFrom: whatsEvenMoreToTheLeft,
            rangeTo: i + 1,
            rangeValEncoded: null,
            rangeValDecoded: null
          });
        }
      }

      letterSeqStartAt = null;
    }

    if (letterSeqStartAt === null && isLatinLetterOrNumberOrHash(str[i]) && str[i + 1]) {
      letterSeqStartAt = i;
    }

    if (str[i] === "a") {
      var singleAmpOnTheRight = rightSeq(str, i, "m", "p", ";");

      if (singleAmpOnTheRight) {
        var toDeleteAllAmpEndHere = singleAmpOnTheRight.rightmostChar + 1;
        var nextAmpOnTheRight = rightSeq(str, singleAmpOnTheRight.rightmostChar, "a", "m", "p", ";");

        if (nextAmpOnTheRight) {
          toDeleteAllAmpEndHere = nextAmpOnTheRight.rightmostChar + 1;

          var _temp5;

          do {
            _temp5 = rightSeq(str, toDeleteAllAmpEndHere - 1, "a", "m", "p", ";");

            if (_temp5) {
              toDeleteAllAmpEndHere = _temp5.rightmostChar + 1;
            }
          } while (_temp5);
        }

        var firstCharThatFollows = right(str, toDeleteAllAmpEndHere - 1);
        var secondCharThatFollows = firstCharThatFollows ? right(str, firstCharThatFollows) : null;
        var matchedTemp = "";

        if (secondCharThatFollows && Object.prototype.hasOwnProperty.call(entStartsWith, str[firstCharThatFollows]) && Object.prototype.hasOwnProperty.call(entStartsWith[str[firstCharThatFollows]], str[secondCharThatFollows]) && entStartsWith[str[firstCharThatFollows]][str[secondCharThatFollows]].some(function (entity) {
          var matchEntityOnTheRight = rightSeq.apply(void 0, [str, toDeleteAllAmpEndHere - 1].concat(entity.split("")));
          /* istanbul ignore else */

          if (matchEntityOnTheRight) {
            matchedTemp = entity;
            return true;
          }
        })) {
          doNothingUntil = firstCharThatFollows + matchedTemp.length + 1;

          var _whatsOnTheLeft = left(str, i);
          /* istanbul ignore else */


          if (str[_whatsOnTheLeft] === "&") {
            rangesArr2.push({
              ruleName: "bad-named-html-entity-multiple-encoding",
              entityName: matchedTemp,
              rangeFrom: _whatsOnTheLeft || 0,
              rangeTo: doNothingUntil,
              rangeValEncoded: "&" + matchedTemp + ";",
              rangeValDecoded: decode("&" + matchedTemp + ";")
            });
          } else if (_whatsOnTheLeft) {
            var _rangeFrom = i;
            var spaceReplacement = "";
            if (str[i - 1] === " ") ;
            /* istanbul ignore else */

            if (typeof opts.cb === "function") {
              rangesArr2.push({
                ruleName: "bad-named-html-entity-multiple-encoding",
                entityName: matchedTemp,
                rangeFrom: _rangeFrom,
                rangeTo: doNothingUntil,
                rangeValEncoded: spaceReplacement + "&" + matchedTemp + ";",
                rangeValDecoded: "" + spaceReplacement + decode("&" + matchedTemp + ";")
              });
            }
          }
        }
      }
    }

    if (str[i] === "#" && right(str, i) && str[right(str, i)].toLowerCase() === "x" && (!str[i - 1] || !left(str, i) || str[left(str, i)] !== "&")) {
      if (isNumeric(str[right(str, right(str, i))])) {
        brokenNumericEntityStartAt = i;
      }
    }

    counter += 1;
  };

  for (var i = 0; i < len; i++) {
    var _ret = _loop(i);

    if (_ret === "continue") continue;
  }

  if (!rangesArr2.length) {
    return [];
  }

  var res = rangesArr2.filter(function (filteredRangeObj, i) {
    return rangesArr2.every(function (oneOfEveryObj, y) {
      return i === y || !(filteredRangeObj.rangeFrom >= oneOfEveryObj.rangeFrom && filteredRangeObj.rangeTo < oneOfEveryObj.rangeTo);
    });
  }).map(opts.cb);
  return res;
}

/**
 * ast-monkey-util
 * Utility library of AST helper functions
 * Version: 1.3.8
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/ast-monkey-util/
 */
function pathNext(str) {
  if (str.includes(".") && /^\d*$/.test(str.slice(str.lastIndexOf(".") + 1))) {
    return "" + str.slice(0, str.lastIndexOf(".") + 1) + (+str.slice(str.lastIndexOf(".") + 1) + 1);
  }

  if (/^\d*$/.test(str)) {
    return "" + (+str + 1);
  }

  return str;
}

function pathPrev(str) {
  if (!str) {
    return null;
  }

  var extractedValue = str.slice(str.lastIndexOf(".") + 1);

  if (extractedValue === "0") {
    return null;
  }

  if (str.includes(".") && /^\d*$/.test(extractedValue)) {
    return "" + str.slice(0, str.lastIndexOf(".") + 1) + (+str.slice(str.lastIndexOf(".") + 1) - 1);
  }

  if (/^\d*$/.test(str)) {
    return "" + (+str - 1);
  }

  return null;
}

function pathUp(str) {
  if (str.includes(".") && str.slice(str.indexOf(".") + 1).includes(".")) {
    var dotsCount = 0;

    for (var i = str.length; i--;) {
      if (str[i] === ".") {
        dotsCount += 1;
      }

      if (dotsCount === 2) {
        return str.slice(0, i);
      }
    }
  }

  return "0";
}

function parent(str) {
  if (str.includes(".")) {
    var lastDotAt = str.lastIndexOf(".");

    if (!str.slice(0, lastDotAt).includes(".")) {
      return str.slice(0, lastDotAt);
    }

    for (var i = lastDotAt - 1; i--;) {
      if (str[i] === ".") {
        return str.slice(i + 1, lastDotAt);
      }
    }
  }

  return null;
}

function traverse(tree1, cb1) {
  var stop2 = {
    now: false
  };

  function traverseInner(treeOriginal, callback, originalInnerObj, stop) {
    var tree = lodash_clonedeep(treeOriginal);
    var res;

    var innerObj = _objectSpread2({
      depth: -1,
      path: ""
    }, originalInnerObj);

    innerObj.depth += 1;

    if (Array.isArray(tree)) {
      for (var i = 0, len = tree.length; i < len; i++) {
        if (stop.now) {
          break;
        }

        var path = innerObj.path ? innerObj.path + "." + i : "" + i;

        if (tree[i] !== undefined) {
          innerObj.parent = lodash_clonedeep(tree);
          innerObj.parentType = "array";
          innerObj.parentKey = parent(path);
          res = traverseInner(callback(tree[i], undefined, _objectSpread2(_objectSpread2({}, innerObj), {}, {
            path: path
          }), stop), callback, _objectSpread2(_objectSpread2({}, innerObj), {}, {
            path: path
          }), stop);

          if (Number.isNaN(res) && i < tree.length) {
            tree.splice(i, 1);
            i -= 1;
          } else {
            tree[i] = res;
          }
        } else {
          tree.splice(i, 1);
        }
      }
    } else if (lodash_isplainobject(tree)) {
      for (var key in tree) {
        if (stop.now && key != null) {
          break;
        }

        var _path = innerObj.path ? innerObj.path + "." + key : key;

        if (innerObj.depth === 0 && key != null) {
          innerObj.topmostKey = key;
        }

        innerObj.parent = lodash_clonedeep(tree);
        innerObj.parentType = "object";
        innerObj.parentKey = parent(_path);
        res = traverseInner(callback(key, tree[key], _objectSpread2(_objectSpread2({}, innerObj), {}, {
          path: _path
        }), stop), callback, _objectSpread2(_objectSpread2({}, innerObj), {}, {
          path: _path
        }), stop);

        if (Number.isNaN(res)) {
          delete tree[key];
        } else {
          tree[key] = res;
        }
      }
    }

    return tree;
  }

  return traverseInner(tree1, cb1, {}, stop2);
}

/**
 * line-column-mini
 * Convert string index to line-column position
 * Version: 1.1.8
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/line-column-mini/
 */

function binarySearch(el, arr) {
  var m = 0;
  var n = arr.length - 2;

  while (m < n) {
    var k = m + (n - m >> 1);

    if (el < arr[k]) {
      n = k - 1;
    } else if (el >= arr[k + 1]) {
      m = k + 1;
    } else {
      m = k;
      break;
    }
  }

  return m;
}

function getLineStartIndexes(str) {
  return str.split(/\n|\r(?!\n)/g).reduce(function (acc, curr) {
    acc.push(acc[acc.length - 1] + curr.length + 1);
    return acc;
  }, [0]);
}

function lineCol(input, idx, skipChecks) {
  if (skipChecks === void 0) {
    skipChecks = false;
  }

  if (!skipChecks && (!Array.isArray(input) && typeof input !== "string" || (typeof input === "string" || Array.isArray(input)) && !input.length)) {
    return null;
  }

  if (!skipChecks && (typeof idx !== "number" || typeof input === "string" && idx >= input.length || Array.isArray(input) && idx + 1 >= input[input.length - 1])) {
    return null;
  }

  if (typeof input === "string") {
    var startIndexesOfEachLine = getLineStartIndexes(input);

    var _line = binarySearch(idx, startIndexesOfEachLine);

    return {
      col: idx - startIndexesOfEachLine[_line] + 1,
      line: _line + 1
    };
  }

  var line = binarySearch(idx, input);
  return {
    col: idx - input[line] + 1,
    line: line + 1
  };
}

function isObj$4(something) {
  return something && typeof something === "object" && !Array.isArray(something);
}

function isStr$1(something) {
  return typeof something === "string";
}

var defaults$9 = {
  stringOffset: 0,
  maxDistance: 1,
  ignoreWhitespace: true
};

function findMalformed(str, refStr, cb, originalOpts) {
  if (!isStr$1(str)) {
    throw new TypeError("string-find-malformed: [THROW_ID_01] the first input argument, string where to look for, must be a string! Currently it's equal to: " + str + " (type: " + typeof str + ")");
  } else if (!str.length) {
    return;
  }

  if (!isStr$1(refStr)) {
    throw new TypeError("string-find-malformed: [THROW_ID_02] the second input argument, string we should find, must be a string! Currently it's equal to: " + refStr + " (type: " + typeof refStr + ")");
  } else if (!refStr.length) {
    return;
  }

  if (typeof cb !== "function") {
    throw new TypeError("string-find-malformed: [THROW_ID_03] the third input argument, a callback function, must be a function! Currently it's equal to: " + cb + " (type: " + typeof cb + ")");
  }

  if (originalOpts && !isObj$4(originalOpts)) {
    throw new TypeError("string-find-malformed: [THROW_ID_04] the fourth input argument, an Optional Options Object, must be a plain object! Currently it's equal to: " + originalOpts + " (type: " + typeof originalOpts + ")");
  }

  var opts = _objectSpread2(_objectSpread2({}, defaults$9), originalOpts);

  if (typeof opts.stringOffset === "string" && /^\d*$/.test(opts.stringOffset)) {
    opts.stringOffset = Number(opts.stringOffset);
  } else if (!Number.isInteger(opts.stringOffset) || opts.stringOffset < 0) {
    throw new TypeError("[THROW_ID_05] opts.stringOffset must be a natural number or zero! Currently it's: " + opts.stringOffset);
  }

  var len = str.length;
  var len2 = Math.min(refStr.length, (opts.maxDistance || 0) + 1);
  var pendingMatchesArr = [];
  var patience = opts.maxDistance || 1;
  var wasThisLetterMatched;

  for (var i = 0; i < len; i++) {
    if (opts.ignoreWhitespace && !str[i].trim()) {
      continue;
    }

    for (var z = 0, len3 = pendingMatchesArr.length; z < len3; z++) {
      wasThisLetterMatched = false;

      if (Array.isArray(pendingMatchesArr[z].pendingToCheck) && pendingMatchesArr[z].pendingToCheck.length && str[i] === pendingMatchesArr[z].pendingToCheck[0]) {
        wasThisLetterMatched = true;
        pendingMatchesArr[z].pendingToCheck.shift();
      } else if (Array.isArray(pendingMatchesArr[z].pendingToCheck) && pendingMatchesArr[z].pendingToCheck.length && str[i] === pendingMatchesArr[z].pendingToCheck[1]) {
        wasThisLetterMatched = true;
        pendingMatchesArr[z].pendingToCheck.shift();
        pendingMatchesArr[z].pendingToCheck.shift();
        pendingMatchesArr[z].patienceLeft -= 1;
      } else {
        pendingMatchesArr[z].patienceLeft -= 1;

        if (str[right(str, i)] !== pendingMatchesArr[z].pendingToCheck[0]) {
          pendingMatchesArr[z].pendingToCheck.shift();

          if (str[i] === pendingMatchesArr[z].pendingToCheck[0]) {
            pendingMatchesArr[z].pendingToCheck.shift();
          }
        }
      }
    }

    pendingMatchesArr = pendingMatchesArr.filter(function (obj) {
      return obj.patienceLeft >= 0;
    });
    var tempArr = pendingMatchesArr.filter(function (obj) {
      return obj.pendingToCheck.length === 0;
    }).map(function (obj) {
      return obj.startsAt;
    });

    if (Array.isArray(tempArr) && tempArr.length) {
      var idxFrom = Math.min.apply(Math, tempArr);
      var idxTo = i + (wasThisLetterMatched ? 1 : 0);

      if (str.slice(idxFrom, idxTo) !== refStr) {
        cb({
          idxFrom: idxFrom + (opts.stringOffset || 0),
          idxTo: idxTo + (opts.stringOffset || 0)
        });
      }

      pendingMatchesArr = pendingMatchesArr.filter(function (obj) {
        return obj.pendingToCheck.length;
      });
    }

    for (var y = 0; y < len2; y++) {
      if (str[i] === refStr[y]) {
        var whatToPush = {
          startsAt: i,
          patienceLeft: patience - y,
          pendingToCheck: Array.from(refStr.slice(y + 1))
        };
        pendingMatchesArr.push(whatToPush);
        break;
      }
    }
  }
}

/**
 * arrayiffy-if-string
 * Put non-empty strings into arrays, turn empty-ones into empty arrays. Bypass everything else.
 * Version: 3.13.8
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/arrayiffy-if-string/
 */
function arrayiffy(something) {
  if (typeof something === "string") {
    if (something.length) {
      return [something];
    }

    return [];
  }

  return something;
}

function isObj$3(something) {
  return something && typeof something === "object" && !Array.isArray(something);
}

function isStr(something) {
  return typeof something === "string";
}

var defaults$8 = {
  cb: undefined,
  i: false,
  trimBeforeMatching: false,
  trimCharsBeforeMatching: [],
  maxMismatches: 0,
  firstMustMatch: false,
  lastMustMatch: false,
  hungry: false
};

var defaultGetNextIdx = function defaultGetNextIdx(index) {
  return index + 1;
};

function march(str, position, whatToMatchVal, originalOpts, special, getNextIdx) {
  if (special === void 0) {
    special = false;
  }

  if (getNextIdx === void 0) {
    getNextIdx = defaultGetNextIdx;
  }

  var whatToMatchValVal = typeof whatToMatchVal === "function" ? whatToMatchVal() : whatToMatchVal;

  if (+position < 0 && special && whatToMatchValVal === "EOL") {
    return whatToMatchValVal;
  }

  var opts = _objectSpread2(_objectSpread2({}, defaults$8), originalOpts);

  if (position >= str.length && !special) {
    return false;
  }

  var charsToCheckCount = special ? 1 : whatToMatchVal.length;
  var charsMatchedTotal = 0;
  var patienceReducedBeforeFirstMatch = false;
  var lastWasMismatched = false;
  var atLeastSomethingWasMatched = false;
  var patience = opts.maxMismatches;
  var i = position;
  var somethingFound = false;
  var firstCharacterMatched = false;
  var lastCharacterMatched = false;

  function whitespaceInFrontOfFirstChar() {
    return charsMatchedTotal === 1 && patience < opts.maxMismatches - 1;
  }

  while (str[i]) {
    var nextIdx = getNextIdx(i);

    if (opts.trimBeforeMatching && str[i].trim() === "") {
      if (!str[nextIdx] && special && whatToMatchVal === "EOL") {
        return true;
      }

      i = getNextIdx(i);
      continue;
    }

    if (opts && !opts.i && opts.trimCharsBeforeMatching && opts.trimCharsBeforeMatching.includes(str[i]) || opts && opts.i && opts.trimCharsBeforeMatching && opts.trimCharsBeforeMatching.map(function (val) {
      return val.toLowerCase();
    }).includes(str[i].toLowerCase())) {
      if (special && whatToMatchVal === "EOL" && !str[nextIdx]) {
        return true;
      }

      i = getNextIdx(i);
      continue;
    }

    var charToCompareAgainst = nextIdx > i ? whatToMatchVal[whatToMatchVal.length - charsToCheckCount] : whatToMatchVal[charsToCheckCount - 1];

    if (!opts.i && str[i] === charToCompareAgainst || opts.i && str[i].toLowerCase() === charToCompareAgainst.toLowerCase()) {
      if (!somethingFound) {
        somethingFound = true;
      }

      if (!atLeastSomethingWasMatched) {
        atLeastSomethingWasMatched = true;
      }

      if (charsToCheckCount === whatToMatchVal.length) {
        firstCharacterMatched = true;

        if (patience !== opts.maxMismatches) {
          return false;
        }
      } else if (charsToCheckCount === 1) {
        lastCharacterMatched = true;
      }

      charsToCheckCount -= 1;
      charsMatchedTotal++;

      if (whitespaceInFrontOfFirstChar()) {
        return false;
      }

      if (!charsToCheckCount) {
        return charsMatchedTotal !== whatToMatchVal.length || patience === opts.maxMismatches || !patienceReducedBeforeFirstMatch ? i : false;
      }
    } else {
      if (!patienceReducedBeforeFirstMatch && !charsMatchedTotal) {
        patienceReducedBeforeFirstMatch = true;
      }

      if (opts.maxMismatches && patience && i) {
        patience -= 1;

        for (var y = 0; y <= patience; y++) {
          var nextCharToCompareAgainst = nextIdx > i ? whatToMatchVal[whatToMatchVal.length - charsToCheckCount + 1 + y] : whatToMatchVal[charsToCheckCount - 2 - y];
          var nextCharInSource = str[getNextIdx(i)];

          if (nextCharToCompareAgainst && (!opts.i && str[i] === nextCharToCompareAgainst || opts.i && str[i].toLowerCase() === nextCharToCompareAgainst.toLowerCase()) && (!opts.firstMustMatch || charsToCheckCount !== whatToMatchVal.length)) {
            charsMatchedTotal++;

            if (whitespaceInFrontOfFirstChar()) {
              return false;
            }

            charsToCheckCount -= 2;
            somethingFound = true;
            break;
          } else if (nextCharInSource && nextCharToCompareAgainst && (!opts.i && nextCharInSource === nextCharToCompareAgainst || opts.i && nextCharInSource.toLowerCase() === nextCharToCompareAgainst.toLowerCase()) && (!opts.firstMustMatch || charsToCheckCount !== whatToMatchVal.length)) {
            if (!charsMatchedTotal && !opts.hungry) {
              return false;
            }

            charsToCheckCount -= 1;
            somethingFound = true;
            break;
          } else if (nextCharToCompareAgainst === undefined && patience >= 0 && somethingFound && (!opts.firstMustMatch || firstCharacterMatched) && (!opts.lastMustMatch || lastCharacterMatched)) {
            return i;
          }
        }

        if (!somethingFound) {
          lastWasMismatched = i;
        }
      } else if (i === 0 && charsToCheckCount === 1 && !opts.lastMustMatch && atLeastSomethingWasMatched) {
        return 0;
      } else {
        return false;
      }
    }

    if (lastWasMismatched !== false && lastWasMismatched !== i) {
      lastWasMismatched = false;
    }

    if (charsToCheckCount < 1) {
      return i;
    }

    i = getNextIdx(i);
  }

  if (charsToCheckCount > 0) {
    if (special && whatToMatchValVal === "EOL") {
      return true;
    }

    if (opts && opts.maxMismatches >= charsToCheckCount && atLeastSomethingWasMatched) {
      return lastWasMismatched || 0;
    }

    return false;
  }
}

function main(mode, str, position, originalWhatToMatch, originalOpts) {
  if (isObj$3(originalOpts) && Object.prototype.hasOwnProperty.call(originalOpts, "trimBeforeMatching") && typeof originalOpts.trimBeforeMatching !== "boolean") {
    throw new Error("string-match-left-right/" + mode + "(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!" + (Array.isArray(originalOpts.trimBeforeMatching) ? " Did you mean to use opts.trimCharsBeforeMatching?" : ""));
  }

  var opts = _objectSpread2(_objectSpread2({}, defaults$8), originalOpts);

  if (typeof opts.trimCharsBeforeMatching === "string") {
    opts.trimCharsBeforeMatching = arrayiffy(opts.trimCharsBeforeMatching);
  }

  opts.trimCharsBeforeMatching = opts.trimCharsBeforeMatching.map(function (el) {
    return isStr(el) ? el : String(el);
  });

  if (!isStr(str)) {
    return false;
  }

  if (!str.length) {
    return false;
  }

  if (!Number.isInteger(position) || position < 0) {
    throw new Error("string-match-left-right/" + mode + "(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: " + typeof position + ", equal to:\n" + JSON.stringify(position, null, 4));
  }

  var whatToMatch;
  var special;

  if (isStr(originalWhatToMatch)) {
    whatToMatch = [originalWhatToMatch];
  } else if (Array.isArray(originalWhatToMatch)) {
    whatToMatch = originalWhatToMatch;
  } else if (!originalWhatToMatch) {
    whatToMatch = originalWhatToMatch;
  } else if (typeof originalWhatToMatch === "function") {
    whatToMatch = [];
    whatToMatch.push(originalWhatToMatch);
  } else {
    throw new Error("string-match-left-right/" + mode + "(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's " + typeof originalWhatToMatch + ", equal to:\n" + JSON.stringify(originalWhatToMatch, null, 4));
  }

  if (originalOpts && !isObj$3(originalOpts)) {
    throw new Error("string-match-left-right/" + mode + "(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type \"" + typeof originalOpts + "\", and equal to:\n" + JSON.stringify(originalOpts, null, 4));
  }

  var culpritsIndex = 0;
  var culpritsVal = "";

  if (opts && opts.trimCharsBeforeMatching && opts.trimCharsBeforeMatching.some(function (el, i) {
    if (el.length > 1) {
      culpritsIndex = i;
      culpritsVal = el;
      return true;
    }

    return false;
  })) {
    throw new Error("string-match-left-right/" + mode + "(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index " + culpritsIndex + " is longer than 1 character, " + culpritsVal.length + " (equals to " + culpritsVal + "). Please split it into separate characters and put into array as separate elements.");
  }

  if (!whatToMatch || !Array.isArray(whatToMatch) || Array.isArray(whatToMatch) && !whatToMatch.length || Array.isArray(whatToMatch) && whatToMatch.length === 1 && isStr(whatToMatch[0]) && !whatToMatch[0].trim()) {
    if (typeof opts.cb === "function") {
      var firstCharOutsideIndex;
      var startingPosition = position;

      if (mode === "matchLeftIncl" || mode === "matchRight") {
        startingPosition += 1;
      }

      if (mode[5] === "L") {
        for (var y = startingPosition; y--;) {
          var currentChar = str[y];

          if ((!opts.trimBeforeMatching || opts.trimBeforeMatching && currentChar !== undefined && currentChar.trim()) && (!opts.trimCharsBeforeMatching || !opts.trimCharsBeforeMatching.length || currentChar !== undefined && !opts.trimCharsBeforeMatching.includes(currentChar))) {
            firstCharOutsideIndex = y;
            break;
          }
        }
      } else if (mode.startsWith("matchRight")) {
        for (var _y = startingPosition; _y < str.length; _y++) {
          var _currentChar = str[_y];

          if ((!opts.trimBeforeMatching || opts.trimBeforeMatching && _currentChar.trim()) && (!opts.trimCharsBeforeMatching || !opts.trimCharsBeforeMatching.length || !opts.trimCharsBeforeMatching.includes(_currentChar))) {
            firstCharOutsideIndex = _y;
            break;
          }
        }
      }

      if (firstCharOutsideIndex === undefined) {
        return false;
      }

      var wholeCharacterOutside = str[firstCharOutsideIndex];
      var indexOfTheCharacterAfter = firstCharOutsideIndex + 1;
      var theRemainderOfTheString = "";

      if (indexOfTheCharacterAfter && indexOfTheCharacterAfter > 0) {
        theRemainderOfTheString = str.slice(0, indexOfTheCharacterAfter);
      }

      if (mode[5] === "L") {
        return opts.cb(wholeCharacterOutside, theRemainderOfTheString, firstCharOutsideIndex);
      }

      if (firstCharOutsideIndex && firstCharOutsideIndex > 0) {
        theRemainderOfTheString = str.slice(firstCharOutsideIndex);
      }

      return opts.cb(wholeCharacterOutside, theRemainderOfTheString, firstCharOutsideIndex);
    }

    var extraNote = "";

    if (!originalOpts) {
      extraNote = " More so, the whole options object, the fourth input argument, is missing!";
    }

    throw new Error("string-match-left-right/" + mode + "(): [THROW_ID_08] the third argument, \"whatToMatch\", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key \"cb\" is not set!" + extraNote);
  }

  for (var i = 0, len = whatToMatch.length; i < len; i++) {
    special = typeof whatToMatch[i] === "function";
    var whatToMatchVal = whatToMatch[i];
    var fullCharacterInFront = void 0;
    var indexOfTheCharacterInFront = void 0;
    var restOfStringInFront = "";
    var _startingPosition = position;

    if (mode === "matchRight") {
      _startingPosition += 1;
    } else if (mode === "matchLeft") {
      _startingPosition -= 1;
    }

    var found = march(str, _startingPosition, whatToMatchVal, opts, special, function (i2) {
      return mode[5] === "L" ? i2 - 1 : i2 + 1;
    });

    if (found && special && typeof whatToMatchVal === "function" && whatToMatchVal() === "EOL") {
      return whatToMatchVal() && (opts.cb ? opts.cb(fullCharacterInFront, restOfStringInFront, indexOfTheCharacterInFront) : true) ? whatToMatchVal() : false;
    }

    if (Number.isInteger(found)) {
      indexOfTheCharacterInFront = mode.startsWith("matchLeft") ? found - 1 : found + 1;

      if (mode[5] === "L") {
        restOfStringInFront = str.slice(0, found);
      } else {
        restOfStringInFront = str.slice(indexOfTheCharacterInFront);
      }
    }

    if (indexOfTheCharacterInFront < 0) {
      indexOfTheCharacterInFront = undefined;
    }

    if (str[indexOfTheCharacterInFront]) {
      fullCharacterInFront = str[indexOfTheCharacterInFront];
    }

    if (Number.isInteger(found) && (opts.cb ? opts.cb(fullCharacterInFront, restOfStringInFront, indexOfTheCharacterInFront) : true)) {
      return whatToMatchVal;
    }
  }

  return false;
}

function matchLeftIncl(str, position, whatToMatch, opts) {
  return main("matchLeftIncl", str, position, whatToMatch, opts);
}

function matchLeft(str, position, whatToMatch, opts) {
  return main("matchLeft", str, position, whatToMatch, opts);
}

function matchRightIncl(str, position, whatToMatch, opts) {
  return main("matchRightIncl", str, position, whatToMatch, opts);
}

function matchRight(str, position, whatToMatch, opts) {
  return main("matchRight", str, position, whatToMatch, opts);
}

/**
 * html-all-known-attributes
 * All HTML attributes known to the Humanity
 * Version: 4.0.8
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/html-all-known-attributes/
 */
var allHtmlAttribs = new Set(["abbr", "accept", "accept-charset", "accesskey", "action", "align", "alink", "allow", "alt", "archive", "async", "autocapitalize", "autocomplete", "autofocus", "autoplay", "axis", "background", "background-attachment", "background-color", "background-image", "background-position", "background-position-x", "background-position-y", "background-repeat", "bgcolor", "border", "border-bottom", "border-bottom-color", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-style", "border-top", "border-top-color", "border-top-style", "border-top-width", "border-width", "buffered", "capture", "cellpadding", "cellspacing", "challenge", "char", "charoff", "charset", "checked", "cite", "class", "classid", "clear", "clip", "code", "codebase", "codetype", "color", "cols", "colspan", "column-span", "compact", "content", "contenteditable", "contextmenu", "controls", "coords", "crossorigin", "csp", "cursor", "data", "data-*", "datetime", "declare", "decoding", "default", "defer", "dir", "direction", "dirname", "disabled", "display", "download", "draggable", "dropzone", "enctype", "enterkeyhint", "face", "filter", "float", "font", "font-color", "font-emphasize", "font-emphasize-position", "font-emphasize-style", "font-family", "font-size", "font-style", "font-variant", "font-weight", "for", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "frame", "frameborder", "frontuid", "headers", "height", "hidden", "high", "horiz-align", "href", "hreflang", "hspace", "http-equiv", "icon", "id", "importance", "inputmode", "integrity", "intrinsicsize", "ismap", "itemprop", "keytype", "kind", "label", "lang", "language", "layout-flow", "layout-grid", "layout-grid-char", "layout-grid-line", "layout-grid-mode", "layout-grid-type", "left", "letter-spacing", "line-break", "line-height", "link", "list", "list-image-1", "list-image-2", "list-image-3", "list-style", "list-style-image", "list-style-position", "list-style-type", "loading", "longdesc", "loop", "low", "manifest", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marginheight", "marginwidth", "max", "maxlength", "media", "method", "min", "minlength", "mso-ansi-font-size", "mso-ansi-font-style", "mso-ansi-font-weight", "mso-ansi-language", "mso-ascii-font-family", "mso-background", "mso-background-source", "mso-baseline-position", "mso-bidi-flag", "mso-bidi-font-family", "mso-bidi-font-size", "mso-bidi-font-style", "mso-bidi-font-weight", "mso-bidi-language", "mso-bookmark", "mso-border-alt", "mso-border-between", "mso-border-between-color", "mso-border-between-style", "mso-border-between-width", "mso-border-bottom-alt", "mso-border-bottom-color-alt", "mso-border-bottom-source", "mso-border-bottom-style-alt", "mso-border-bottom-width-alt", "mso-border-color-alt", "mso-border-effect", "mso-border-left-alt", "mso-border-left-color-alt", "mso-border-left-source", "mso-border-left-style-alt", "mso-border-left-width-alt", "mso-border-right-alt", "mso-border-right-color-alt", "mso-border-right-source", "mso-border-right-style-alt", "mso-border-right-width-alt", "mso-border-shadow", "mso-border-source", "mso-border-style-alt", "mso-border-top-alt", "mso-border-top-color-alt", "mso-border-top-source", "mso-border-top-style-alt", "mso-border-top-width-alt", "mso-border-width-alt", "mso-break-type", "mso-build", "mso-build-after-action", "mso-build-after-color", "mso-build-auto-secs", "mso-build-avi", "mso-build-dual-id", "mso-build-order", "mso-build-sound-name", "mso-bullet-image", "mso-cell-special", "mso-cellspacing", "mso-char-indent", "mso-char-indent-count", "mso-char-indent-size", "mso-char-type", "mso-char-wrap", "mso-color-alt", "mso-color-index", "mso-color-source", "mso-column-break-before", "mso-column-separator", "mso-columns", "mso-comment-author", "mso-comment-continuation", "mso-comment-id", "mso-comment-reference", "mso-data-placement", "mso-default-height", "mso-default-width", "mso-diagonal-down", "mso-diagonal-down-color", "mso-diagonal-down-source", "mso-diagonal-down-style", "mso-diagonal-down-width", "mso-diagonal-up", "mso-diagonal-up-color", "mso-diagonal-up-source", "mso-diagonal-up-style", "mso-diagonal-up-width", "mso-displayed-decimal-separator", "mso-displayed-thousand-separator", "mso-element", "mso-element-anchor-horizontal", "mso-element-anchor-lock", "mso-element-anchor-vertical", "mso-element-frame-height", "mso-element-frame-hspace", "mso-element-frame-vspace", "mso-element-frame-width", "mso-element-left", "mso-element-linespan", "mso-element-top", "mso-element-wrap", "mso-endnote-continuation-notice", "mso-endnote-continuation-notice-id", "mso-endnote-continuation-notice-src", "mso-endnote-continuation-separator", "mso-endnote-continuation-separator-id", "mso-endnote-continuation-separator-src", "mso-endnote-display", "mso-endnote-id", "mso-endnote-numbering", "mso-endnote-numbering-restart", "mso-endnote-numbering-start", "mso-endnote-numbering-style", "mso-endnote-position", "mso-endnote-separator", "mso-endnote-separator-id", "mso-endnote-separator-src", "mso-even-footer", "mso-even-footer-id", "mso-even-footer-src", "mso-even-header", "mso-even-header-id", "mso-even-header-src", "mso-facing-pages", "mso-fareast-font-family", "mso-fareast-hint", "mso-fareast-language", "mso-field-change", "mso-field-change-author", "mso-field-change-time", "mso-field-change-value", "mso-field-code", "mso-field-lock", "mso-fills-color", "mso-first-footer", "mso-first-footer-id", "mso-first-footer-src", "mso-first-header", "mso-first-header-id", "mso-first-header-src", "mso-font-alt", "mso-font-charset", "mso-font-format", "mso-font-info", "mso-font-info-charset", "mso-font-info-type", "mso-font-kerning", "mso-font-pitch", "mso-font-signature", "mso-font-signature-csb-one", "mso-font-signature-csb-two", "mso-font-signature-usb-four", "mso-font-signature-usb-one", "mso-font-signature-usb-three", "mso-font-signature-usb-two", "mso-font-src", "mso-font-width", "mso-footer", "mso-footer-data", "mso-footer-id", "mso-footer-margin", "mso-footer-src", "mso-footnote-continuation-notice", "mso-footnote-continuation-notice-id", "mso-footnote-continuation-notice-src", "mso-footnote-continuation-separator", "mso-footnote-continuation-separator-id", "mso-footnote-continuation-separator-src", "mso-footnote-id", "mso-footnote-numbering", "mso-footnote-numbering-restart", "mso-footnote-numbering-start", "mso-footnote-numbering-style", "mso-footnote-position", "mso-footnote-separator", "mso-footnote-separator-id", "mso-footnote-separator-src", "mso-foreground", "mso-forms-protection", "mso-generic-font-family", "mso-grid-bottom", "mso-grid-bottom-count", "mso-grid-left", "mso-grid-left-count", "mso-grid-right", "mso-grid-right-count", "mso-grid-top", "mso-grid-top-count", "mso-gutter-direction", "mso-gutter-margin", "mso-gutter-position", "mso-hansi-font-family", "mso-header", "mso-header-data", "mso-header-id", "mso-header-margin", "mso-header-src", "mso-height-alt", "mso-height-rule", "mso-height-source", "mso-hide", "mso-highlight", "mso-horizontal-page-align", "mso-hyphenate", "mso-ignore", "mso-kinsoku-overflow", "mso-layout-grid-align", "mso-layout-grid-char-alt", "mso-layout-grid-origin", "mso-level-inherit", "mso-level-legacy", "mso-level-legacy-indent", "mso-level-legacy-space", "mso-level-legal-format", "mso-level-number-format", "mso-level-number-position", "mso-level-numbering", "mso-level-reset-level", "mso-level-start-at", "mso-level-style-link", "mso-level-suffix", "mso-level-tab-stop", "mso-level-text", "mso-line-break-override", "mso-line-grid", "mso-line-height-alt", "mso-line-height-rule", "mso-line-numbers-count-by", "mso-line-numbers-distance", "mso-line-numbers-restart", "mso-line-numbers-start", "mso-line-spacing", "mso-linked-frame", "mso-list", "mso-list-change", "mso-list-change-author", "mso-list-change-time", "mso-list-change-values", "mso-list-id", "mso-list-ins", "mso-list-ins-author", "mso-list-ins-time", "mso-list-name", "mso-list-template-ids", "mso-list-type", "mso-margin-bottom-alt", "mso-margin-left-alt", "mso-margin-top-alt", "mso-mirror-margins", "mso-negative-indent-tab", "mso-number-format", "mso-outline-level", "mso-outline-parent", "mso-outline-parent-col", "mso-outline-parent-row", "mso-outline-parent-visibility", "mso-outline-style", "mso-padding-alt", "mso-padding-between", "mso-padding-bottom-alt", "mso-padding-left-alt", "mso-padding-right-alt", "mso-padding-top-alt", "mso-page-border-aligned", "mso-page-border-art", "mso-page-border-bottom-art", "mso-page-border-display", "mso-page-border-left-art", "mso-page-border-offset-from", "mso-page-border-right-art", "mso-page-border-surround-footer", "mso-page-border-surround-header", "mso-page-border-top-art", "mso-page-border-z-order", "mso-page-numbers", "mso-page-numbers-chapter-separator", "mso-page-numbers-chapter-style", "mso-page-numbers-start", "mso-page-numbers-style", "mso-page-orientation", "mso-page-scale", "mso-pagination", "mso-panose-arm-style", "mso-panose-contrast", "mso-panose-family-type", "mso-panose-letterform", "mso-panose-midline", "mso-panose-proportion", "mso-panose-serif-style", "mso-panose-stroke-variation", "mso-panose-weight", "mso-panose-x-height", "mso-paper-source", "mso-paper-source-first-page", "mso-paper-source-other-pages", "mso-pattern", "mso-pattern-color", "mso-pattern-style", "mso-print-area", "mso-print-color", "mso-print-gridlines", "mso-print-headings", "mso-print-resolution", "mso-print-sheet-order", "mso-print-title-column", "mso-print-title-row", "mso-prop-change", "mso-prop-change-author", "mso-prop-change-time", "mso-protection", "mso-rotate", "mso-row-margin-left", "mso-row-margin-right", "mso-ruby-merge", "mso-ruby-visibility", "mso-scheme-fill-color", "mso-scheme-shadow-color", "mso-shading", "mso-shadow-color", "mso-space-above", "mso-space-below", "mso-spacerun", "mso-special-character", "mso-special-format", "mso-style-id", "mso-style-name", "mso-style-next", "mso-style-parent", "mso-style-type", "mso-style-update", "mso-subdocument", "mso-symbol-font-family", "mso-tab-count", "mso-table-anchor-horizontal", "mso-table-anchor-vertical", "mso-table-bspace", "mso-table-del-author", "mso-table-del-time", "mso-table-deleted", "mso-table-dir", "mso-table-ins-author", "mso-table-ins-time", "mso-table-inserted", "mso-table-layout-alt", "mso-table-left", "mso-table-lspace", "mso-table-overlap", "mso-table-prop-author", "mso-table-prop-change", "mso-table-prop-time", "mso-table-rspace", "mso-table-top", "mso-table-tspace", "mso-table-wrap", "mso-text-animation", "mso-text-combine-brackets", "mso-text-combine-id", "mso-text-control", "mso-text-fit-id", "mso-text-indent-alt", "mso-text-orientation", "mso-text-raise", "mso-title-page", "mso-tny-compress", "mso-unsynced", "mso-vertical-align-alt", "mso-vertical-align-special", "mso-vertical-page-align", "mso-width-alt", "mso-width-source", "mso-word-wrap", "mso-xlrowspan", "mso-zero-height", "multiple", "muted", "name", "nav-banner-image", "navbutton_background_color", "navbutton_home_hovered", "navbutton_home_normal", "navbutton_home_pushed", "navbutton_horiz_hovered", "navbutton_horiz_normal", "navbutton_horiz_pushed", "navbutton_next_hovered", "navbutton_next_normal", "navbutton_next_pushed", "navbutton_prev_hovered", "navbutton_prev_normal", "navbutton_prev_pushed", "navbutton_up_hovered", "navbutton_up_normal", "navbutton_up_pushed", "navbutton_vert_hovered", "navbutton_vert_normal", "navbutton_vert_pushed", "nohref", "noresize", "noshade", "novalidate", "nowrap", "object", "onblur", "onchange", "onclick", "ondblclick", "onfocus", "onkeydown", "onkeypress", "onkeyup", "onload", "onmousedown", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onreset", "onselect", "onsubmit", "onunload", "open", "optimum", "overflow", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "panose-1", "pattern", "ping", "placeholder", "position", "poster", "preload", "profile", "prompt", "punctuation-trim", "punctuation-wrap", "radiogroup", "readonly", "referrerpolicy", "rel", "required", "rev", "reversed", "right", "row-span", "rows", "rowspan", "ruby-align", "ruby-overhang", "ruby-position", "rules", "sandbox", "scheme", "scope", "scoped", "scrolling", "selected", "separator-image", "shape", "size", "sizes", "slot", "span", "spellcheck", "src", "srcdoc", "srclang", "srcset", "standby", "start", "step", "style", "summary", "tab-interval", "tab-stops", "tabindex", "table-border-color-dark", "table-border-color-light", "table-layout", "target", "text", "text-align", "text-autospace", "text-combine", "text-decoration", "text-effect", "text-fit", "text-indent", "text-justify", "text-justify-trim", "text-kashida", "text-line-through", "text-shadow", "text-transform", "text-underline", "text-underline-color", "text-underline-style", "title", "top", "top-bar-button", "translate", "type", "unicode-bidi", "urlId", "usemap", "valign", "value", "valuetype", "version", "vert-align", "vertical-align", "visibility", "vlink", "vnd.ms-excel.numberformat", "vspace", "white-space", "width", "word-break", "word-spacing", "wrap", "xmlns", "z-index"]);

/**
 * is-char-suitable-for-html-attr-name
 * Is given character suitable to be in an HTML attribute's name?
 * Version: 2.0.8
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/is-char-suitable-for-html-attr-name/
 */
function isAttrNameChar(char) {
  return typeof char === "string" && (char.charCodeAt(0) > 96 && char.charCodeAt(0) < 123 || char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91 || char.charCodeAt(0) > 47 && char.charCodeAt(0) < 58 || char === ":" || char === "-");
}

/**
 * is-html-attribute-closing
 * Is a character on a given index a closing of an HTML attribute?
 * Version: 2.1.5
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/is-html-attribute-closing/
 */

function makeTheQuoteOpposite(quoteChar) {
  return quoteChar === "'" ? "\"" : "'";
}

function ensureXIsNotPresentBeforeOneOfY(str, startingIdx, x, y) {
  if (y === void 0) {
    y = [];
  }

  var _loop = function _loop(i, len) {
    if (y.some(function (oneOfStr) {
      return str.startsWith(oneOfStr, i);
    })) {
      return {
        v: true
      };
    }

    if (str[i] === x) {
      return {
        v: false
      };
    }
  };

  for (var i = startingIdx, len = str.length; i < len; i++) {
    var _ret = _loop(i);

    if (typeof _ret === "object") return _ret.v;
  }

  return true;
}

function xBeforeYOnTheRight$1(str, startingIdx, x, y) {
  for (var i = startingIdx, len = str.length; i < len; i++) {
    if (str.startsWith(x, i)) {
      return true;
    }

    if (str.startsWith(y, i)) {
      return false;
    }
  }

  return false;
}

function plausibleAttrStartsAtX(str, start) {
  if (!isAttrNameChar(str[start]) || !start) {
    return false;
  }

  var regex = /^[a-zA-Z0-9:-]*(\s*[=]?\s*((?:'[^']*')|(?:"[^"]*")))|( [^/>'"=]*['"])/;
  return regex.test(str.slice(start));
}

function guaranteedAttrStartsAtX(str, start) {
  if (!start || !isAttrNameChar(str[start])) {
    return false;
  }

  var regex = /^[a-zA-Z0-9:-]*=(((?:'[^']*')|(?:"[^"]*"))|((?:['"][^'"]*['"]\s*\/?>)))/;
  return regex.test(str.slice(start));
}

function findAttrNameCharsChunkOnTheLeft(str, i) {
  if (!isAttrNameChar(str[left(str, i)])) {
    return;
  }

  for (var y = i; y--;) {
    if (str[y].trim().length && !isAttrNameChar(str[y])) {
      return str.slice(y + 1, i);
    }
  }
}

function isAttrClosing(str, idxOfAttrOpening, isThisClosingIdx) {
  if (typeof str !== "string" || !str.trim() || !Number.isInteger(idxOfAttrOpening) || !Number.isInteger(isThisClosingIdx) || !str[idxOfAttrOpening] || !str[isThisClosingIdx] || idxOfAttrOpening >= isThisClosingIdx) {
    return false;
  }

  var openingQuote = "'\"".includes(str[idxOfAttrOpening]) ? str[idxOfAttrOpening] : null;
  var oppositeToOpeningQuote = null;

  if (openingQuote) {
    oppositeToOpeningQuote = makeTheQuoteOpposite(openingQuote);
  }

  var chunkStartsAt;
  var quotesCount = new Map().set("'", 0).set("\"", 0).set("matchedPairs", 0);
  var lastQuoteAt = null;
  var totalQuotesCount = 0;
  var lastQuoteWasMatched = false;
  var lastMatchedQuotesPairsStartIsAt;
  var lastMatchedQuotesPairsEndIsAt;
  var lastCapturedChunk;
  var secondLastCapturedChunk;
  var lastChunkWasCapturedAfterSuspectedClosing = false;
  var closingBracketMet = false;
  var openingBracketMet = false;

  for (var i = idxOfAttrOpening, len = str.length; i < len; i++) {
    if ("'\"".includes(str[i]) && lastQuoteWasMatched && lastMatchedQuotesPairsStartIsAt === idxOfAttrOpening && lastMatchedQuotesPairsEndIsAt !== undefined && lastMatchedQuotesPairsEndIsAt < i && i >= isThisClosingIdx) {
      var E1 = i !== isThisClosingIdx || guaranteedAttrStartsAtX(str, right(str, isThisClosingIdx)) || "/>".includes(str[right(str, i)]);
      var E2 = !(i > isThisClosingIdx && str[idxOfAttrOpening] === str[isThisClosingIdx] && str[idxOfAttrOpening] === str[i] && plausibleAttrStartsAtX(str, i + 1));
      var E31 = i === isThisClosingIdx && plausibleAttrStartsAtX(str, isThisClosingIdx + 1);
      var E32 = chunkStartsAt && chunkStartsAt < i && allHtmlAttribs.has(str.slice(chunkStartsAt, i).trim());

      if (chunkStartsAt) {
        str.slice(chunkStartsAt, i).trim();
      }

      var E33 = chunkStartsAt && chunkStartsAt < i && str[chunkStartsAt - 1] && !str[chunkStartsAt - 1].trim() && Array.from(str.slice(chunkStartsAt, i).trim()).every(function (char) {
        return isAttrNameChar(char);
      }) && str[idxOfAttrOpening] === str[isThisClosingIdx] && !"/>".includes(str[right(str, i)]) && ensureXIsNotPresentBeforeOneOfY(str, i + 1, "=", ["'", "\""]);
      var attrNameCharsChunkOnTheLeft = void 0;

      if (i === isThisClosingIdx) {
        attrNameCharsChunkOnTheLeft = findAttrNameCharsChunkOnTheLeft(str, i);
      }

      var E34 = i === isThisClosingIdx && (!isAttrNameChar(str[left(str, i)]) || attrNameCharsChunkOnTheLeft && !allHtmlAttribs.has(attrNameCharsChunkOnTheLeft)) && str[left(str, i)] !== "=";
      var E41 = "/>".includes(str[right(str, i)]) && i === isThisClosingIdx;
      var E42 = isAttrNameChar(str[right(str, i)]);
      var E43 = lastQuoteWasMatched && i !== isThisClosingIdx;
      var E5 = !(i >= isThisClosingIdx && str[left(str, isThisClosingIdx)] === ":");
      return !!(E1 && E2 && (E31 || E32 || E33 || E34) && (E41 || E42 || E43) && E5);
    }

    if ("'\"".includes(str[i])) {
      if (str[i] === "'" && str[i - 1] === "\"" && str[i + 1] === "\"" || str[i] === "\"" && str[i - 1] === "'" && str[i + 1] === "'") {
        continue;
      }

      if (lastQuoteAt && str[i] === str[lastQuoteAt]) {
        quotesCount.set("matchedPairs", quotesCount.get("matchedPairs") + 1);
        lastMatchedQuotesPairsStartIsAt = lastQuoteAt;
        lastMatchedQuotesPairsEndIsAt = i;
        lastQuoteAt = null;
        lastQuoteWasMatched = true;
      } else {
        lastQuoteWasMatched = false;
      }

      quotesCount.set(str[i], quotesCount.get(str[i]) + 1);
      totalQuotesCount = quotesCount.get("\"") + quotesCount.get("'");
    }

    if (str[i] === ">" && !closingBracketMet) {
      closingBracketMet = true;

      if (totalQuotesCount && quotesCount.get("matchedPairs") && totalQuotesCount === quotesCount.get("matchedPairs") * 2 && i < isThisClosingIdx) {
        return false;
      }
    }

    if (str[i] === "<" && str[right(str, i)] !== "%" && closingBracketMet && !openingBracketMet) {
      openingBracketMet = true;
      return false;
    }

    if (str[i].trim() && !chunkStartsAt) {
      if (isAttrNameChar(str[i])) {
        chunkStartsAt = i;
      }
    } else if (chunkStartsAt && !isAttrNameChar(str[i])) {
      secondLastCapturedChunk = lastCapturedChunk;
      lastCapturedChunk = str.slice(chunkStartsAt, i);
      lastChunkWasCapturedAfterSuspectedClosing = chunkStartsAt >= isThisClosingIdx;

      if ("'\"".includes(str[i]) && quotesCount.get("matchedPairs") === 0 && totalQuotesCount === 3 && str[idxOfAttrOpening] === str[i] && allHtmlAttribs.has(lastCapturedChunk) && !"'\"".includes(str[right(str, i)])) {
        var A1 = i > isThisClosingIdx;
        var A21 = !lastQuoteAt;
        var A22 = lastQuoteAt + 1 >= i;
        var A23 = str.slice(lastQuoteAt + 1, i).trim().split(/\s+/).every(function (chunk) {
          return allHtmlAttribs.has(chunk);
        });
        var A3 = !lastCapturedChunk || !secondLastCapturedChunk || !secondLastCapturedChunk.endsWith(":");
        var B1 = i === isThisClosingIdx;
        var B21 = totalQuotesCount < 3;
        var B22 = !!lastQuoteWasMatched;
        var B23 = !lastQuoteAt;
        var B24 = lastQuoteAt + 1 >= i;
        var B25 = !str.slice(lastQuoteAt + 1, i).trim().split(/\s+/).every(function (chunk) {
          return allHtmlAttribs.has(chunk);
        });
        return A1 && (A21 || A22 || A23) && A3 || B1 && (B21 || B22 || B23 || B24 || B25);
      }

      if (lastCapturedChunk && allHtmlAttribs.has(lastCapturedChunk) && lastMatchedQuotesPairsStartIsAt === idxOfAttrOpening && lastMatchedQuotesPairsEndIsAt === isThisClosingIdx) {
        return true;
      }
    }

    if ("'\"".includes(str[i]) && (!(quotesCount.get("\"") % 2) || !(quotesCount.get("'") % 2)) && (quotesCount.get("\"") + quotesCount.get("'")) % 2 && (lastCapturedChunk && allHtmlAttribs.has(lastCapturedChunk) || i > isThisClosingIdx + 1 && allHtmlAttribs.has(str.slice(isThisClosingIdx + 1, i).trim())) && !(str[i + 1] === str[i] && str[i] === str[idxOfAttrOpening]) && !(i > isThisClosingIdx + 1 && str[left(str, isThisClosingIdx)] === ":") && !(lastCapturedChunk && secondLastCapturedChunk && secondLastCapturedChunk.trim().endsWith(":"))) {
      var R0 = i > isThisClosingIdx;
      var R1 = !!openingQuote;
      var R2 = str[idxOfAttrOpening] !== str[isThisClosingIdx];
      var R3 = allHtmlAttribs.has(str.slice(idxOfAttrOpening + 1, isThisClosingIdx).trim());
      var R4 = !xBeforeYOnTheRight$1(str, i + 1, str[isThisClosingIdx], makeTheQuoteOpposite(str[isThisClosingIdx]));
      return R0 && !(R1 && R2 && R3 && R4);
    }

    if ((str[i] === "=" || !str[i].length && str[right(str, i)] === "=") && lastCapturedChunk && allHtmlAttribs.has(lastCapturedChunk)) {
      var W1 = i > isThisClosingIdx;
      var W2 = !(!(lastQuoteWasMatched && lastMatchedQuotesPairsStartIsAt === idxOfAttrOpening && lastMatchedQuotesPairsEndIsAt === isThisClosingIdx || guaranteedAttrStartsAtX(str, chunkStartsAt)) && lastQuoteWasMatched && lastMatchedQuotesPairsStartIsAt !== undefined && lastMatchedQuotesPairsStartIsAt <= isThisClosingIdx);
      return W1 && W2;
    }

    if (i > isThisClosingIdx) {
      if (openingQuote && str[i] === openingQuote) {
        var Y1 = !!lastQuoteAt;
        var Y2 = lastQuoteAt === isThisClosingIdx;
        var Y3 = lastQuoteAt + 1 < i && str.slice(lastQuoteAt + 1, i).trim();
        var Y4 = str.slice(lastQuoteAt + 1, i).trim().split(/\s+/).every(function (chunk) {
          return allHtmlAttribs.has(chunk);
        });
        var Y5 = i >= isThisClosingIdx;
        var Y6 = !str[right(str, i)] || !"'\"".includes(str[right(str, i)]);
        return !!(Y1 && Y2 && Y3 && Y4 && Y5 && Y6);
      }

      if (openingQuote && str[isThisClosingIdx] === oppositeToOpeningQuote && str[i] === oppositeToOpeningQuote) {
        return false;
      }

      if (str[i] === "/" || str[i] === ">" || str[i] === "<") {
        var _R = str[idxOfAttrOpening] === str[isThisClosingIdx] && lastQuoteAt === isThisClosingIdx && !str.slice(idxOfAttrOpening + 1, isThisClosingIdx).includes(str[idxOfAttrOpening]);

        var R11 = quotesCount.get("matchedPairs") < 2;

        var _attrNameCharsChunkOnTheLeft = findAttrNameCharsChunkOnTheLeft(str, i);

        var R12 = (!_attrNameCharsChunkOnTheLeft || !allHtmlAttribs.has(_attrNameCharsChunkOnTheLeft)) && (!(i > isThisClosingIdx && quotesCount.get("'") && quotesCount.get("\"") && quotesCount.get("matchedPairs") > 1) || "/>".includes(str[right(str, i)]));

        var _R2 = totalQuotesCount < 3 || quotesCount.get("\"") + quotesCount.get("'") - quotesCount.get("matchedPairs") * 2 !== 2;

        var R31 = !lastQuoteWasMatched || lastQuoteWasMatched && !(lastMatchedQuotesPairsStartIsAt !== undefined && Array.from(str.slice(idxOfAttrOpening + 1, lastMatchedQuotesPairsStartIsAt).trim()).every(function (char) {
          return isAttrNameChar(char);
        }) && allHtmlAttribs.has(str.slice(idxOfAttrOpening + 1, lastMatchedQuotesPairsStartIsAt).trim()));
        var R32 = !right(str, i) && totalQuotesCount % 2 === 0;
        var R33 = str[idxOfAttrOpening - 2] && str[idxOfAttrOpening - 1] === "=" && isAttrNameChar(str[idxOfAttrOpening - 2]);
        var R34 = !ensureXIsNotPresentBeforeOneOfY(str, i + 1, "<", ["='", "=\""]);
        return _R || (R11 || R12) && _R2 && (R31 || R32 || R33 || R34);
      }

      if (str[i] === "=" && matchRight(str, i, ["'", "\""], {
        trimBeforeMatching: true,
        trimCharsBeforeMatching: ["="]
      })) {
        return true;
      }
    } else {
      var firstNonWhitespaceCharOnTheLeft = void 0;

      if (str[i - 1] && str[i - 1].trim() && str[i - 1] !== "=") {
        firstNonWhitespaceCharOnTheLeft = i - 1;
      } else {
        for (var y = i; y--;) {
          if (str[y].trim() && str[y] !== "=") {
            firstNonWhitespaceCharOnTheLeft = y;
            break;
          }
        }
      }

      if (str[i] === "=" && matchRight(str, i, ["'", "\""], {
        cb: function cb(char) {
          return !"/>".includes(char);
        },
        trimBeforeMatching: true,
        trimCharsBeforeMatching: ["="]
      }) && isAttrNameChar(str[firstNonWhitespaceCharOnTheLeft]) && !str.slice(idxOfAttrOpening + 1).startsWith("http") && !str.slice(idxOfAttrOpening + 1, i).includes("/") && !str.endsWith("src=", idxOfAttrOpening) && !str.endsWith("href=", idxOfAttrOpening)) {
        return false;
      }

      if (i === isThisClosingIdx && guaranteedAttrStartsAtX(str, i + 1)) {
        return true;
      }

      if (i < isThisClosingIdx && "'\"".includes(str[i]) && lastCapturedChunk && str[left(str, idxOfAttrOpening)] && str[left(str, idxOfAttrOpening)] !== "=" && lastMatchedQuotesPairsStartIsAt === idxOfAttrOpening && allHtmlAttribs.has(lastCapturedChunk)) {
        return false;
      }

      if (i === isThisClosingIdx && "'\"".includes(str[i]) && lastCapturedChunk && secondLastCapturedChunk && totalQuotesCount % 2 === 0 && secondLastCapturedChunk.endsWith(":")) {
        return true;
      }
    }

    if ("'\"".includes(str[i]) && i > isThisClosingIdx) {
      if (!lastChunkWasCapturedAfterSuspectedClosing || !lastCapturedChunk || !allHtmlAttribs.has(lastCapturedChunk)) {
        return false;
      }

      return true;
    }

    if ("'\"".includes(str[i])) {
      lastQuoteAt = i;
    }

    if (chunkStartsAt && !isAttrNameChar(str[i])) {
      chunkStartsAt = null;
    }
  }

  return false;
}

var defaultOpts$1 = {
  allowCustomTagNames: false,
  skipOpeningBracket: false
};
var BACKSLASH$6 = "\\";
var knownHtmlTags = ["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "doctype", "dt", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h1 - h6", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "math", "menu", "menuitem", "meta", "meter", "nav", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "slot", "small", "source", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xml"];

function isNotLetter(char) {
  return char === undefined || char.toUpperCase() === char.toLowerCase() && !/\d/.test(char) && char !== "=";
}

function extraRequirements(str, idx) {
  return str[idx] === "<" || str[left(str, idx)] === "<";
}

function isOpening(str, idx, originalOpts) {
  if (idx === void 0) {
    idx = 0;
  }

  if (typeof str !== "string") {
    throw new Error("is-html-tag-opening: [THROW_ID_01] the first input argument should have been a string but it was given as \"" + typeof str + "\", value being " + JSON.stringify(str, null, 4));
  }

  if (!Number.isInteger(idx) || idx < 0) {
    throw new Error("is-html-tag-opening: [THROW_ID_02] the second input argument should have been a natural number string index but it was given as \"" + typeof idx + "\", value being " + JSON.stringify(idx, null, 4));
  }

  var opts = _objectSpread2(_objectSpread2({}, defaultOpts$1), originalOpts);

  var whitespaceChunk = "[\\\\ \\t\\r\\n/]*";
  var generalChar = "._a-z0-9\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\uFFFF";
  var r1 = new RegExp("^<" + (opts.skipOpeningBracket ? "?" : "") + whitespaceChunk + "\\w+" + whitespaceChunk + "\\/?" + whitespaceChunk + ">", "g");
  var r5 = new RegExp("^<" + (opts.skipOpeningBracket ? "?" : "") + whitespaceChunk + "[" + generalChar + "]+[-" + generalChar + "]*" + whitespaceChunk + ">", "g");
  var r2 = new RegExp("^<" + (opts.skipOpeningBracket ? "?" : "") + "\\s*\\w+\\s+\\w+(?:-\\w+)?\\s*=\\s*['\"\\w]", "g");
  var r6 = new RegExp("^<" + (opts.skipOpeningBracket ? "?" : "") + "\\s*\\w+\\s+[" + generalChar + "]+[-" + generalChar + "]*(?:-\\w+)?\\s*=\\s*['\"\\w]");
  var r3 = new RegExp("^<" + (opts.skipOpeningBracket ? "?" : "") + "\\s*\\/?\\s*\\w+\\s*\\/?\\s*>", "g");
  var r7 = new RegExp("^<" + (opts.skipOpeningBracket ? "?" : "") + "\\s*\\/?\\s*[" + generalChar + "]+[-" + generalChar + "]*\\s*\\/?\\s*>", "g");
  var r4 = new RegExp("^<" + (opts.skipOpeningBracket ? "?" : "") + whitespaceChunk + "\\w+(?:\\s*\\w+)?\\s*\\w+=['\"]", "g");
  var r8 = new RegExp("^<" + (opts.skipOpeningBracket ? "?" : "") + whitespaceChunk + "[" + generalChar + "]+[-" + generalChar + "]*\\s+(?:\\s*\\w+)?\\s*\\w+=['\"]", "g");
  var r9 = new RegExp("^<" + (opts.skipOpeningBracket ? "?\\/?" : "") + "(" + whitespaceChunk + "[" + generalChar + "]+)+" + whitespaceChunk + "[\\\\/=>]", "");
  var r10 = new RegExp("^\\/\\s*\\w+s*>");
  var whatToTest = idx ? str.slice(idx) : str;
  var leftSideIdx = left(str, idx);
  var qualified = false;
  var passed = false;
  var matchingOptions = {
    cb: isNotLetter,
    i: true,
    trimCharsBeforeMatching: ["/", BACKSLASH$6, "!", " ", "\t", "\n", "\r"]
  };

  if (opts.allowCustomTagNames) {
    if ((opts.skipOpeningBracket && (str[idx - 1] === "<" || str[idx - 1] === "/" && str[left(str, leftSideIdx)] === "<") || whatToTest[0] === "<" && whatToTest[1] && whatToTest[1].trim()) && (r9.test(whatToTest) || /^<\w+$/.test(whatToTest))) {
      passed = true;
    } else if (r5.test(whatToTest) && extraRequirements(str, idx)) {
      passed = true;
    } else if (r6.test(whatToTest)) {
      passed = true;
    } else if (r7.test(whatToTest) && extraRequirements(str, idx)) {
      passed = true;
    } else if (r8.test(whatToTest)) {
      passed = true;
    } else if (str[idx] === "/" && str[leftSideIdx] !== "<" && r10.test(whatToTest)) {
      passed = true;
    }
  } else {
    if ((opts.skipOpeningBracket && (str[idx - 1] === "<" || str[idx - 1] === "/" && str[left(str, leftSideIdx)] === "<") || (whatToTest[0] === "<" || whatToTest[0] === "/" && (!str[leftSideIdx] || str[leftSideIdx] !== "<")) && whatToTest[1] && whatToTest[1].trim()) && r9.test(whatToTest)) {
      qualified = true;
    } else if (r1.test(whatToTest) && extraRequirements(str, idx)) {
      qualified = true;
    } else if (r2.test(whatToTest)) {
      qualified = true;
    } else if (r3.test(whatToTest) && extraRequirements(str, idx)) {
      qualified = true;
    } else if (r4.test(whatToTest)) {
      qualified = true;
    }

    if (qualified && matchRightIncl(str, idx, knownHtmlTags, {
      cb: function cb(char) {
        if (char === undefined) {
          if (str[idx] === "<" && str[idx + 1] && str[idx + 1].trim() || str[idx - 1] === "<") {
            passed = true;
          }

          return true;
        }

        return char.toUpperCase() === char.toLowerCase() && !/\d/.test(char) && char !== "=";
      },
      i: true,
      trimCharsBeforeMatching: ["<", "/", BACKSLASH$6, "!", " ", "\t", "\n", "\r"]
    })) {
      passed = true;
    }
  }

  if (!passed && str[idx] === "<" && str[idx + 1] && str[idx + 1].trim() && matchRight(str, idx, knownHtmlTags, matchingOptions)) {
    passed = true;
  }

  var res = typeof str === "string" && idx < str.length && passed;
  return res;
}

var allHTMLTagsKnownToHumanity = new Set(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]);
var espChars = "{}%-$_()*|#";
var veryEspChars = "{}|#";
var notVeryEspChars = "%()$_*#";
var leftyChars = "({";
var rightyChars = "})";
var espLumpBlacklist = [")|(", "|(", ")(", "()", "}{", "{}", "%)", "*)", "||", "--"];
var punctuationChars = ".,;!?";
var BACKTICK = "\x60";
var LEFTDOUBLEQUOTMARK = "\u201C";
var RIGHTDOUBLEQUOTMARK = "\u201D";

function isLatinLetter(char) {
  return !!(char && (char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91 || char.charCodeAt(0) > 96 && char.charCodeAt(0) < 123));
}

function charSuitableForTagName(char) {
  return /[.\-_a-z0-9\u00B7\u00C0-\uFFFD]/i.test(char);
}

function flipEspTag(str) {
  var res = "";

  for (var i = 0, len = str.length; i < len; i++) {
    if (str[i] === "[") {
      res = "]" + res;
    } else if (str[i] === "]") {
      res = "[" + res;
    } else if (str[i] === "{") {
      res = "}" + res;
    } else if (str[i] === "}") {
      res = "{" + res;
    } else if (str[i] === "(") {
      res = ")" + res;
    } else if (str[i] === ")") {
      res = "(" + res;
    } else if (str[i] === "<") {
      res = ">" + res;
    } else if (str[i] === ">") {
      res = "<" + res;
    } else if (str[i] === LEFTDOUBLEQUOTMARK) {
      res = "" + RIGHTDOUBLEQUOTMARK + res;
    } else if (str[i] === RIGHTDOUBLEQUOTMARK) {
      res = "" + LEFTDOUBLEQUOTMARK + res;
    } else {
      res = "" + str[i] + res;
    }
  }

  return res;
}

function isTagNameRecognised(tagName) {
  return allHTMLTagsKnownToHumanity.has(tagName.toLowerCase()) || ["doctype", "cdata", "xml"].includes(tagName.toLowerCase());
}

function xBeforeYOnTheRight(str, startingIdx, x, y) {
  for (var i = startingIdx, len = str.length; i < len; i++) {
    if (str.startsWith(x, i)) {
      return true;
    }

    if (str.startsWith(y, i)) {
      return false;
    }
  }

  return false;
}

function isObj$2(something) {
  return something && typeof something === "object" && !Array.isArray(something);
}

var voidTags = ["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"];
var inlineTags = new Set(["a", "abbr", "acronym", "audio", "b", "bdi", "bdo", "big", "br", "button", "canvas", "cite", "code", "data", "datalist", "del", "dfn", "em", "embed", "i", "iframe", "img", "input", "ins", "kbd", "label", "map", "mark", "meter", "noscript", "object", "output", "picture", "progress", "q", "ruby", "s", "samp", "script", "select", "slot", "small", "span", "strong", "sub", "sup", "svg", "template", "textarea", "time", "u", "tt", "var", "video", "wbr"]);
var charsThatEndCSSChunks = ["{", "}", ","];
var SOMEQUOTE = "'\"" + LEFTDOUBLEQUOTMARK + RIGHTDOUBLEQUOTMARK;
var attrNameRegexp = /[\w-]/;

function getLastEspLayerObjIdx(layers) {
  if (layers && layers.length) {
    for (var z = layers.length; z--;) {
      if (layers[z].type === "esp") {
        return z;
      }
    }
  }

  return undefined;
}

function getWholeEspTagLumpOnTheRight(str, i, layers) {
  var wholeEspTagLumpOnTheRight = str[i];
  var len = str.length;
  var lastEspLayerObj = layers[getLastEspLayerObjIdx(layers)];

  for (var y = i + 1; y < len; y++) {
    if (leftyChars.includes(str[y]) && rightyChars.includes(str[y - 1])) {
      break;
    }

    if (wholeEspTagLumpOnTheRight.length > 1 && (wholeEspTagLumpOnTheRight.includes("<") || wholeEspTagLumpOnTheRight.includes("{") || wholeEspTagLumpOnTheRight.includes("[") || wholeEspTagLumpOnTheRight.includes("(")) && str[y] === "(") {
      break;
    }

    if (espChars.includes(str[y]) || lastEspLayerObj && lastEspLayerObj.guessedClosingLump.includes(str[y]) || str[i] === "<" && str[y] === "/" || str[y] === ">" && wholeEspTagLumpOnTheRight === "--" && Array.isArray(layers) && layers.length && layers[layers.length - 1].type === "esp" && layers[layers.length - 1].openingLump[0] === "<" && layers[layers.length - 1].openingLump[2] === "-" && layers[layers.length - 1].openingLump[3] === "-" || !lastEspLayerObj && y > i && "!=@".includes(str[y])) {
      wholeEspTagLumpOnTheRight += str[y];
    } else {
      break;
    }
  }

  if (wholeEspTagLumpOnTheRight && Array.isArray(layers) && layers.length && layers[layers.length - 1].type === "esp" && layers[layers.length - 1].guessedClosingLump && wholeEspTagLumpOnTheRight.length > layers[layers.length - 1].guessedClosingLump.length) {
    if (wholeEspTagLumpOnTheRight.endsWith(layers[layers.length - 1].openingLump)) {
      return wholeEspTagLumpOnTheRight.slice(0, wholeEspTagLumpOnTheRight.length - layers[layers.length - 1].openingLump.length);
    }

    var uniqueCharsListFromGuessedClosingLumpArr = new Set(layers[layers.length - 1].guessedClosingLump);
    var found = 0;

    var _loop = function _loop(len2, _y) {
      if (!uniqueCharsListFromGuessedClosingLumpArr.has(wholeEspTagLumpOnTheRight[_y]) && found > 1) {
        return {
          v: wholeEspTagLumpOnTheRight.slice(0, _y)
        };
      }

      if (uniqueCharsListFromGuessedClosingLumpArr.has(wholeEspTagLumpOnTheRight[_y])) {
        found += 1;
        uniqueCharsListFromGuessedClosingLumpArr = new Set([].concat(uniqueCharsListFromGuessedClosingLumpArr).filter(function (el) {
          return el !== wholeEspTagLumpOnTheRight[_y];
        }));
      }
    };

    for (var _y = 0, len2 = wholeEspTagLumpOnTheRight.length; _y < len2; _y++) {
      var _ret = _loop(len2, _y);

      if (typeof _ret === "object") return _ret.v;
    }
  }

  return wholeEspTagLumpOnTheRight;
}

function startsHtmlComment(str, i, token, layers) {
  return !!(str[i] === "<" && (matchRight(str, i, ["!--"], {
    maxMismatches: 1,
    firstMustMatch: true,
    trimBeforeMatching: true
  }) || matchRightIncl(str, i, ["<![endif]"], {
    i: true,
    maxMismatches: 2,
    trimBeforeMatching: true
  })) && !matchRight(str, i, ["![cdata", "<"], {
    i: true,
    maxMismatches: 1,
    trimBeforeMatching: true
  }) && (token.type !== "comment" || token.kind !== "not") || str[i] === "-" && matchRightIncl(str, i, ["-->"], {
    trimBeforeMatching: true
  }) && (token.type !== "comment" || !token.closing && token.kind !== "not") && !matchLeft(str, i, "<", {
    trimBeforeMatching: true,
    trimCharsBeforeMatching: ["-", "!"]
  }) && (!Array.isArray(layers) || !layers.length || layers[layers.length - 1].type !== "esp" || !(layers[layers.length - 1].openingLump[0] === "<" && layers[layers.length - 1].openingLump[2] === "-" && layers[layers.length - 1].openingLump[3] === "-")));
}

function startsCssComment(str, i, _token, _layers, withinStyle) {
  return withinStyle && (str[i] === "/" && str[i + 1] === "*" || str[i] === "*" && str[i + 1] === "/");
}

function matchLayerLast(wholeEspTagLump, layers, matchFirstInstead) {
  if (matchFirstInstead === void 0) {
    matchFirstInstead = false;
  }

  if (!layers.length) {
    return;
  }

  var whichLayerToMatch = matchFirstInstead ? layers[0] : layers[layers.length - 1];

  if (whichLayerToMatch.type !== "esp") {
    return;
  }

  if (wholeEspTagLump.includes(whichLayerToMatch.guessedClosingLump) || Array.from(wholeEspTagLump).every(function (char) {
    return whichLayerToMatch.guessedClosingLump.includes(char);
  }) || whichLayerToMatch.guessedClosingLump && whichLayerToMatch.guessedClosingLump.length > 2 && whichLayerToMatch.guessedClosingLump[whichLayerToMatch.guessedClosingLump.length - 1] === wholeEspTagLump[wholeEspTagLump.length - 1] && whichLayerToMatch.guessedClosingLump[whichLayerToMatch.guessedClosingLump.length - 2] === wholeEspTagLump[wholeEspTagLump.length - 2]) {
    return wholeEspTagLump.length;
  }
}

var BACKSLASH$5 = "\\";

function startsTag(str, i, token, layers, withinStyle, leftVal, rightVal) {
  return !!(str[i] && str[i].trim().length && (!layers.length || token.type === "text") && (!token.kind || !["doctype", "xml"].includes(token.kind)) && (!withinStyle || str[i] === "<") && (str[i] === "<" && (isOpening(str, i, {
    allowCustomTagNames: true
  }) || str[rightVal] === ">" || matchRight(str, i, ["doctype", "xml", "cdata"], {
    i: true,
    trimBeforeMatching: true,
    trimCharsBeforeMatching: ["?", "!", "[", " ", "-"]
  })) || str[i] === "/" && isLatinLetter(str[i + 1]) && str[leftVal] !== "<" && isOpening(str, i, {
    allowCustomTagNames: true,
    skipOpeningBracket: true
  }) || isLatinLetter(str[i]) && (!str[i - 1] || !isLatinLetter(str[i - 1]) && !["<", "/", "!", BACKSLASH$5].includes(str[leftVal])) && isOpening(str, i, {
    allowCustomTagNames: false,
    skipOpeningBracket: true
  })) && (token.type !== "esp" || token.tail && token.tail.includes(str[i])));
}

function startsEsp(str, i, token, layers, withinStyle) {
  var res = espChars.includes(str[i]) && str[i + 1] && espChars.includes(str[i + 1]) && !(notVeryEspChars.includes(str[i]) && notVeryEspChars.includes(str[i + 1])) && (str[i] !== str[i + 1] || veryEspChars.includes(str[i])) && token.type !== "rule" && token.type !== "at" && !(str[i] === "-" && "-{(".includes(str[i + 1])) && !("})".includes(str[i]) && "-".includes(str[i + 1])) && !(str[i] === "%" && str[i + 1] === "%" && "0123456789".includes(str[i - 1]) && (!str[i + 2] || punctuationChars.includes(str[i + 2]) || !str[i + 2].trim().length)) && !(withinStyle && ("{}".includes(str[i]) || "{}".includes(str[right(str, i)]))) || str[i] === "<" && (str[i + 1] === "/" && espChars.includes(str[i + 2]) || espChars.includes(str[i + 1]) && !["-"].includes(str[i + 1])) || str[i] === "<" && (str[i + 1] === "%" || str.startsWith("jsp:", i + 1) || str.startsWith("cms:", i + 1) || str.startsWith("c:", i + 1)) || str.startsWith("${jspProp", i) || ">})".includes(str[i]) && Array.isArray(layers) && layers.length && layers[layers.length - 1].type === "esp" && layers[layers.length - 1].openingLump.includes(flipEspTag(str[i])) && (str[i] !== ">" || !xBeforeYOnTheRight(str, i + 1, ">", "<")) || str[i] === "-" && str[i + 1] === "-" && str[i + 2] === ">" && Array.isArray(layers) && layers.length && layers[layers.length - 1].type === "esp" && layers[layers.length - 1].openingLump[0] === "<" && layers[layers.length - 1].openingLump[2] === "-" && layers[layers.length - 1].openingLump[3] === "-";
  return !!res;
}
var importantStartsRegexp = /^\s*!?\s*[a-zA-Z0-9]+(?:[\s;}<>'"]|$)/gm;
var defaults$7 = {
  tagCb: null,
  tagCbLookahead: 0,
  charCb: null,
  charCbLookahead: 0,
  reportProgressFunc: null,
  reportProgressFuncFrom: 0,
  reportProgressFuncTo: 100
};

function tokenizer(str, originalOpts) {
  var start = Date.now();

  if (typeof str !== "string") {
    if (str === undefined) {
      throw new Error("codsen-tokenizer: [THROW_ID_01] the first input argument is completely missing! It should be given as string.");
    } else {
      throw new Error("codsen-tokenizer: [THROW_ID_02] the first input argument must be string! It was given as \"" + typeof str + "\", equal to:\n" + JSON.stringify(str, null, 4));
    }
  }

  if (originalOpts && !isObj$2(originalOpts)) {
    throw new Error("codsen-tokenizer: [THROW_ID_03] the second input argument, an options object, should be a plain object but it was given as type " + typeof originalOpts + ", equal to " + JSON.stringify(originalOpts, null, 4));
  }

  if (originalOpts && isObj$2(originalOpts) && originalOpts.tagCb && typeof originalOpts.tagCb !== "function") {
    throw new Error("codsen-tokenizer: [THROW_ID_04] the opts.tagCb, callback function, should be a function but it was given as type " + typeof originalOpts.tagCb + ", equal to " + JSON.stringify(originalOpts.tagCb, null, 4));
  }

  if (originalOpts && isObj$2(originalOpts) && originalOpts.charCb && typeof originalOpts.charCb !== "function") {
    throw new Error("codsen-tokenizer: [THROW_ID_05] the opts.charCb, callback function, should be a function but it was given as type " + typeof originalOpts.charCb + ", equal to " + JSON.stringify(originalOpts.charCb, null, 4));
  }

  if (originalOpts && isObj$2(originalOpts) && originalOpts.reportProgressFunc && typeof originalOpts.reportProgressFunc !== "function") {
    throw new Error("codsen-tokenizer: [THROW_ID_06] the opts.reportProgressFunc, callback function, should be a function but it was given as type " + typeof originalOpts.reportProgressFunc + ", equal to " + JSON.stringify(originalOpts.reportProgressFunc, null, 4));
  }

  var opts = _objectSpread2(_objectSpread2({}, defaults$7), originalOpts);

  var currentPercentageDone = 0;
  var lastPercentage = 0;
  var len = str.length;
  var midLen = Math.floor(len / 2);
  var doNothing = 0;
  var withinScript = false;
  var withinStyle = false;
  var withinStyleComment = false;
  var tagStash = [];
  var charStash = [];
  var token = {};

  function tokenReset() {
    token = {
      type: null,
      start: null,
      end: null,
      value: null
    };
    attribReset();
  }

  var attribDefaults = {
    attribName: "",
    attribNameRecognised: false,
    attribNameStartsAt: null,
    attribNameEndsAt: null,
    attribOpeningQuoteAt: null,
    attribClosingQuoteAt: null,
    attribValueRaw: null,
    attribValue: [],
    attribValueStartsAt: null,
    attribValueEndsAt: null,
    attribStarts: null,
    attribEnds: null,
    attribLeft: null
  };

  var attrib = _objectSpread2({}, attribDefaults);

  function attribReset() {
    attrib = lodash_clonedeep(attribDefaults);
  }

  function attribPush(tokenObj) {
    /* istanbul ignore else */
    if (attrib.attribValue.length && attrib.attribValue[~-attrib.attribValue.length].start && !attrib.attribValue[~-attrib.attribValue.length].end) {
      attrib.attribValue[~-attrib.attribValue.length].end = tokenObj.start;
      attrib.attribValue[~-attrib.attribValue.length].value = str.slice(attrib.attribValue[~-attrib.attribValue.length].start, tokenObj.start);
    }

    attrib.attribValue.push(tokenObj);
  }

  var propertyDefault = {
    start: null,
    end: null,
    property: null,
    propertyStarts: null,
    propertyEnds: null,
    value: null,
    valueStarts: null,
    valueEnds: null,
    important: null,
    importantStarts: null,
    importantEnds: null,
    colon: null,
    semi: null
  };

  var property = _objectSpread2({}, propertyDefault);

  function propertyReset() {
    property = _objectSpread2({}, propertyDefault);
  }

  function pushProperty(p) {
    if (attrib && attrib.attribName === "style") {
      attrib.attribValue.push(_objectSpread2({}, p));
    } else if (token && Array.isArray(token.properties)) {
      token.properties.push(_objectSpread2({}, p));
    }
  }

  tokenReset();
  var selectorChunkStartedAt;
  var parentTokenToBackup;
  var attribToBackup;
  var lastNonWhitespaceCharAt = null;
  var layers = [];

  function lastLayerIs(something) {
    return !!(Array.isArray(layers) && layers.length && layers[~-layers.length].type === something);
  }

  function closingComment(i) {
    var end = (right(str, i) || i) + 1;
    attribPush({
      type: "comment",
      start: i,
      end: end,
      value: str.slice(i, end),
      closing: true,
      kind: "block",
      language: "css"
    });
    doNothing = end;

    if (lastLayerIs("block")) {
      layers.pop();
    }
  }

  function reportFirstFromStash(stash, cb, lookaheadLength) {
    var currentElem = stash.shift();
    var next = [];

    for (var i = 0; i < lookaheadLength; i++) {
      if (stash[i]) {
        next.push(lodash_clonedeep(stash[i]));
      } else {
        break;
      }
    }

    if (typeof cb === "function") {
      cb(currentElem, next);
    }
  }

  function pingCharCb(incomingToken) {
    if (opts.charCb) {
      charStash.push(incomingToken);

      if (charStash.length > opts.charCbLookahead) {
        reportFirstFromStash(charStash, opts.charCb, opts.charCbLookahead);
      }
    }
  }

  function pingTagCb(incomingToken) {
    if (opts.tagCb) {
      tagStash.push(incomingToken);

      if (tagStash.length > opts.tagCbLookahead) {
        reportFirstFromStash(tagStash, opts.tagCb, opts.tagCbLookahead);
      }
    }
  }

  function dumpCurrentToken(incomingToken, i) {
    if (!["text", "esp"].includes(incomingToken.type) && incomingToken.start !== null && incomingToken.start < i && (str[~-i] && !str[~-i].trim() || str[i] === "<")) {
      if (left(str, i) !== null) {
        incomingToken.end = left(str, i) + 1;
      } else {
        incomingToken.end = i;
      }

      incomingToken.value = str.slice(incomingToken.start, incomingToken.end);

      if (incomingToken.type === "tag" && !"/>".includes(str[~-incomingToken.end])) {
        var cutOffIndex = incomingToken.tagNameEndsAt || i;

        if (Array.isArray(incomingToken.attribs) && incomingToken.attribs.length) {
          for (var i2 = 0, len2 = incomingToken.attribs.length; i2 < len2; i2++) {
            if (incomingToken.attribs[i2].attribNameRecognised && incomingToken.attribs[i2].attribEnds) {
              cutOffIndex = incomingToken.attribs[i2].attribEnds;

              if (str[cutOffIndex + 1] && !str[cutOffIndex].trim() && str[cutOffIndex + 1].trim()) {
                cutOffIndex += 1;
              }
            } else {
              if (i2 === 0) {
                incomingToken.attribs = [];
              } else {
                incomingToken.attribs = incomingToken.attribs.splice(0, i2);
              }

              break;
            }
          }
        }

        incomingToken.end = cutOffIndex;
        incomingToken.value = str.slice(incomingToken.start, incomingToken.end);

        if (!incomingToken.tagNameEndsAt) {
          incomingToken.tagNameEndsAt = cutOffIndex;
        }

        if (incomingToken.tagNameStartsAt && incomingToken.tagNameEndsAt && !incomingToken.tagName) {
          incomingToken.tagName = str.slice(incomingToken.tagNameStartsAt, cutOffIndex);
          incomingToken.recognised = isTagNameRecognised(incomingToken.tagName);
        }

        pingTagCb(incomingToken);
        initToken("text", cutOffIndex);
      } else {
        pingTagCb(incomingToken);
        tokenReset();

        if (str[~-i] && !str[~-i].trim()) {
          initToken("text", left(str, i) + 1);
        }
      }
    }

    if (token.start !== null) {
      if (token.end === null && token.start !== i) {
        token.end = i;
        token.value = str.slice(token.start, token.end);
      }

      if (token.start !== null && token.end) {
        if (lastLayerIs("at")) {
          layers[~-layers.length].token.rules.push(token);
        } else {
          pingTagCb(token);
        }
      }

      tokenReset();
    }
  }

  function atRuleWaitingForClosingCurlie() {
    return lastLayerIs("at") && isObj$2(layers[~-layers.length].token) && layers[~-layers.length].token.openingCurlyAt && !layers[~-layers.length].token.closingCurlyAt;
  }

  function getNewToken(type, startVal) {
    if (startVal === void 0) {
      startVal = null;
    }

    if (type === "tag") {
      return {
        type: type,
        start: startVal,
        end: null,
        value: null,
        tagNameStartsAt: null,
        tagNameEndsAt: null,
        tagName: null,
        recognised: null,
        closing: false,
        void: false,
        pureHTML: true,
        kind: null,
        attribs: []
      };
    }

    if (type === "comment") {
      return {
        type: type,
        start: startVal,
        end: null,
        value: null,
        closing: false,
        kind: "simple",
        language: "html"
      };
    }

    if (type === "rule") {
      return {
        type: type,
        start: startVal,
        end: null,
        value: null,
        left: null,
        nested: false,
        openingCurlyAt: null,
        closingCurlyAt: null,
        selectorsStart: null,
        selectorsEnd: null,
        selectors: [],
        properties: []
      };
    }

    if (type === "at") {
      return {
        type: type,
        start: startVal,
        end: null,
        value: null,
        left: null,
        nested: false,
        openingCurlyAt: null,
        closingCurlyAt: null,
        identifier: null,
        identifierStartsAt: null,
        identifierEndsAt: null,
        query: null,
        queryStartsAt: null,
        queryEndsAt: null,
        rules: []
      };
    }

    if (type === "esp") {
      return {
        type: type,
        start: startVal,
        end: null,
        value: null,
        head: null,
        headStartsAt: null,
        headEndsAt: null,
        tail: null,
        tailStartsAt: null,
        tailEndsAt: null
      };
    }

    return {
      type: "text",
      start: startVal,
      end: null,
      value: null
    };
  }

  function initToken(type, startVal) {
    attribReset();
    token = getNewToken(type, startVal);
  }

  function initProperty(propertyStarts) {
    propertyReset();

    if (typeof propertyStarts === "number") {
      property.propertyStarts = propertyStarts;
      property.start = propertyStarts;
    } else {
      property = _objectSpread2(_objectSpread2({}, propertyDefault), propertyStarts);
    }
  }

  function ifQuoteThenAttrClosingQuote(idx) {
    return !"'\"".includes(str[idx]) || !(attrib.attribOpeningQuoteAt || attrib.attribValueStartsAt) || isAttrClosing(str, attrib.attribOpeningQuoteAt || attrib.attribValueStartsAt, idx);
  }

  function attrEndsAt(idx) {
    return ";}/".includes(str[idx]) && (!attrib || !attrib.attribName || attrib.attribName !== "style") || "/;'\"><".includes(str[idx]) && attrib && attrib.attribName === "style" && ifQuoteThenAttrClosingQuote(idx);
  }

  var _loop2 = function _loop2(_i) {
    if (!doNothing && str[_i] && opts.reportProgressFunc) {
      if (len > 1000 && len < 2000) {
        if (_i === midLen) {
          opts.reportProgressFunc(Math.floor((opts.reportProgressFuncTo - opts.reportProgressFuncFrom) / 2));
        }
      } else if (len >= 2000) {
        currentPercentageDone = opts.reportProgressFuncFrom + Math.floor(_i / len * (opts.reportProgressFuncTo - opts.reportProgressFuncFrom));

        if (currentPercentageDone !== lastPercentage) {
          lastPercentage = currentPercentageDone;
          opts.reportProgressFunc(currentPercentageDone);
        }
      }
    }

    var leftVal = left(str, _i);
    var rightVal = right(str, _i);

    if (withinStyle && token.type && !["rule", "at", "text", "comment"].includes(token.type)) {
      withinStyle = false;
    }

    if (doNothing && _i >= doNothing) {
      doNothing = 0;
    }

    if (isLatinLetter(str[_i]) && isLatinLetter(str[~-_i]) && isLatinLetter(str[_i + 1])) {
      if (property && property.valueStarts && !property.valueEnds && !property.importantStarts && str.startsWith("important", _i)) {
        property.valueEnds = _i;
        property.value = str.slice(property.valueStarts, _i);
        property.importantStarts = _i;
      }

      i = _i;
      return "continue";
    }

    if (" \t\r\n".includes(str[_i]) && str[_i] === str[~-_i] && str[_i] === str[_i + 1]) {
      i = _i;
      return "continue";
    }

    if (!doNothing && atRuleWaitingForClosingCurlie()) {
      if (str[_i] === "}") {
        if (!token.type || token.type === "text" || token.type === "rule" && token.openingCurlyAt === null) {
          if (token.type === "rule") {
            token.end = leftVal + 1;
            token.value = str.slice(token.start, token.end);
            pingTagCb(token);

            if (lastLayerIs("at")) {
              layers[~-layers.length].token.rules.push(token);
            }

            tokenReset();

            if (leftVal !== null && leftVal < ~-_i) {
              initToken("text", leftVal + 1);
            }
          }

          dumpCurrentToken(token, _i);
          var poppedToken = layers.pop();
          token = poppedToken.token;
          token.closingCurlyAt = _i;
          token.end = _i + 1;
          token.value = str.slice(token.start, token.end);
          pingTagCb(token);

          if (lastLayerIs("at")) {
            layers[~-layers.length].token.rules.push(token);
          }

          tokenReset();
          doNothing = _i + 1;
        }
      } else if (token.type === "text" && str[_i] && str[_i].trim()) {
        token.end = _i;
        token.value = str.slice(token.start, token.end);

        if (lastLayerIs("at")) {
          layers[~-layers.length].token.rules.push(token);
        } else {
          pingTagCb(token);
        }

        tokenReset();
      }
    }

    if (token.end && token.end === _i) {
      if (token.tagName === "style" && !token.closing) {
        withinStyle = true;
      }

      if (attribToBackup) {
        attrib = attribToBackup;
        attrib.attribValue.push(token);
        token = lodash_clonedeep(parentTokenToBackup);
        attribToBackup = undefined;
        parentTokenToBackup = undefined;
      } else {
        dumpCurrentToken(token, _i);
        layers.length = 0;
      }
    }

    if (!doNothing) {
      if (["tag", "at"].includes(token.type) && token.kind !== "cdata") {
        if (str[_i] && (SOMEQUOTE.includes(str[_i]) || "()".includes(str[_i])) && !(SOMEQUOTE.includes(str[leftVal]) && str[leftVal] === str[rightVal]) && ifQuoteThenAttrClosingQuote(_i)) {
          if (lastLayerIs("simple") && layers[~-layers.length].value === flipEspTag(str[_i])) {
            layers.pop();
          } else {
            layers.push({
              type: "simple",
              value: str[_i],
              position: _i
            });
          }
        }
      } else if (token.type === "comment" && ["only", "not"].includes(token.kind)) {
        if (["[", "]"].includes(str[_i])) {
          if (lastLayerIs("simple") && layers[~-layers.length].value === flipEspTag(str[_i])) {
            layers.pop();
          } else {
            layers.push({
              type: "simple",
              value: str[_i],
              position: _i
            });
          }
        }
      } else if (token.type === "esp" && ("'\"" + BACKTICK + "()").includes(str[_i]) && !(["\"", "'", "`"].includes(str[leftVal]) && str[leftVal] === str[rightVal])) {
        if (lastLayerIs("simple") && layers[~-layers.length].value === flipEspTag(str[_i])) {
          layers.pop();
          doNothing = _i + 1;
        } else if (!"]})>".includes(str[_i])) {
          layers.push({
            type: "simple",
            value: str[_i],
            position: _i
          });
        }
      }
    }

    if (!doNothing && token.type === "at" && token.start != null && _i >= token.start && !token.identifierStartsAt && str[_i] && str[_i].trim() && str[_i] !== "@") {
      token.identifierStartsAt = _i;
    }

    if (!doNothing && token.type === "at" && token.queryStartsAt && !token.queryEndsAt && "{;".includes(str[_i])) {
      if (str[_i] === "{") {
        if (str[~-_i] && str[~-_i].trim()) {
          token.queryEndsAt = _i;
        } else {
          token.queryEndsAt = leftVal !== null ? leftVal + 1 : _i;
        }
      } else {
        token.queryEndsAt = left(str, _i + 1) || 0;
      }

      if (token.queryStartsAt && token.queryEndsAt) {
        token.query = str.slice(token.queryStartsAt, token.queryEndsAt);
      }

      token.end = str[_i] === ";" ? _i + 1 : _i;
      token.value = str.slice(token.start, token.end);

      if (str[_i] === ";") {
        pingTagCb(token);
      } else {
        token.openingCurlyAt = _i;
        layers.push({
          type: "at",
          token: token
        });
      }

      tokenReset();
      doNothing = _i + 1;
    }

    if (!doNothing && token.type === "at" && token.identifier && str[_i] && str[_i].trim() && !token.queryStartsAt) {
      token.queryStartsAt = _i;
    }

    if (!doNothing && token && token.type === "at" && token.identifierStartsAt && _i >= token.start && str[_i] && (!str[_i].trim() || "()".includes(str[_i])) && !token.identifierEndsAt) {
      token.identifierEndsAt = _i;
      token.identifier = str.slice(token.identifierStartsAt, _i);
    }

    if (token.type === "rule") {
      if (selectorChunkStartedAt && (charsThatEndCSSChunks.includes(str[_i]) || str[_i] && rightVal && !str[_i].trim() && charsThatEndCSSChunks.includes(str[rightVal]))) {
        token.selectors.push({
          value: str.slice(selectorChunkStartedAt, _i),
          selectorStarts: selectorChunkStartedAt,
          selectorEnds: _i
        });
        selectorChunkStartedAt = undefined;
        token.selectorsEnd = _i;
      } else if (str[_i] === "{" && token.openingCurlyAt && !token.closingCurlyAt) {
        for (var y = _i; y--;) {
          if (!str[y].trim() || "{}\"';".includes(str[y])) {
            if (property && property.start && !property.end) {
              property.end = y + 1;
              property.property = str.slice(property.start, property.end);
              pushProperty(property);
              propertyReset();
              token.end = y + 1;
              token.value = str.slice(token.start, token.end);
              pingTagCb(token);
              initToken(str[y + 1] === "@" ? "at" : "rule", y + 1);
              token.left = left(str, y + 1);
              token.selectorsStart = y + 1;
              _i = y + 1;
            }

            break;
          }
        }
      }
    }

    var lastEspLayerObjIdx = getLastEspLayerObjIdx(layers);

    if (!doNothing && str[_i]) {
      if (startsTag(str, _i, token, layers, withinStyle, leftVal, rightVal)) {
        if (token.type && token.start !== null) {
          if (token.type === "rule") {
            if (property && property.start) {
              if (property.importantStarts && !property.importantEnds) {
                property.importantEnds = _i;
                property.important = str.slice(property.importantStarts, _i);
              }

              if (property.propertyStarts && !property.propertyEnds) {
                property.propertyEnds = _i;

                if (!property.property) {
                  property.property = str.slice(property.propertyStarts, _i);
                }
              }

              if (!property.end) {
                property.end = _i;
              }

              if (property.valueStarts && !property.valueEnds) {
                property.valueEnds = _i;

                if (!property.value) {
                  property.value = str.slice(property.valueStarts, _i);
                }
              }

              pushProperty(property);
              propertyReset();
            }
          }

          dumpCurrentToken(token, _i);
          tokenReset();
        }

        initToken("tag", _i);

        if (withinStyle) {
          withinStyle = false;
        }

        var badCharacters = "?![-/";
        var extractedTagName = "";
        var letterMet = false;

        if (rightVal) {
          for (var _y2 = rightVal; _y2 < len; _y2++) {
            if (!letterMet && str[_y2] && str[_y2].trim() && str[_y2].toUpperCase() !== str[_y2].toLowerCase()) {
              letterMet = true;
            }

            if (letterMet && str[_y2] && (!str[_y2].trim() || !/\w/.test(str[_y2]) && !badCharacters.includes(str[_y2]) || str[_y2] === "[")) {
              break;
            } else if (!badCharacters.includes(str[_y2])) {
              extractedTagName += str[_y2].trim().toLowerCase();
            }
          }
        }

        if (extractedTagName === "doctype") {
          token.kind = "doctype";
        } else if (extractedTagName === "cdata") {
          token.kind = "cdata";
        } else if (extractedTagName === "xml") {
          token.kind = "xml";
        } else if (inlineTags.has(extractedTagName)) {
          token.kind = "inline";

          if (extractedTagName) {
            doNothing = _i;
          }
        }
      } else if (!withinScript && startsHtmlComment(str, _i, token, layers)) {
        if (token.start != null) {
          dumpCurrentToken(token, _i);
        }

        initToken("comment", _i);

        if (str[_i] === "-") {
          token.closing = true;
        } else if (matchRightIncl(str, _i, ["<![endif]-->"], {
          i: true,
          trimBeforeMatching: true,
          maxMismatches: 2
        })) {
          token.closing = true;
          token.kind = "only";
        }

        if (withinStyle) {
          withinStyle = false;
        }
      } else if (!withinScript && startsCssComment(str, _i, token, layers, withinStyle)) {
        if (token.start != null) {
          dumpCurrentToken(token, _i);
        }

        initToken("comment", _i);
        token.language = "css";
        token.kind = str[_i] === "/" && str[_i + 1] === "/" ? "line" : "block";
        token.value = str.slice(_i, _i + 2);
        token.end = _i + 2;
        token.closing = str[_i] === "*" && str[_i + 1] === "/";
        withinStyleComment = true;

        if (token.closing) {
          withinStyleComment = false;
        }

        doNothing = _i + 2;
      } else if (!withinScript && (typeof lastEspLayerObjIdx === "number" && layers[lastEspLayerObjIdx] && layers[lastEspLayerObjIdx].type === "esp" && layers[lastEspLayerObjIdx].openingLump && layers[lastEspLayerObjIdx].guessedClosingLump && layers[lastEspLayerObjIdx].guessedClosingLump.length > 1 && layers[lastEspLayerObjIdx].guessedClosingLump.includes(str[_i]) && layers[lastEspLayerObjIdx].guessedClosingLump.includes(str[_i + 1]) && !(layers[lastEspLayerObjIdx + 1] && "'\"".includes(layers[lastEspLayerObjIdx + 1].value) && str.indexOf(layers[lastEspLayerObjIdx + 1].value, _i) > 0 && layers[lastEspLayerObjIdx].guessedClosingLump.includes(str[right(str, str.indexOf(layers[lastEspLayerObjIdx + 1].value, _i))])) || startsEsp(str, _i, token, layers, withinStyle) && (!lastLayerIs("simple") || !["'", "\""].includes(layers[~-layers.length].value) || attrib && attrib.attribStarts && !attrib.attribEnds))) {
        var wholeEspTagLumpOnTheRight = getWholeEspTagLumpOnTheRight(str, _i, layers);

        if (!espLumpBlacklist.includes(wholeEspTagLumpOnTheRight)) {
          var lengthOfClosingEspChunk;
          var disposableVar;

          if (layers.length && (lengthOfClosingEspChunk = matchLayerLast(wholeEspTagLumpOnTheRight, layers))) {
            if (token.type === "esp") {
              if (!token.end) {
                token.end = _i + lengthOfClosingEspChunk;
                token.value = str.slice(token.start, token.end);
                token.tail = str.slice(_i, _i + lengthOfClosingEspChunk);
                token.tailStartsAt = _i;
                token.tailEndsAt = token.end;

                if (str[_i] === ">" && str[leftVal] === "/") {
                  token.tailStartsAt = leftVal;
                  token.tail = str.slice(token.tailStartsAt, _i + 1);
                }
              }

              doNothing = token.tailEndsAt;

              if (parentTokenToBackup) {
                if (!Array.isArray(parentTokenToBackup.attribs)) {
                  parentTokenToBackup.attribs = [];
                }

                if (attribToBackup) {
                  attrib = attribToBackup;
                  attrib.attribValue.push(_objectSpread2({}, token));
                } else {
                  parentTokenToBackup.attribs.push(_objectSpread2({}, token));
                }

                token = lodash_clonedeep(parentTokenToBackup);
                parentTokenToBackup = undefined;
                attribToBackup = undefined;
                layers.pop();
                i = _i;
                return "continue";
              } else {
                dumpCurrentToken(token, _i);
              }

              tokenReset();
            }

            layers.pop();
          } else if (layers.length && (lengthOfClosingEspChunk = matchLayerLast(wholeEspTagLumpOnTheRight, layers, true))) {
            if (token.type === "esp") {
              if (!token.end) {
                token.end = _i + (lengthOfClosingEspChunk || 0);
                token.value = str.slice(token.start, token.end);
              }

              if (!token.tailStartsAt) {
                token.tailStartsAt = _i;
              }

              if (!token.tailEndsAt && lengthOfClosingEspChunk) {
                token.tailEndsAt = token.tailStartsAt + lengthOfClosingEspChunk;
                token.tail = str.slice(_i, _i + lengthOfClosingEspChunk);
              }

              dumpCurrentToken(token, _i);
              tokenReset();
            }

            layers.length = 0;
          } else if (attrib && attrib.attribValue && attrib.attribValue.length && attrib.attribValue[~-attrib.attribValue.length].start && Array.from(str.slice(attrib.attribValue[~-attrib.attribValue.length].start, _i)).some(function (char, idx) {
            return wholeEspTagLumpOnTheRight.includes(flipEspTag(char)) && (veryEspChars.includes(char) || !idx) && (disposableVar = {
              char: char,
              idx: idx
            });
          }) && token.type === "tag" && attrib && attrib.attribValueStartsAt && !attrib.attribValueEndsAt && attrib.attribValue[~-attrib.attribValue.length] && attrib.attribValue[~-attrib.attribValue.length].type === "text") {
            token.pureHTML = false;
            var lastAttrValueObj = attrib.attribValue[~-attrib.attribValue.length];
            var newTokenToPutInstead = getNewToken("esp", lastAttrValueObj.start);

            if (!disposableVar || !disposableVar.idx) {
              newTokenToPutInstead.head = disposableVar.char;
              newTokenToPutInstead.headStartsAt = lastAttrValueObj.start;
              newTokenToPutInstead.headEndsAt = newTokenToPutInstead.headStartsAt + 1;
              newTokenToPutInstead.tailStartsAt = _i;
              newTokenToPutInstead.tailEndsAt = _i + wholeEspTagLumpOnTheRight.length;
              newTokenToPutInstead.tail = wholeEspTagLumpOnTheRight;
              attrib.attribValue[~-attrib.attribValue.length] = newTokenToPutInstead;
            }
          } else {
            if (lastLayerIs("esp")) {
              layers.pop();
            }

            if (attribToBackup) {
              if (!Array.isArray(attribToBackup.attribValue)) {
                attribToBackup.attribValue = [];
              }

              attribToBackup.attribValue.push(token);
            }

            layers.push({
              type: "esp",
              openingLump: wholeEspTagLumpOnTheRight,
              guessedClosingLump: flipEspTag(wholeEspTagLumpOnTheRight),
              position: _i
            });

            if (token.start !== null) {
              if (token.type === "tag") {
                if (token.tagNameStartsAt && (!token.tagName || !token.tagNameEndsAt)) {
                  token.tagNameEndsAt = _i;
                  token.tagName = str.slice(token.tagNameStartsAt, _i);
                  token.recognised = isTagNameRecognised(token.tagName);
                }

                parentTokenToBackup = lodash_clonedeep(token);

                if (attrib.attribStarts && !attrib.attribEnds) {
                  attribToBackup = lodash_clonedeep(attrib);
                }
              } else if (!attribToBackup) {
                dumpCurrentToken(token, _i);
              } else if (attribToBackup && Array.isArray(attribToBackup.attribValue) && attribToBackup.attribValue.length && attribToBackup.attribValue[~-attribToBackup.attribValue.length].type === "esp" && !attribToBackup.attribValue[~-attribToBackup.attribValue.length].end) {
                attribToBackup.attribValue[~-attribToBackup.attribValue.length].end = _i;
                attribToBackup.attribValue[~-attribToBackup.attribValue.length].value = str.slice(attribToBackup.attribValue[~-attribToBackup.attribValue.length].start, _i);
              }
            }

            initToken("esp", _i);
            token.head = wholeEspTagLumpOnTheRight;
            token.headStartsAt = _i;
            token.headEndsAt = _i + wholeEspTagLumpOnTheRight.length;

            if (parentTokenToBackup && parentTokenToBackup.pureHTML) {
              parentTokenToBackup.pureHTML = false;
            }

            if (attribToBackup && Array.isArray(attribToBackup.attribValue) && attribToBackup.attribValue.length) {
              if (attribToBackup.attribValue[~-attribToBackup.attribValue.length].start === token.start) {
                attribToBackup.attribValue.pop();
              } else if (attribToBackup.attribValue[~-attribToBackup.attribValue.length].type === "text" && !attribToBackup.attribValue[~-attribToBackup.attribValue.length].end) {
                attribToBackup.attribValue[~-attribToBackup.attribValue.length].end = _i;
                attribToBackup.attribValue[~-attribToBackup.attribValue.length].value = str.slice(attribToBackup.attribValue[~-attribToBackup.attribValue.length].start, _i);
              }
            }
          }

          doNothing = _i + (lengthOfClosingEspChunk || wholeEspTagLumpOnTheRight.length);
        }
      } else if (!withinScript && withinStyle && !withinStyleComment && str[_i] && str[_i].trim() && !"{}".includes(str[_i]) && (!token.type || ["text"].includes(token.type))) {
        if (token.type) {
          dumpCurrentToken(token, _i);
        }

        initToken(str[_i] === "@" ? "at" : "rule", _i);
        token.left = lastNonWhitespaceCharAt;
        token.nested = layers.some(function (o) {
          return o.type === "at";
        });
      } else if (!token.type) {
        initToken("text", _i);

        if (withinScript && str.indexOf("</script>", _i)) {
          doNothing = str.indexOf("</script>", _i);
        } else {
          doNothing = _i;
        }
      }
    }

    var R1 = void 0;
    var R2 = void 0;

    if (!doNothing && (property.start || str[_i] === "!")) {
      R1 = ";'\"{}<>".includes(str[right(str, _i - 1)]);
      R2 = matchRightIncl(str, _i, ["!important"], {
        i: true,
        trimBeforeMatching: true,
        maxMismatches: 2
      });
    }
    /* istanbul ignore else */


    if (!doNothing && property && (property.semi && property.semi < _i && property.semi < _i || (property.valueStarts && !property.valueEnds && str[rightVal] !== "!" && (!rightVal || R1) || property.importantStarts && !property.importantEnds) && (!property.valueEnds || str[rightVal] !== ";") && (!str[_i] || !str[_i].trim() || !property.valueEnds && str[_i] === ";" || attrEndsAt(_i)))) {
      /* istanbul ignore else */
      if (property.importantStarts && !property.importantEnds) {
        property.importantEnds = left(str, _i) + 1;
        property.important = str.slice(property.importantStarts, property.importantEnds);
      }
      /* istanbul ignore else */


      if (property.valueStarts && !property.valueEnds) {
        property.valueEnds = _i;
        property.value = str.slice(property.valueStarts, _i);
      }
      /* istanbul ignore else */


      if (str[_i] === ";") {
        property.semi = _i;
        property.end = _i + 1;
      } else if (str[rightVal] === ";") {
        property.semi = rightVal;
        property.end = property.semi + 1;
        doNothing = property.end;
      }

      if (!property.end) {
        property.end = _i;
      }

      pushProperty(property);
      propertyReset();

      if (!doNothing && (!str[_i] || str[_i].trim()) && str[_i] === ";") {
        doNothing = _i;
      }
    }
    /* istanbul ignore else */


    if (!doNothing && property && property.valueStarts && !property.valueEnds) {
      if (!str[_i] || R1 || R2 || str[right(str, _i - 1)] === "!" || ";}".includes(str[_i]) && (!attrib || !attrib.attribName || attrib.attribName !== "style") || ";'\"".includes(str[_i]) && attrib && attrib.attribName === "style" && ifQuoteThenAttrClosingQuote(_i) || rightVal && !str[_i].trim() && (str.slice(_i, rightVal).includes("\n") || str.slice(_i, rightVal).includes("\r"))) {
        if (lastNonWhitespaceCharAt && (!"'\"".includes(str[_i]) || !rightVal || !"'\";".includes(str[rightVal]))) {
          property.valueEnds = lastNonWhitespaceCharAt + 1;
          property.value = str.slice(property.valueStarts, lastNonWhitespaceCharAt + 1);
        }

        if (str[_i] === ";") {
          property.semi = _i;
        } else if (str[_i] && !str[_i].trim() && str[rightVal] === ";") {
          property.semi = rightVal;
        }

        if (property.semi) {
          property.end = property.semi + 1;
        }

        if (!property.semi && !R1 && !R2 && str[right(str, _i - 1)] !== "!" && !property.end) {
          property.end = _i;
        }

        if (property.end) {
          if (property.end > _i) {
            doNothing = property.end;
          }

          pushProperty(property);
          propertyReset();
        }
      } else if (str[_i] === ":" && property && property.colon && property.colon < _i && lastNonWhitespaceCharAt && property.colon + 1 < lastNonWhitespaceCharAt) {
        var split = [];

        if (right(str, property.colon)) {
          split = str.slice(right(str, property.colon), lastNonWhitespaceCharAt + 1).split(/\s+/);
        }

        if (split.length === 2) {
          property.valueEnds = property.valueStarts + split[0].length;
          property.value = str.slice(property.valueStarts, property.valueEnds);
          property.end = property.valueEnds;
          pushProperty(property);
          var whitespaceStarts = property.end;
          var newPropertyStarts = lastNonWhitespaceCharAt + 1 - split[1].length;
          propertyReset();
          pushProperty({
            type: "text",
            start: whitespaceStarts,
            end: newPropertyStarts,
            value: str.slice(whitespaceStarts, newPropertyStarts)
          });
          property.start = newPropertyStarts;
          property.propertyStarts = newPropertyStarts;
        }
      } else if (str[_i] === "/" && str[rightVal] === "*") {
        /* istanbul ignore else */
        if (property.valueStarts && !property.valueEnds) {
          property.valueEnds = _i;
          property.value = str.slice(property.valueStarts, _i);
        }
        /* istanbul ignore else */


        if (!property.end) {
          property.end = _i;
        }

        pushProperty(property);
        propertyReset();
      }
    }

    if (!doNothing && property && property.start && !property.end && str[_i] === ";") {
      property.semi = _i;
      property.end = _i + 1;

      if (!property.propertyEnds) {
        property.propertyEnds = _i;
      }

      if (property.propertyStarts && property.propertyEnds && !property.property) {
        property.property = str.slice(property.propertyStarts, property.propertyEnds);
      }

      pushProperty(property);
      propertyReset();
      doNothing = _i;
    }
    /* istanbul ignore else */


    if (property && property.importantStarts && !property.importantEnds && str[_i] && !str[_i].trim()) {
      property.importantEnds = _i;
      property.important = str.slice(property.importantStarts, _i);
    }
    /* istanbul ignore else */


    if (!doNothing && property && property.valueEnds && !property.importantStarts && (str[_i] === "!" || isLatinLetter(str[_i]) && str.slice(_i).match(importantStartsRegexp))) {
      property.importantStarts = _i;

      if (str[_i - 1] && str[_i - 1].trim() && str[_i - 2] && !str[_i - 2].trim() || str[_i - 1] === "1" && str[_i - 2] && !/\d/.test(str[_i - 2])) {
        property.valueEnds = left(str, _i - 1) + 1;
        property.value = str.slice(property.valueStarts, property.valueEnds);
        property.importantStarts--;
        property.important = str[_i - 1] + property.important;
      }
    }
    /* istanbul ignore else */


    if (!doNothing && property && property.colon && !property.valueStarts && str[_i] && str[_i].trim()) {
      /* istanbul ignore else */
      if (";}'\"".includes(str[_i]) && ifQuoteThenAttrClosingQuote(_i)) {
        /* istanbul ignore else */
        if (str[_i] === ";") {
          property.semi = _i;
        }

        var temp;
        /* istanbul ignore else */

        if (!property.end) {
          property.end = property.semi ? property.semi + 1 : left(str, _i) + 1;
          temp = property.end;
        }

        pushProperty(property);
        propertyReset();
        /* istanbul ignore else */

        if (temp && temp < _i) {
          pushProperty({
            type: "text",
            start: temp,
            end: _i,
            value: str.slice(temp, _i)
          });
        }
      } else if (str[_i] === "!") {
        property.importantStarts = _i;
      } else {
        property.valueStarts = _i;
      }
    }

    if (!doNothing && token.type === "rule" && str[_i] && str[_i].trim() && !"{}".includes(str[_i]) && !selectorChunkStartedAt && !token.openingCurlyAt) {
      if (!",".includes(str[_i])) {
        selectorChunkStartedAt = _i;

        if (token.selectorsStart === null) {
          token.selectorsStart = _i;
        }
      } else {
        token.selectorsEnd = _i + 1;
      }
    }

    if (!doNothing && property && property.propertyStarts && property.propertyStarts < _i && !property.propertyEnds && (!str[_i] || !str[_i].trim() || !attrNameRegexp.test(str[_i]) && (str[_i] === ":" || !rightVal || !":/}".includes(str[rightVal]) || str[_i] === "}" && str[rightVal] === "}") || str[_i] === "!") && (str[_i] !== "/" || str[_i - 1] !== "/")) {
      property.propertyEnds = _i;
      property.property = str.slice(property.propertyStarts, _i);

      if (property.valueStarts) {
        property.end = _i;
      }

      if ("};".includes(str[_i]) || str[_i] && !str[_i].trim() && str[rightVal] !== ":") {
        if (str[_i] === ";") {
          property.semi = _i;
        }

        if (!property.end) {
          property.end = property.semi ? property.semi + 1 : _i;
        }

        pushProperty(property);
        propertyReset();
      }

      if (str[_i] && str[_i].trim() && attrNameRegexp.test(str[property.propertyStarts]) && !attrNameRegexp.test(str[_i]) && !":'\"".includes(str[_i])) {
        var nextSemi = str.indexOf(";", _i);
        var nextColon = str.indexOf(":", _i);

        if ((nextColon === -1 && nextSemi !== -1 || !(nextColon !== -1 && nextSemi !== -1 && nextColon < nextSemi)) && !"{}".includes(str[_i]) && rightVal && (!"!".includes(str[_i]) || isLatinLetter(str[rightVal]))) {
          property.colon = _i;
          property.valueStarts = rightVal;
        } else if (nextColon !== -1 && nextSemi !== -1 && nextColon < nextSemi) {
          property.propertyEnds = null;
        } else if (str[_i] === "!") {
          property.importantStarts = _i;
        }
      }
    }

    if (!doNothing && property && property.propertyEnds && !property.valueStarts && str[_i] === ":") {
      property.colon = _i;

      if (!rightVal) {
        property.end = _i + 1;

        if (str[_i + 1]) {
          pushProperty(property);
          propertyReset();

          if (token.properties) {
            token.properties.push({
              type: "text",
              start: _i + 1,
              end: null,
              value: null
            });
            doNothing = _i + 1;
          }
        }
      }

      if (property.propertyEnds && lastNonWhitespaceCharAt && property.propertyEnds !== lastNonWhitespaceCharAt + 1 && !attrNameRegexp.test(str[property.propertyEnds])) {
        property.propertyEnds = lastNonWhitespaceCharAt + 1;
        property.property = str.slice(property.propertyStarts, property.propertyEnds);
      }
    }

    if (!doNothing && token.type === "rule" && str[_i] && str[_i].trim() && !"{}".includes(str[_i]) && token.selectorsEnd && token.openingCurlyAt && !property.propertyStarts && !property.importantStarts) {
      if (Array.isArray(token.properties) && token.properties.length && token.properties[~-token.properties.length].start && !token.properties[~-token.properties.length].end) {
        token.properties[~-token.properties.length].end = _i;
        token.properties[~-token.properties.length].value = str.slice(token.properties[~-token.properties.length].start, _i);
      }

      if (str[_i] === ";") {
        initProperty({
          start: _i,
          end: _i + 1,
          semi: _i
        });
        pushProperty(property);
        propertyReset();
      } else if (str[_i] === "!") {
        initProperty({
          start: _i,
          importantStarts: _i
        });
      } else {
        initProperty(_i);
      }

      doNothing = _i;
    }

    if (!doNothing && attrib && attrib.attribName === "style" && attrib.attribOpeningQuoteAt && !attrib.attribClosingQuoteAt && !property.start && str[_i] && str[_i].trim() && !"'\"".includes(str[_i]) && !lastLayerIs("block")) {
      if (str[_i] === "/" && str[rightVal] === "*") {
        attribPush({
          type: "comment",
          start: _i,
          end: rightVal + 1,
          value: str.slice(_i, rightVal + 1),
          closing: false,
          kind: "block",
          language: "css"
        });
        layers.push({
          type: "block",
          value: str.slice(_i, rightVal + 1),
          position: _i
        });
        doNothing = rightVal + 1;
      } else if (str[_i] === "*" && str[rightVal] === "/") {
        closingComment(_i);
      } else {
        if (Array.isArray(attrib.attribValue) && attrib.attribValue.length && !attrib.attribValue[~-attrib.attribValue.length].end) {
          attrib.attribValue[~-attrib.attribValue.length].end = _i;
          attrib.attribValue[~-attrib.attribValue.length].value = str.slice(attrib.attribValue[~-attrib.attribValue.length].start, _i);
        }

        if (str[_i] === ";") {
          initProperty({
            start: _i,
            end: _i + 1,
            semi: _i
          });
          doNothing = _i;
        } else if (R2) {
          initProperty({
            start: _i,
            importantStarts: _i
          });
        } else {
          initProperty(_i);
        }
      }
    }

    if (token.type === "comment" && ["only", "not"].includes(token.kind)) {
      if (str[_i] === "[") ;
    }

    if (!doNothing) {
      if (token.type === "tag" && !layers.length && str[_i] === ">") {
        token.end = _i + 1;
        token.value = str.slice(token.start, token.end);
      } else if (token.type === "comment" && token.language === "html" && !layers.length && token.kind === "simple" && (str[token.start] === "<" && str[_i] === "-" && (matchLeft(str, _i, "!-", {
        trimBeforeMatching: true
      }) || matchLeftIncl(str, _i, "!-", {
        trimBeforeMatching: true
      }) && str[_i + 1] !== "-") || str[token.start] === "-" && str[_i] === ">" && matchLeft(str, _i, "--", {
        trimBeforeMatching: true,
        maxMismatches: 1
      }))) {
        if (str[_i] === "-" && (matchRight(str, _i, ["[if", "(if", "{if"], {
          i: true,
          trimBeforeMatching: true
        }) || matchRight(str, _i, ["if"], {
          i: true,
          trimBeforeMatching: true
        }) && (xBeforeYOnTheRight(str, _i, "]", ">") || str.includes("mso", _i) && !str.slice(_i, str.indexOf("mso")).includes("<") && !str.slice(_i, str.indexOf("mso")).includes(">")))) {
          token.kind = "only";
        } else if (str[token.start] !== "-" && matchRightIncl(str, _i, ["-<![endif"], {
          i: true,
          trimBeforeMatching: true,
          maxMismatches: 2
        })) {
          token.kind = "not";
          token.closing = true;
        } else if (token.kind === "simple" && token.language === "html" && !token.closing && str[rightVal] === ">") {
          token.end = rightVal + 1;
          token.kind = "simplet";
          token.closing = null;
        } else if (token.language === "html") {
          token.end = _i + 1;

          if (str[leftVal] === "!" && str[rightVal] === "-") {
            token.end = rightVal + 1;
          }

          token.value = str.slice(token.start, token.end);
        }
      } else if (token.type === "comment" && token.language === "html" && str[_i] === ">" && (!layers.length || str[rightVal] === "<")) {
        if (Array.isArray(layers) && layers.length && layers[~-layers.length].value === "[") {
          layers.pop();
        }

        if (!["simplet", "not"].includes(token.kind) && matchRight(str, _i, ["<!-->", "<!---->"], {
          trimBeforeMatching: true,
          maxMismatches: 1,
          lastMustMatch: true
        })) {
          token.kind = "not";
        } else {
          token.end = _i + 1;
          token.value = str.slice(token.start, token.end);
        }
      } else if (token.type === "comment" && token.language === "css" && str[_i] === "*" && str[_i + 1] === "/") {
        token.end = _i + 1;
        token.value = str.slice(token.start, token.end);
      } else if (token.type === "esp" && token.end === null && typeof token.head === "string" && typeof token.tail === "string" && token.tail.includes(str[_i])) {
        var wholeEspTagClosing = "";

        for (var _y3 = _i; _y3 < len; _y3++) {
          if (espChars.includes(str[_y3])) {
            wholeEspTagClosing += str[_y3];
          } else {
            break;
          }
        }

        if (wholeEspTagClosing.length > token.head.length) {
          var headsFirstChar = token.head[0];

          if (wholeEspTagClosing.endsWith(token.head)) {
            token.end = _i + wholeEspTagClosing.length - token.head.length;
            token.value = str.slice(token.start, token.end);
            doNothing = token.end;
          } else if (wholeEspTagClosing.startsWith(token.tail)) {
            token.end = _i + token.tail.length;
            token.value = str.slice(token.start, token.end);
            doNothing = token.end;
          } else if (!token.tail.includes(headsFirstChar) && wholeEspTagClosing.includes(headsFirstChar) || wholeEspTagClosing.endsWith(token.head) || wholeEspTagClosing.startsWith(token.tail)) {
            var firstPartOfWholeEspTagClosing = wholeEspTagClosing.slice(0, wholeEspTagClosing.indexOf(headsFirstChar));
            var secondPartOfWholeEspTagClosing = wholeEspTagClosing.slice(wholeEspTagClosing.indexOf(headsFirstChar));

            if (firstPartOfWholeEspTagClosing.length && secondPartOfWholeEspTagClosing.length && token.tail.split("").every(function (char) {
              return firstPartOfWholeEspTagClosing.includes(char);
            })) {
              token.end = _i + firstPartOfWholeEspTagClosing.length;
              token.value = str.slice(token.start, token.end);
              doNothing = token.end;
            }
          } else {
            token.end = _i + wholeEspTagClosing.length;
            token.value = str.slice(token.start, token.end);
            doNothing = token.end;
          }
        } else {
          token.end = _i + wholeEspTagClosing.length;
          token.value = str.slice(token.start, token.end);

          if (lastLayerIs("esp")) {
            layers.pop();
          }

          doNothing = token.end;
        }
      }
    }

    if (!doNothing && token.type === "tag" && token.tagNameStartsAt && !token.tagNameEndsAt) {
      if (!str[_i] || !charSuitableForTagName(str[_i])) {
        token.tagNameEndsAt = _i;
        token.tagName = str.slice(token.tagNameStartsAt, _i).toLowerCase();

        if (token.tagName && token.tagName.toLowerCase() === "script") {
          withinScript = !withinScript;
        }

        if (token.tagName === "xml" && token.closing && !token.kind) {
          token.kind = "xml";
        }

        if (voidTags.includes(token.tagName)) {
          token.void = true;
        }

        token.recognised = isTagNameRecognised(token.tagName);
        doNothing = _i;
      }
    }

    if (!doNothing && token.type === "tag" && !token.tagNameStartsAt && token.start != null && (token.start < _i || str[token.start] !== "<")) {
      if (str[_i] === "/") {
        token.closing = true;
        doNothing = _i;
      } else if (isLatinLetter(str[_i])) {
        token.tagNameStartsAt = _i;

        if (!token.closing) {
          token.closing = false;
          doNothing = _i;
        }
      } else ;
    }

    if (!doNothing && token.type === "tag" && token.kind !== "cdata" && attrib.attribNameStartsAt && _i > attrib.attribNameStartsAt && attrib.attribNameEndsAt === null && !isAttrNameChar(str[_i])) {
      attrib.attribNameEndsAt = _i;
      attrib.attribName = str.slice(attrib.attribNameStartsAt, _i);
      attrib.attribNameRecognised = allHtmlAttribs.has(attrib.attribName);

      if (attrib.attribName.startsWith("mc:")) {
        token.pureHTML = false;
      }

      if (str[_i] && !str[_i].trim() && str[rightVal] === "=") ;else if (str[_i] && !str[_i].trim() || str[_i] === ">" || str[_i] === "/" && str[rightVal] === ">") {
        if ("'\"".includes(str[rightVal])) ;else {
          attrib.attribEnds = _i;
          token.attribs.push(lodash_clonedeep(attrib));
          attribReset();
        }
      }
    }

    if (!doNothing && str[_i] && token.type === "tag" && token.kind !== "cdata" && token.tagNameEndsAt && _i > token.tagNameEndsAt && attrib.attribStarts === null && isAttrNameChar(str[_i])) {
      attrib.attribStarts = _i;
      attrib.attribLeft = lastNonWhitespaceCharAt;
      attrib.attribNameStartsAt = _i;
    }

    if (!doNothing && token.type === "rule") {
      if (str[_i] === "{" && !token.openingCurlyAt) {
        token.openingCurlyAt = _i;
      } else if (str[_i] === "}" && token.openingCurlyAt && !token.closingCurlyAt) {
        token.closingCurlyAt = _i;
        token.end = _i + 1;
        token.value = str.slice(token.start, token.end);

        if (Array.isArray(token.properties) && token.properties.length && token.properties[~-token.properties.length].start && !token.properties[~-token.properties.length].end) {
          token.properties[~-token.properties.length].end = _i;
          token.properties[~-token.properties.length].value = str.slice(token.properties[~-token.properties.length].start, _i);
        }

        if (property.start) {
          token.properties.push(property);
          propertyReset();
        }

        pingTagCb(token);

        if (lastLayerIs("at")) {
          layers[~-layers.length].token.rules.push(token);
        }

        tokenReset();
      }
    }

    if (!doNothing && attrib.attribName && Array.isArray(attrib.attribValue) && attrib.attribValue.length && !attrib.attribValue[~-attrib.attribValue.length].end) {
      if (str[_i] === "*" && str[rightVal] === "/") {
        closingComment(_i);
      }
    }

    if (!doNothing && attrib && attrib.attribValueStartsAt && !attrib.attribValueEndsAt && !property.propertyStarts && _i >= attrib.attribValueStartsAt && Array.isArray(attrib.attribValue) && (!attrib.attribValue.length || attrib.attribValue[~-attrib.attribValue.length].end && attrib.attribValue[~-attrib.attribValue.length].end <= _i) || !doNothing && token.type === "rule" && token.openingCurlyAt && !token.closingCurlyAt && !property.propertyStarts) {
      if (str[_i] === ";" && (attrib && Array.isArray(attrib.attribValue) && attrib.attribValue.length && attrib.attribValue[~-attrib.attribValue.length].semi && attrib.attribValue[~-attrib.attribValue.length].semi < _i || token && token.type === "rule" && Array.isArray(token.properties) && token.properties.length && token.properties[~-token.properties.length].semi && token.properties[~-token.properties.length].semi < _i)) {
        initProperty({
          start: _i,
          semi: _i
        });
        doNothing = _i + 1;
      } else if (str[_i] && !str[_i].trim() || lastLayerIs("block")) {
        if (attrib.attribName) {
          attrib.attribValue.push({
            type: "text",
            start: _i,
            end: null,
            value: null
          });
        } else if (token.type === "rule" && (!Array.isArray(token.properties) || !token.properties.length || token.properties[~-token.properties.length].end)) {
          token.properties.push({
            type: "text",
            start: _i,
            end: null,
            value: null
          });
        }
      }
    }

    if (!doNothing && token.type === "tag" && attrib.attribValueStartsAt && _i >= attrib.attribValueStartsAt && attrib.attribValueEndsAt === null) {
      if (SOMEQUOTE.includes(str[_i])) {
        if (!layers.some(function (layerObj) {
          return layerObj.type === "esp";
        }) && (!str[_i] || !str.includes(">", _i) || isAttrClosing(str, attrib.attribOpeningQuoteAt || attrib.attribValueStartsAt, _i))) {
          attrib.attribClosingQuoteAt = _i;
          attrib.attribValueEndsAt = _i;

          if (attrib.attribValueStartsAt) {
            attrib.attribValueRaw = str.slice(attrib.attribValueStartsAt, _i);
          }

          attrib.attribEnds = _i + 1;

          if (property.propertyStarts) {
            attrib.attribValue.push(lodash_clonedeep(property));
            propertyReset();
          }

          if (Array.isArray(attrib.attribValue) && attrib.attribValue.length && !attrib.attribValue[~-attrib.attribValue.length].end) {
            if (!attrib.attribValue[~-attrib.attribValue.length].property) {
              attrib.attribValue[~-attrib.attribValue.length].end = _i;
              attrib.attribValue[~-attrib.attribValue.length].value = str.slice(attrib.attribValue[~-attrib.attribValue.length].start, _i);
            }
          }

          if (str[attrib.attribOpeningQuoteAt] !== str[_i]) {
            layers.pop();
            layers.pop();
          }

          if (attrib.attribValue[~-attrib.attribValue.length] && !attrib.attribValue[~-attrib.attribValue.length].end) {
            attrib.attribValue[~-attrib.attribValue.length].end = _i;
          }

          token.attribs.push(lodash_clonedeep(attrib));
          attribReset();
        } else if ((!Array.isArray(attrib.attribValue) || !attrib.attribValue.length || attrib.attribValue[~-attrib.attribValue.length].type !== "text") && !property.propertyStarts) {
          attrib.attribValue.push({
            type: "text",
            start: _i,
            end: null,
            value: null
          });
        }
      } else if (attrib.attribOpeningQuoteAt === null && (str[_i] && !str[_i].trim() || ["/", ">"].includes(str[_i]) || espChars.includes(str[_i]) && espChars.includes(str[_i + 1]))) {
        attrib.attribValueEndsAt = _i;
        attrib.attribValueRaw = str.slice(attrib.attribValueStartsAt, _i);

        if (Array.isArray(attrib.attribValue) && attrib.attribValue.length && !attrib.attribValue[~-attrib.attribValue.length].end) {
          attrib.attribValue[~-attrib.attribValue.length].end = _i;
          attrib.attribValue[~-attrib.attribValue.length].value = str.slice(attrib.attribValue[~-attrib.attribValue.length].start, attrib.attribValue[~-attrib.attribValue.length].end);
        }

        attrib.attribEnds = _i;
        token.attribs.push(lodash_clonedeep(attrib));
        attribReset();
        layers.pop();

        if (str[_i] === ">") {
          token.end = _i + 1;
          token.value = str.slice(token.start, token.end);
        }
      } else if (str[_i] === "=" && leftVal !== null && rightVal && ("'\"".includes(str[rightVal]) || str[~-_i] && isLatinLetter(str[~-_i])) && !(attrib && attrib.attribOpeningQuoteAt && (/\//.test(str.slice(attrib.attribOpeningQuoteAt + 1, _i)) || /mailto:/.test(str.slice(attrib.attribOpeningQuoteAt + 1, _i)) || /\w\?\w/.test(str.slice(attrib.attribOpeningQuoteAt + 1, _i))))) {
        var whitespaceFound;
        var attribClosingQuoteAt;

        for (var _y4 = leftVal; _y4 >= attrib.attribValueStartsAt; _y4--) {
          if (!whitespaceFound && str[_y4] && !str[_y4].trim()) {
            whitespaceFound = true;

            if (attribClosingQuoteAt) {
              str.slice(_y4, attribClosingQuoteAt);
            }
          }

          if (whitespaceFound && str[_y4] && str[_y4].trim()) {
            whitespaceFound = false;

            if (!attribClosingQuoteAt) {
              attribClosingQuoteAt = _y4 + 1;
            }
          }
        }

        if (attribClosingQuoteAt) {
          attrib.attribValueEndsAt = attribClosingQuoteAt;

          if (attrib.attribValueStartsAt) {
            attrib.attribValueRaw = str.slice(attrib.attribValueStartsAt, attribClosingQuoteAt);

            if (Array.isArray(attrib.attribValue) && attrib.attribValue.length && !attrib.attribValue[~-attrib.attribValue.length].end) {
              attrib.attribValue[~-attrib.attribValue.length].end = attrib.attribValueEndsAt;
              attrib.attribValue[~-attrib.attribValue.length].value = str.slice(attrib.attribValue[~-attrib.attribValue.length].start, attrib.attribValueEndsAt);
            }
          }

          attrib.attribEnds = attribClosingQuoteAt;

          if (str[attrib.attribOpeningQuoteAt] !== str[_i]) {
            layers.pop();
          }

          token.attribs.push(lodash_clonedeep(attrib));
          attribReset();
          _i = ~-attribClosingQuoteAt;
          i = _i;
          return "continue";
        } else if (attrib.attribOpeningQuoteAt && ("'\"".includes(str[rightVal]) || allHtmlAttribs.has(str.slice(attrib.attribOpeningQuoteAt + 1, _i).trim()))) {
          _i = attrib.attribOpeningQuoteAt;
          attrib.attribEnds = attrib.attribOpeningQuoteAt + 1;
          attrib.attribValueStartsAt = null;
          layers.pop();
          token.attribs.push(lodash_clonedeep(attrib));
          attribReset();
          i = _i;
          return "continue";
        }
      } else if (str[_i] === "/" && str[rightVal] === ">") {
        if (attrib.attribValueStartsAt) {
          attrib.attribValueStartsAt = null;
        }

        if (!attrib.attribEnds) {
          attrib.attribEnds = _i;
        }
      } else if (attrib && attrib.attribName !== "style" && attrib.attribStarts && !attrib.attribEnds && !property.propertyStarts && (!Array.isArray(attrib.attribValue) || !attrib.attribValue.length || attrib.attribValue[~-attrib.attribValue.length].end && attrib.attribValue[~-attrib.attribValue.length].end <= _i)) {
        attrib.attribValue.push({
          type: "text",
          start: _i,
          end: null,
          value: null
        });
      }
    } else if (token.type === "esp" && attribToBackup && parentTokenToBackup && attribToBackup.attribOpeningQuoteAt && attribToBackup.attribValueStartsAt && "'\"".includes(str[_i]) && str[attribToBackup.attribOpeningQuoteAt] === str[_i] && isAttrClosing(str, attribToBackup.attribOpeningQuoteAt, _i)) {
      token.end = _i;
      token.value = str.slice(token.start, _i);

      if (attribToBackup && !Array.isArray(attribToBackup.attribValue)) {
        attribToBackup.attribValue = [];
      }

      attribToBackup.attribValue.push(token);
      attribToBackup.attribValueEndsAt = _i;
      attribToBackup.attribValueRaw = str.slice(attribToBackup.attribValueStartsAt, _i);
      attribToBackup.attribClosingQuoteAt = _i;
      attribToBackup.attribEnds = _i + 1;
      token = lodash_clonedeep(parentTokenToBackup);
      token.attribs.push(attribToBackup);
      attribToBackup = undefined;
      parentTokenToBackup = undefined;
      layers.pop();
      layers.pop();
      layers.pop();
    }

    if (!doNothing && token.type === "tag" && !attrib.attribValueStartsAt && attrib.attribNameEndsAt && attrib.attribNameEndsAt <= _i && str[_i] && str[_i].trim()) {
      if (str[_i] === "=" && !SOMEQUOTE.includes(str[rightVal]) && !"=".includes(str[rightVal]) && !espChars.includes(str[rightVal])) {
        var firstQuoteOnTheRightIdx = SOMEQUOTE.split("").map(function (quote) {
          return str.indexOf(quote, rightVal);
        }).filter(function (val) {
          return val > 0;
        }).length ? Math.min.apply(Math, SOMEQUOTE.split("").map(function (quote) {
          return str.indexOf(quote, rightVal);
        }).filter(function (val) {
          return val > 0;
        })) : undefined;

        if (rightVal && str.slice(rightVal).includes("=") && allHtmlAttribs.has(str.slice(rightVal, rightVal + str.slice(rightVal).indexOf("=")).trim().toLowerCase())) {
          attrib.attribEnds = _i + 1;
          token.attribs.push(_objectSpread2({}, attrib));
          attribReset();
        } else if (!firstQuoteOnTheRightIdx || str.slice(rightVal, firstQuoteOnTheRightIdx).includes("=") || !str.includes(str[firstQuoteOnTheRightIdx], firstQuoteOnTheRightIdx + 1) || Array.from(str.slice(firstQuoteOnTheRightIdx + 1, str.indexOf(str[firstQuoteOnTheRightIdx], firstQuoteOnTheRightIdx + 1))).some(function (char) {
          return "<>=".includes(char);
        })) {
          attrib.attribValueStartsAt = rightVal;
          layers.push({
            type: "simple",
            value: null,
            position: attrib.attribValueStartsAt
          });
        }
      } else if (SOMEQUOTE.includes(str[_i])) {
        var nextCharIdx = rightVal;

        if (nextCharIdx && SOMEQUOTE.includes(str[nextCharIdx]) && str[_i] !== str[nextCharIdx] && str.length > nextCharIdx + 2 && str.slice(nextCharIdx + 1).includes(str[nextCharIdx]) && (!str.indexOf(str[nextCharIdx], nextCharIdx + 1) || !right(str, str.indexOf(str[nextCharIdx], nextCharIdx + 1)) || str[_i] !== str[right(str, str.indexOf(str[nextCharIdx], nextCharIdx + 1))]) && !Array.from(str.slice(nextCharIdx + 1, str.indexOf(str[nextCharIdx]))).some(function (char) {
          return ("<>=" + str[_i]).includes(char);
        })) {
          layers.pop();
        } else {
          if (!attrib.attribOpeningQuoteAt) {
            attrib.attribOpeningQuoteAt = _i;

            if (str[_i + 1] && (str[_i + 1] !== str[_i] || !ifQuoteThenAttrClosingQuote(_i + 1))) {
              attrib.attribValueStartsAt = _i + 1;
            }
          } else {
            /* istanbul ignore else */
            if (isAttrClosing(str, attrib.attribOpeningQuoteAt, _i)) {
              attrib.attribClosingQuoteAt = _i;
            }
            /* istanbul ignore else */


            if (attrib.attribOpeningQuoteAt && attrib.attribClosingQuoteAt) {
              if (attrib.attribOpeningQuoteAt < ~-attrib.attribClosingQuoteAt) {
                attrib.attribValueRaw = str.slice(attrib.attribOpeningQuoteAt + 1, attrib.attribClosingQuoteAt);
              } else {
                attrib.attribValueRaw = "";
              }

              attrib.attribEnds = _i + 1;
              token.attribs.push(lodash_clonedeep(attrib));
              attribReset();
            }
          }
        }
      }
    }

    if (!doNothing && str[_i] === ">" && str[_i - 1] !== "%" && token.type === "tag" && attrib.attribStarts && !attrib.attribEnds) {
      var thisIsRealEnding = false;

      if (str[_i + 1]) {
        for (var _y5 = _i + 1; _y5 < len; _y5++) {
          if (attrib.attribOpeningQuoteAt && str[_y5] === str[attrib.attribOpeningQuoteAt]) {
            if (_y5 !== _i + 1 && str[~-_y5] !== "=") {
              thisIsRealEnding = true;
            }

            break;
          } else if (str[_y5] === ">") {
            break;
          } else if (str[_y5] === "<") {
            thisIsRealEnding = true;
            layers.pop();
            break;
          } else if (!str[_y5 + 1]) {
            thisIsRealEnding = true;
            break;
          }
        }
      } else {
        thisIsRealEnding = true;
      }

      if (thisIsRealEnding) {
        token.end = _i + 1;
        token.value = str.slice(token.start, token.end);

        if (attrib.attribValueStartsAt && _i && attrib.attribValueStartsAt < _i && str.slice(attrib.attribValueStartsAt, _i).trim()) {
          attrib.attribValueEndsAt = _i;
          attrib.attribValueRaw = str.slice(attrib.attribValueStartsAt, _i);

          if (Array.isArray(attrib.attribValue) && attrib.attribValue.length && !attrib.attribValue[~-attrib.attribValue.length].end) {
            attrib.attribValue[~-attrib.attribValue.length].end = _i;
            attrib.attribValue[~-attrib.attribValue.length].value = str.slice(attrib.attribValue[~-attrib.attribValue.length].start, _i);
          }
        } else {
          attrib.attribValueStartsAt = null;
        }

        if (attrib.attribEnds === null) {
          attrib.attribEnds = _i;
        }

        if (attrib) {
          token.attribs.push(lodash_clonedeep(attrib));
          attribReset();
        }
      }
    }

    if (str[_i] && opts.charCb) {
      pingCharCb({
        type: token.type,
        chr: str[_i],
        i: _i
      });
    }

    if (!str[_i] && token.start !== null) {
      token.end = _i;
      token.value = str.slice(token.start, token.end);

      if (attrib && attrib.attribName) {
        if (!attrib.attribEnds) {
          attrib.attribEnds = _i;
        }

        token.attribs.push(_objectSpread2({}, attrib));
        attribReset();
      }

      if (token && Array.isArray(token.properties) && token.properties.length && !token.properties[~-token.properties.length].end) {
        token.properties[~-token.properties.length].end = _i;

        if (token.properties[~-token.properties.length].start && !token.properties[~-token.properties.length].value) {
          token.properties[~-token.properties.length].value = str.slice(token.properties[~-token.properties.length].start, _i);
        }
      }

      if (property && property.propertyStarts) {
        if (!property.end) {
          property.end = _i;
        }

        pushProperty(property);
        propertyReset();
      }

      pingTagCb(token);
    }

    if (str[_i] && str[_i].trim()) {
      lastNonWhitespaceCharAt = _i;
    }

    i = _i;
  };

  for (var i = 0; i <= len; i++) {
    var _ret2 = _loop2(i);

    if (_ret2 === "continue") continue;
  }

  if (charStash.length) {
    for (var _i2 = 0, len2 = charStash.length; _i2 < len2; _i2++) {
      reportFirstFromStash(charStash, opts.charCb, opts.charCbLookahead);
    }
  }

  if (tagStash.length) {
    for (var _i3 = 0, _len = tagStash.length; _i3 < _len; _i3++) {
      reportFirstFromStash(tagStash, opts.tagCb, opts.tagCbLookahead);
    }
  }

  var timeTakenInMilliseconds = Date.now() - start;
  return {
    timeTakenInMilliseconds: timeTakenInMilliseconds
  };
}

var objectPath = createCommonjsModule(function (module) {
  (function (root, factory) {
    /*istanbul ignore next:cant test*/

    {
      module.exports = factory();
    }
  })(commonjsGlobal, function () {

    var toStr = Object.prototype.toString;

    function hasOwnProperty(obj, prop) {
      if (obj == null) {
        return false;
      } //to handle objects with null prototypes (too edge case?)


      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    function isEmpty(value) {
      if (!value) {
        return true;
      }

      if (isArray(value) && value.length === 0) {
        return true;
      } else if (typeof value !== 'string') {
        for (var i in value) {
          if (hasOwnProperty(value, i)) {
            return false;
          }
        }

        return true;
      }

      return false;
    }

    function toString(type) {
      return toStr.call(type);
    }

    function isObject(obj) {
      return typeof obj === 'object' && toString(obj) === "[object Object]";
    }

    var isArray = Array.isArray || function (obj) {
      /*istanbul ignore next:cant test*/
      return toStr.call(obj) === '[object Array]';
    };

    function isBoolean(obj) {
      return typeof obj === 'boolean' || toString(obj) === '[object Boolean]';
    }

    function getKey(key) {
      var intKey = parseInt(key);

      if (intKey.toString() === key) {
        return intKey;
      }

      return key;
    }

    function factory(options) {
      options = options || {};

      var objectPath = function objectPath(obj) {
        return Object.keys(objectPath).reduce(function (proxy, prop) {
          if (prop === 'create') {
            return proxy;
          }
          /*istanbul ignore else*/


          if (typeof objectPath[prop] === 'function') {
            proxy[prop] = objectPath[prop].bind(objectPath, obj);
          }

          return proxy;
        }, {});
      };

      var hasShallowProperty;

      if (options.includeInheritedProps) {
        hasShallowProperty = function hasShallowProperty() {
          return true;
        };
      } else {
        hasShallowProperty = function hasShallowProperty(obj, prop) {
          return typeof prop === 'number' && Array.isArray(obj) || hasOwnProperty(obj, prop);
        };
      }

      function getShallowProperty(obj, prop) {
        if (hasShallowProperty(obj, prop)) {
          return obj[prop];
        }
      }

      function set(obj, path, value, doNotReplace) {
        if (typeof path === 'number') {
          path = [path];
        }

        if (!path || path.length === 0) {
          return obj;
        }

        if (typeof path === 'string') {
          return set(obj, path.split('.').map(getKey), value, doNotReplace);
        }

        var currentPath = path[0];
        var currentValue = getShallowProperty(obj, currentPath);

        if (options.includeInheritedProps && (currentPath === '__proto__' || currentPath === 'constructor' && typeof currentValue === 'function')) {
          throw new Error('For security reasons, object\'s magic properties cannot be set');
        }

        if (path.length === 1) {
          if (currentValue === void 0 || !doNotReplace) {
            obj[currentPath] = value;
          }

          return currentValue;
        }

        if (currentValue === void 0) {
          //check if we assume an array
          if (typeof path[1] === 'number') {
            obj[currentPath] = [];
          } else {
            obj[currentPath] = {};
          }
        }

        return set(obj[currentPath], path.slice(1), value, doNotReplace);
      }

      objectPath.has = function (obj, path) {
        if (typeof path === 'number') {
          path = [path];
        } else if (typeof path === 'string') {
          path = path.split('.');
        }

        if (!path || path.length === 0) {
          return !!obj;
        }

        for (var i = 0; i < path.length; i++) {
          var j = getKey(path[i]);

          if (typeof j === 'number' && isArray(obj) && j < obj.length || (options.includeInheritedProps ? j in Object(obj) : hasOwnProperty(obj, j))) {
            obj = obj[j];
          } else {
            return false;
          }
        }

        return true;
      };

      objectPath.ensureExists = function (obj, path, value) {
        return set(obj, path, value, true);
      };

      objectPath.set = function (obj, path, value, doNotReplace) {
        return set(obj, path, value, doNotReplace);
      };

      objectPath.insert = function (obj, path, value, at) {
        var arr = objectPath.get(obj, path);
        at = ~~at;

        if (!isArray(arr)) {
          arr = [];
          objectPath.set(obj, path, arr);
        }

        arr.splice(at, 0, value);
      };

      objectPath.empty = function (obj, path) {
        if (isEmpty(path)) {
          return void 0;
        }

        if (obj == null) {
          return void 0;
        }

        var value, i;

        if (!(value = objectPath.get(obj, path))) {
          return void 0;
        }

        if (typeof value === 'string') {
          return objectPath.set(obj, path, '');
        } else if (isBoolean(value)) {
          return objectPath.set(obj, path, false);
        } else if (typeof value === 'number') {
          return objectPath.set(obj, path, 0);
        } else if (isArray(value)) {
          value.length = 0;
        } else if (isObject(value)) {
          for (i in value) {
            if (hasShallowProperty(value, i)) {
              delete value[i];
            }
          }
        } else {
          return objectPath.set(obj, path, null);
        }
      };

      objectPath.push = function (obj, path
      /*, values */
      ) {
        var arr = objectPath.get(obj, path);

        if (!isArray(arr)) {
          arr = [];
          objectPath.set(obj, path, arr);
        }

        arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));
      };

      objectPath.coalesce = function (obj, paths, defaultValue) {
        var value;

        for (var i = 0, len = paths.length; i < len; i++) {
          if ((value = objectPath.get(obj, paths[i])) !== void 0) {
            return value;
          }
        }

        return defaultValue;
      };

      objectPath.get = function (obj, path, defaultValue) {
        if (typeof path === 'number') {
          path = [path];
        }

        if (!path || path.length === 0) {
          return obj;
        }

        if (obj == null) {
          return defaultValue;
        }

        if (typeof path === 'string') {
          return objectPath.get(obj, path.split('.'), defaultValue);
        }

        var currentPath = getKey(path[0]);
        var nextObj = getShallowProperty(obj, currentPath);

        if (nextObj === void 0) {
          return defaultValue;
        }

        if (path.length === 1) {
          return nextObj;
        }

        return objectPath.get(obj[currentPath], path.slice(1), defaultValue);
      };

      objectPath.del = function del(obj, path) {
        if (typeof path === 'number') {
          path = [path];
        }

        if (obj == null) {
          return obj;
        }

        if (isEmpty(path)) {
          return obj;
        }

        if (typeof path === 'string') {
          return objectPath.del(obj, path.split('.'));
        }

        var currentPath = getKey(path[0]);

        if (!hasShallowProperty(obj, currentPath)) {
          return obj;
        }

        if (path.length === 1) {
          if (isArray(obj)) {
            obj.splice(currentPath, 1);
          } else {
            delete obj[currentPath];
          }
        } else {
          return objectPath.del(obj[currentPath], path.slice(1));
        }

        return obj;
      };

      return objectPath;
    }

    var mod = factory();
    mod.create = factory;
    mod.withInheritedProps = factory({
      includeInheritedProps: true
    });
    return mod;
  });
});

var defaults$6 = {
  reportProgressFunc: null,
  reportProgressFuncFrom: 0,
  reportProgressFuncTo: 100,
  tagCb: null,
  charCb: null,
  errCb: null
};

function isObj$1(something) {
  return something && typeof something === "object" && !Array.isArray(something);
}

function layerPending(layers, tokenObj) {
  return tokenObj.closing && layers.length && (layers[layers.length - 1].type === tokenObj.type && Object.prototype.hasOwnProperty.call(layers[layers.length - 1], "tagName") && Object.prototype.hasOwnProperty.call(tokenObj, "tagName") && layers[layers.length - 1].tagName === tokenObj.tagName && layers[layers.length - 1].closing === false || tokenObj.type === "comment" && layers.some(function (layerObjToken) {
    return Object.prototype.hasOwnProperty.call(layerObjToken, "closing") && !layerObjToken.closing;
  }));
}

function cparser(str, originalOpts) {
  if (typeof str !== "string") {
    if (str === undefined) {
      throw new Error("codsen-tokenizer: [THROW_ID_01] the first input argument is completely missing! It should be given as string.");
    } else {
      throw new Error("codsen-tokenizer: [THROW_ID_02] the first input argument must be string! It was given as \"" + typeof str + "\", equal to:\n" + JSON.stringify(str, null, 4));
    }
  }

  if (originalOpts && !isObj$1(originalOpts)) {
    throw new Error("codsen-tokenizer: [THROW_ID_03] the second input argument, an options object, should be a plain object but it was given as type " + typeof originalOpts + ", equal to " + JSON.stringify(originalOpts, null, 4));
  }

  if (originalOpts && isObj$1(originalOpts) && originalOpts.tagCb && typeof originalOpts.tagCb !== "function") {
    throw new Error("codsen-tokenizer: [THROW_ID_04] the opts.tagCb, callback function, should be a function but it was given as type " + typeof originalOpts.tagCb + ", equal to " + JSON.stringify(originalOpts.tagCb, null, 4));
  }

  if (originalOpts && isObj$1(originalOpts) && originalOpts.charCb && typeof originalOpts.charCb !== "function") {
    throw new Error("codsen-tokenizer: [THROW_ID_05] the opts.charCb, callback function, should be a function but it was given as type " + typeof originalOpts.charCb + ", equal to " + JSON.stringify(originalOpts.charCb, null, 4));
  }

  if (originalOpts && isObj$1(originalOpts) && originalOpts.reportProgressFunc && typeof originalOpts.reportProgressFunc !== "function") {
    throw new Error("codsen-tokenizer: [THROW_ID_06] the opts.reportProgressFunc, callback function, should be a function but it was given as type " + typeof originalOpts.reportProgressFunc + ", equal to " + JSON.stringify(originalOpts.reportProgressFunc, null, 4));
  }

  if (originalOpts && isObj$1(originalOpts) && originalOpts.errCb && typeof originalOpts.errCb !== "function") {
    throw new Error("codsen-tokenizer: [THROW_ID_07] the opts.errCb, callback function, should be a function but it was given as type " + typeof originalOpts.errCb + ", equal to " + JSON.stringify(originalOpts.errCb, null, 4));
  }

  var opts = _objectSpread2(_objectSpread2({}, defaults$6), originalOpts);

  var layers = [];
  var res = [];
  var path = "";
  var nestNext = false;
  var lastProcessedToken = {};
  var tokensWithChildren = ["tag", "comment"];
  var tagNamesThatDontHaveClosings = ["doctype"];
  tokenizer(str, {
    reportProgressFunc: opts.reportProgressFunc,
    reportProgressFuncFrom: opts.reportProgressFuncFrom,
    reportProgressFuncTo: opts.reportProgressFuncTo,
    tagCbLookahead: 2,
    tagCb: function tagCb(tokenObj, next) {
      if (typeof opts.tagCb === "function") {
        opts.tagCb(tokenObj);
      }

      if (!tokenObj.nested) {
        var prevToken = objectPath.get(res, path);

        if (!isObj$1(prevToken)) {
          prevToken = null;
        }

        if (nestNext && !tokenObj.closing && (!lastProcessedToken.closing || lastProcessedToken.type === "comment" && lastProcessedToken.language === "html") && lastProcessedToken.type !== "text" && (!prevToken || !(prevToken.tagName === tokenObj.tagName && !prevToken.closing && tokenObj.closing)) && !layerPending(layers, tokenObj)) {
          nestNext = false;
          path = path + ".children.0";
        } else if (tokenObj.closing && typeof path === "string" && path.includes(".") && (!tokenObj.tagName || lastProcessedToken.tagName !== tokenObj.tagName || lastProcessedToken.closing)) {
          if (tokenObj.type === "comment" && tokenObj.closing && Array.isArray(layers) && layers.length && layers.some(function (l) {
            return l.type === "comment" && l.kind === tokenObj.kind;
          })) {
            for (var i = layers.length; i--;) {
              path = pathNext(pathUp(path));

              if (layers[i].type === "comment" && layers[i].kind === tokenObj.kind) {
                break;
              }
            }
          } else {
            path = pathNext(pathUp(path));
          }

          if (layerPending(layers, tokenObj)) {
            while (layers.length && layers[layers.length - 1].type !== tokenObj.type && layers[layers.length - 1].kind !== tokenObj.kind) {
              layers.pop();
            }

            layers.pop();
            nestNext = false;
          } else {
            if (layers.length && tokenObj.tagName && layers.some(function (layerObj) {
              return layerObj.type === "tag" && layerObj.tagName === tokenObj.tagName;
            })) {
              var lastLayer = layers.pop();
              var currTagName = lastLayer.tagName;

              while (currTagName !== tokenObj.tagName) {
                if (lastLayer && typeof opts.errCb === "function") {
                  opts.errCb({
                    ruleId: "" + lastLayer.type + (lastLayer.type === "comment" ? "-" + lastLayer.kind : "") + "-missing-closing",
                    idxFrom: lastLayer.start,
                    idxTo: lastLayer.end,
                    tokenObj: lastLayer
                  });
                }

                lastLayer = layers.pop();
                currTagName = lastLayer.tagName;
                path = pathNext(pathUp(path));
              }
            } else if (layers.length > 1 && layers[layers.length - 2].type === tokenObj.type && layers[layers.length - 2].type === tokenObj.type && layers[layers.length - 2].tagName === tokenObj.tagName) {
              if (typeof opts.errCb === "function") {
                var lastLayersToken = layers[layers.length - 1];
                opts.errCb({
                  ruleId: "tag-rogue",
                  idxFrom: lastLayersToken.start,
                  idxTo: lastLayersToken.end,
                  tokenObj: lastLayersToken
                });
              }

              layers.pop();
              layers.pop();
            } else ;
          }
        } else if (!path) {
          path = "0";
        } else {
          path = pathNext(path);

          if (layerPending(layers, tokenObj)) {
            layers.pop();
          }
        }

        if (tokensWithChildren.includes(tokenObj.type) && !tokenObj.void && Object.prototype.hasOwnProperty.call(tokenObj, "closing") && !tokenObj.closing) {
          nestNext = true;

          if (!tokenObj.kind || !tagNamesThatDontHaveClosings.includes(tokenObj.kind)) {
            layers.push(_objectSpread2({}, tokenObj));
          }
        }

        var previousPath = pathPrev(path) || "";
        var parentPath = pathUp(path);
        var parentTagsToken;

        if (parentPath && path.includes(".")) {
          parentTagsToken = objectPath.get(res, parentPath);
        }

        var previousTagsToken;

        if (previousPath) {
          previousTagsToken = objectPath.get(res, previousPath);
        }

        var suspiciousCommentTagEndingRegExp = /(-+|-+[^>])>/;
        var parentsLastChildTokenValue;
        var parentsLastChildTokenPath;

        if (isObj$1(previousTagsToken) && Array.isArray(previousTagsToken.children) && previousTagsToken.children.length && previousTagsToken.children[previousTagsToken.children.length - 1]) {
          parentsLastChildTokenValue = previousTagsToken.children[previousTagsToken.children.length - 1];
          parentsLastChildTokenPath = previousPath + ".children." + (objectPath.get(res, previousPath).children.length - 1);
        }

        var tokenTakenCareOf = false;

        if (tokenObj.type === "text" && isObj$1(parentTagsToken) && parentTagsToken.type === "comment" && parentTagsToken.kind === "simple" && !parentTagsToken.closing && suspiciousCommentTagEndingRegExp.test(tokenObj.value)) {
          var suspiciousEndingStartsAt = (suspiciousCommentTagEndingRegExp.exec(tokenObj.value) || {}).index;
          var suspiciousEndingEndsAt = (suspiciousEndingStartsAt || 0) + tokenObj.value.slice(suspiciousEndingStartsAt).indexOf(">") + 1;

          if (suspiciousEndingStartsAt && suspiciousEndingStartsAt > 0) {
            objectPath.set(res, path, _objectSpread2(_objectSpread2({}, tokenObj), {}, {
              end: tokenObj.start + suspiciousEndingStartsAt,
              value: tokenObj.value.slice(0, suspiciousEndingStartsAt)
            }));

            if (tokensWithChildren.includes(tokenObj.type)) {
              tokenObj.children = [];
            }
          }

          path = pathNext(pathUp(path));
          objectPath.set(res, path, {
            type: "comment",
            kind: "simple",
            closing: true,
            start: tokenObj.start + (suspiciousEndingStartsAt || 0),
            end: tokenObj.start + suspiciousEndingEndsAt,
            value: tokenObj.value.slice(suspiciousEndingStartsAt, suspiciousEndingEndsAt),
            children: []
          });

          if (suspiciousEndingEndsAt < tokenObj.value.length) {
            path = pathNext(path);
            objectPath.set(res, path, {
              type: "text",
              start: tokenObj.start + suspiciousEndingEndsAt,
              end: tokenObj.end,
              value: tokenObj.value.slice(suspiciousEndingEndsAt)
            });
          }

          tokenTakenCareOf = true;
        } else if (tokenObj.type === "comment" && tokenObj.kind === "only" && isObj$1(previousTagsToken)) {
          if (previousTagsToken.type === "text" && previousTagsToken.value.trim() && "<!-".includes(previousTagsToken.value[left(previousTagsToken.value, previousTagsToken.value.length)])) {
            var capturedMalformedTagRanges = [];
            findMalformed(previousTagsToken.value, "<!--", function (obj) {
              capturedMalformedTagRanges.push(obj);
            }, {
              maxDistance: 2
            });

            if (capturedMalformedTagRanges.length && !right(previousTagsToken.value, capturedMalformedTagRanges[capturedMalformedTagRanges.length - 1].idxTo - 1)) {
              var malformedRange = capturedMalformedTagRanges.pop();

              if (!left(previousTagsToken.value, malformedRange.idxFrom) && previousPath && isObj$1(previousTagsToken)) {
                if (tokensWithChildren.includes(tokenObj.type)) {
                  tokenObj.children = [];
                }

                path = previousPath;
                objectPath.set(res, path, _objectSpread2(_objectSpread2({}, tokenObj), {}, {
                  start: malformedRange.idxFrom + previousTagsToken.start,
                  kind: "not",
                  value: "" + previousTagsToken.value + tokenObj.value
                }));
                tokenTakenCareOf = true;
              } else if (previousPath && isObj$1(previousTagsToken)) {
                objectPath.set(res, previousPath, _objectSpread2(_objectSpread2({}, previousTagsToken), {}, {
                  end: malformedRange.idxFrom + previousTagsToken.start,
                  value: previousTagsToken.value.slice(0, malformedRange.idxFrom)
                }));

                if (tokensWithChildren.includes(tokenObj.type)) {
                  tokenObj.children = [];
                }

                objectPath.set(res, path, _objectSpread2(_objectSpread2({}, tokenObj), {}, {
                  start: malformedRange.idxFrom + previousTagsToken.start,
                  kind: "not",
                  value: "" + previousTagsToken.value.slice(malformedRange.idxFrom) + tokenObj.value
                }));
                tokenTakenCareOf = true;
              }
            }
          } else if (isObj$1(parentsLastChildTokenValue) && parentsLastChildTokenValue.type === "text" && parentsLastChildTokenValue.value.trim() && "<!-".includes(parentsLastChildTokenValue.value[left(parentsLastChildTokenValue.value, parentsLastChildTokenValue.value.length)])) {
            var _capturedMalformedTagRanges = [];
            findMalformed(parentsLastChildTokenValue.value, "<!--", function (obj) {
              _capturedMalformedTagRanges.push(obj);
            }, {
              maxDistance: 2
            });

            if (_capturedMalformedTagRanges.length && !right(parentsLastChildTokenValue.value, _capturedMalformedTagRanges[_capturedMalformedTagRanges.length - 1].idxTo - 1)) {
              var _malformedRange = _capturedMalformedTagRanges.pop();

              if (!left(parentsLastChildTokenValue.value, _malformedRange.idxFrom) && previousPath && isObj$1(parentsLastChildTokenValue)) {
                if (tokensWithChildren.includes(tokenObj.type)) {
                  tokenObj.children = [];
                }

                objectPath.set(res, path, _objectSpread2(_objectSpread2({}, tokenObj), {}, {
                  start: _malformedRange.idxFrom + parentsLastChildTokenValue.start,
                  kind: "not",
                  value: "" + parentsLastChildTokenValue.value + tokenObj.value
                }));
                objectPath.del(res, previousPath + ".children." + (objectPath.get(res, previousPath).children.length - 1));
                tokenTakenCareOf = true;
              } else if (previousPath && isObj$1(parentsLastChildTokenValue) && parentsLastChildTokenPath) {
                objectPath.set(res, parentsLastChildTokenPath, _objectSpread2(_objectSpread2({}, parentsLastChildTokenValue), {}, {
                  end: _malformedRange.idxFrom + parentsLastChildTokenValue.start,
                  value: parentsLastChildTokenValue.value.slice(0, _malformedRange.idxFrom)
                }));

                if (tokensWithChildren.includes(tokenObj.type)) {
                  tokenObj.children = [];
                }

                objectPath.set(res, path, _objectSpread2(_objectSpread2({}, tokenObj), {}, {
                  start: _malformedRange.idxFrom + parentsLastChildTokenValue.start,
                  kind: "not",
                  value: "" + parentsLastChildTokenValue.value.slice(_malformedRange.idxFrom) + tokenObj.value
                }));
                tokenTakenCareOf = true;
              }
            }
          }
        }

        if (!tokenTakenCareOf) {
          if (tokensWithChildren.includes(tokenObj.type)) {
            tokenObj.children = [];
          }

          objectPath.set(res, path, tokenObj);
        }

        if (tokensWithChildren.includes(tokenObj.type) && tokenObj.closing && (!previousPath || !isObj$1(previousTagsToken) || previousTagsToken.closing || previousTagsToken.type !== tokenObj.type || previousTagsToken.tagName !== tokenObj.tagName)) {
          if (tokenObj.void) {
            if (typeof opts.errCb === "function") {
              opts.errCb({
                ruleId: "tag-void-frontal-slash",
                idxFrom: tokenObj.start,
                idxTo: tokenObj.end,
                fix: {
                  ranges: [[tokenObj.start + 1, tokenObj.tagNameStartsAt]]
                },
                tokenObj: tokenObj
              });
            }
          } else {
            if (typeof opts.errCb === "function") {
              opts.errCb({
                ruleId: "" + tokenObj.type + (tokenObj.type === "comment" ? "-" + tokenObj.kind : "") + "-missing-opening",
                idxFrom: tokenObj.start,
                idxTo: tokenObj.end,
                tokenObj: tokenObj
              });
            }
          }
        }

        lastProcessedToken = _objectSpread2({}, tokenObj);
      }
    },
    charCb: opts.charCb
  });

  if (layers.length) {
    layers.forEach(function (tokenObj) {
      if (typeof opts.errCb === "function") {
        opts.errCb({
          ruleId: "" + tokenObj.type + (tokenObj.type === "comment" ? "-" + tokenObj.kind : "") + "-missing-closing",
          idxFrom: tokenObj.start,
          idxTo: tokenObj.end,
          tokenObj: tokenObj
        });
      }
    });
  }

  return res;
}

var escapeStringRegexp = function escapeStringRegexp(string) {
  if (typeof string !== 'string') {
    throw new TypeError('Expected a string');
  } // Escape characters with special meaning either inside or outside character sets.
  // Use a simple backslash escape when it’s always valid, and a \unnnn escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.


  return string.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
};

var regexpCache = new Map();

function sanitizeArray(input, inputName) {
  if (!Array.isArray(input)) {
    switch (typeof input) {
      case 'string':
        input = [input];
        break;

      case 'undefined':
        input = [];
        break;

      default:
        throw new TypeError("Expected '" + inputName + "' to be a string or an array, but got a type of '" + typeof input + "'");
    }
  }

  return input.filter(function (string) {
    if (typeof string !== 'string') {
      if (typeof string === 'undefined') {
        return false;
      }

      throw new TypeError("Expected '" + inputName + "' to be an array of strings, but found a type of '" + typeof string + "' in the array");
    }

    return true;
  });
}

function makeRegexp(pattern, options) {
  options = _objectSpread2({
    caseSensitive: false
  }, options);
  var cacheKey = pattern + JSON.stringify(options);

  if (regexpCache.has(cacheKey)) {
    return regexpCache.get(cacheKey);
  }

  var negated = pattern[0] === '!';

  if (negated) {
    pattern = pattern.slice(1);
  }

  pattern = escapeStringRegexp(pattern).replace(/\\\*/g, '[\\s\\S]*');
  var regexp = new RegExp("^" + pattern + "$", options.caseSensitive ? '' : 'i');
  regexp.negated = negated;
  regexpCache.set(cacheKey, regexp);
  return regexp;
}

var matcher = function matcher(inputs, patterns, options) {
  inputs = sanitizeArray(inputs, 'inputs');
  patterns = sanitizeArray(patterns, 'patterns');

  if (patterns.length === 0) {
    return [];
  }

  var isFirstPatternNegated = patterns[0][0] === '!';
  patterns = patterns.map(function (pattern) {
    return makeRegexp(pattern, options);
  });
  var result = [];

  for (var _iterator = _createForOfIteratorHelperLoose(inputs), _step; !(_step = _iterator()).done;) {
    var input = _step.value;
    // If first pattern is negated we include everything to match user expectation.
    var matches = isFirstPatternNegated;

    for (var _iterator2 = _createForOfIteratorHelperLoose(patterns), _step2; !(_step2 = _iterator2()).done;) {
      var pattern = _step2.value;

      if (pattern.test(input)) {
        matches = !pattern.negated;
      }
    }

    if (matches) {
      result.push(input);
    }
  }

  return result;
};

var isMatch = function isMatch(inputs, patterns, options) {
  inputs = sanitizeArray(inputs, 'inputs');
  patterns = sanitizeArray(patterns, 'patterns');

  if (patterns.length === 0) {
    return false;
  }

  return inputs.some(function (input) {
    return patterns.every(function (pattern) {
      var regexp = makeRegexp(pattern, options);
      var matches = regexp.test(input);
      return regexp.negated ? !matches : matches;
    });
  });
};
matcher.isMatch = isMatch;

var defineLazyProp = function defineLazyProp(object, propertyName, fn) {
  var define = function define(value) {
    return Object.defineProperty(object, propertyName, {
      value: value,
      enumerable: true,
      writable: true
    });
  };

  Object.defineProperty(object, propertyName, {
    configurable: true,
    enumerable: true,
    get: function get() {
      var result = fn();
      define(result);
      return result;
    },
    set: function set(value) {
      define(value);
    }
  });
  return object;
};

var allBadCharacterRules = ["bad-character-acknowledge", "bad-character-activate-arabic-form-shaping", "bad-character-activate-symmetric-swapping", "bad-character-application-program-command", "bad-character-backspace", "bad-character-bell", "bad-character-break-permitted-here", "bad-character-cancel", "bad-character-cancel-character", "bad-character-character-tabulation-set", "bad-character-character-tabulation-with-justification", "bad-character-control-0080", "bad-character-control-0081", "bad-character-control-0084", "bad-character-control-0099", "bad-character-control-sequence-introducer", "bad-character-data-link-escape", "bad-character-delete", "bad-character-device-control-four", "bad-character-device-control-one", "bad-character-device-control-string", "bad-character-device-control-three", "bad-character-device-control-two", "bad-character-em-quad", "bad-character-em-space", "bad-character-en-quad", "bad-character-en-space", "bad-character-end-of-medium", "bad-character-end-of-protected-area", "bad-character-end-of-selected-area", "bad-character-end-of-text", "bad-character-end-of-transmission", "bad-character-end-of-transmission-block", "bad-character-enquiry", "bad-character-escape", "bad-character-figure-space", "bad-character-first-strong-isolate", "bad-character-form-feed", "bad-character-four-per-em-space", "bad-character-function-application", "bad-character-hair-space", "bad-character-ideographic-space", "bad-character-information-separator-four", "bad-character-information-separator-one", "bad-character-information-separator-three", "bad-character-information-separator-two", "bad-character-inhibit-arabic-form-shaping", "bad-character-inhibit-symmetric-swapping", "bad-character-interlinear-annotation-anchor", "bad-character-interlinear-annotation-separator", "bad-character-interlinear-annotation-terminator", "bad-character-invisible-plus", "bad-character-invisible-separator", "bad-character-invisible-times", "bad-character-left-to-right-embedding", "bad-character-left-to-right-isolate", "bad-character-left-to-right-mark", "bad-character-left-to-right-override", "bad-character-line-separator", "bad-character-line-tabulation", "bad-character-line-tabulation-set", "bad-character-medium-mathematical-space", "bad-character-message-waiting", "bad-character-narrow-no-break-space", "bad-character-national-digit-shapes", "bad-character-negative-acknowledge", "bad-character-next-line", "bad-character-no-break-here", "bad-character-nominal-digit-shapes", "bad-character-non-breaking-space", "bad-character-null", "bad-character-ogham-space-mark", "bad-character-operating-system-command", "bad-character-paragraph-separator", "bad-character-partial-line-backward", "bad-character-partial-line-forward", "bad-character-pop-directional-formatting", "bad-character-pop-directional-isolate", "bad-character-private-message", "bad-character-private-use-1", "bad-character-private-use-2", "bad-character-punctuation-space", "bad-character-replacement-character", "bad-character-reverse-line-feed", "bad-character-right-to-left-embedding", "bad-character-right-to-left-isolate", "bad-character-right-to-left-mark", "bad-character-right-to-left-override", "bad-character-set-transmit-state", "bad-character-shift-in", "bad-character-shift-out", "bad-character-single-character-introducer", "bad-character-single-shift-three", "bad-character-single-shift-two", "bad-character-six-per-em-space", "bad-character-soft-hyphen", "bad-character-start-of-heading", "bad-character-start-of-protected-area", "bad-character-start-of-selected-area", "bad-character-start-of-string", "bad-character-start-of-text", "bad-character-string-terminator", "bad-character-substitute", "bad-character-synchronous-idle", "bad-character-tabulation", "bad-character-thin-space", "bad-character-three-per-em-space", "bad-character-word-joiner", "bad-character-zero-width-joiner", "bad-character-zero-width-no-break-space", "bad-character-zero-width-non-joiner", "bad-character-zero-width-space"];

var allTagRules = ["tag-bad-self-closing", "tag-bold", "tag-closing-backslash", "tag-is-present", "tag-malformed", "tag-missing-closing", "tag-missing-opening", "tag-name-case", "tag-rogue", "tag-space-after-opening-bracket", "tag-space-before-closing-bracket", "tag-space-between-slash-and-bracket", "tag-table", "tag-void-frontal-slash", "tag-void-slash"];

var allAttribRules = ["attribute-duplicate", "attribute-enforce-img-alt", "attribute-malformed", "attribute-on-closing-tag"];

var allCSSRules = ["css-rule-malformed", "css-trailing-semi"];

var allBadNamedHTMLEntityRules = ["bad-malformed-numeric-character-entity", "bad-named-html-entity-malformed-nbsp", "bad-named-html-entity-multiple-encoding", "bad-named-html-entity-not-email-friendly", "bad-named-html-entity-unrecognised"];

function splitByWhitespace(str, cbValues, cbWhitespace, originalOpts) {
  // console.log(
  //   `003 splitByWhitespace(): ${`\u001b[${36}m${`traverse and extract`}\u001b[${39}m`}`
  // );
  var defaults = {
    offset: 0,
    from: 0,
    to: str.length
  };

  var opts = _objectSpread2(_objectSpread2({}, defaults), originalOpts);

  var nameStartsAt = null;
  var whitespaceStartsAt = null;

  for (var i = opts.from; i < opts.to; i++) {
    // console.log(
    //   `018 ${`\u001b[${36}m${`------------------------------------------------\nstr[${i}]`}\u001b[${39}m`} = ${JSON.stringify(
    //     str[i],
    //     null,
    //     4
    //   )}`
    // );
    // catch the beginning of a whitespace
    if (whitespaceStartsAt === null && !str[i].trim().length) {
      whitespaceStartsAt = i; // console.log(
      //   `029 splitByWhitespace(): ${`\u001b[${32}m${`SET`}\u001b[${39}m`} ${`\u001b[${33}m${`whitespaceStartsAt`}\u001b[${39}m`} = ${whitespaceStartsAt}`
      // );
    } // catch the ending of a whitespace


    if (whitespaceStartsAt !== null && (str[i].trim().length || i + 1 === opts.to)) {
      // console.log(
      //   `039 ${`\u001b[${32}m${`PING`}\u001b[${39}m`} whitespace [${whitespaceStartsAt}, ${
      //     str[i].trim().length ? i : i + 1
      //   }]`
      // );
      if (typeof cbWhitespace === "function") {
        cbWhitespace([whitespaceStartsAt + opts.offset, (str[i].trim().length ? i : i + 1) + opts.offset]);
      }

      whitespaceStartsAt = null; // console.log(
      //   `051 splitByWhitespace(): ${`\u001b[${31}m${`RESET`}\u001b[${39}m`} ${`\u001b[${33}m${`whitespaceStartsAt`}\u001b[${39}m`} = ${whitespaceStartsAt}`
      // );
    } // catch the beginning of a name


    if (nameStartsAt === null && str[i].trim().length) {
      nameStartsAt = i; // console.log(
      //   `059 splitByWhitespace(): ${`\u001b[${32}m${`SET`}\u001b[${39}m`} ${`\u001b[${33}m${`nameStartsAt`}\u001b[${39}m`} = ${nameStartsAt}`
      // );
    } // catch the ending of a name


    if (nameStartsAt !== null && (!str[i].trim().length || i + 1 === opts.to)) {
      // console.log(
      //   `066 splitByWhitespace(): ${`\u001b[${32}m${`██`}\u001b[${39}m`} ${`\u001b[${32}m${`carved out ${opts.typeName} name`}\u001b[${39}m`} ${JSON.stringify(
      //     str.slice(
      //       nameStartsAt,
      //       i + 1 === opts.to && str[i].trim().length ? i + 1 : i
      //     ),
      //     null,
      //     0
      //   )}`
      // );
      // // call CB
      // console.log(
      //   `078 ${`\u001b[${32}m${`PING`}\u001b[${39}m`} chunk [${nameStartsAt}, ${
      //     i + 1 === opts.to ? i + 1 && str[i].trim().length : i
      //   }]`
      // );
      if (typeof cbValues === "function") {
        cbValues([nameStartsAt + opts.offset, (i + 1 === opts.to && str[i].trim().length ? i + 1 : i) + opts.offset]);
      } // reset


      nameStartsAt = null; // console.log(
      //   `092 splitByWhitespace(): ${`\u001b[${31}m${`RESET`}\u001b[${39}m`} ${`\u001b[${33}m${`nameStartsAt`}\u001b[${39}m`} = ${nameStartsAt}`
      // );
    } // console.log(" ");
    // console.log(" ");
    // console.log(
    //   `${`\u001b[${90}m${`1 splitByWhitespace(): ██ nameStartsAt = ${nameStartsAt}; whitespaceStartsAt = ${whitespaceStartsAt}`}\u001b[${39}m`}`
    // );
    // console.log(" ");
    // console.log(" ");

  }
}

function processCommaSep(str, originalOpts) {
  if (typeof str !== "string") {
    throw new Error("string-process-comma-separated: [THROW_ID_01] input must be string! It was given as " + typeof str + ", equal to:\n" + JSON.stringify(str, null, 4));
  } else if (!str.length || !originalOpts || !originalOpts.cb && !originalOpts.errCb) {
    return;
  }

  var defaults = {
    from: 0,
    to: str.length,
    offset: 0,
    leadingWhitespaceOK: false,
    trailingWhitespaceOK: false,
    oneSpaceAfterCommaOK: false,
    innerWhitespaceAllowed: false,
    separator: ",",
    cb: null,
    errCb: null
  };

  var opts = _objectSpread2(_objectSpread2({}, defaults), originalOpts);

  if (!Number.isInteger(originalOpts.from)) {
    opts.from = 0;
  }

  if (!Number.isInteger(originalOpts.to)) {
    opts.to = str.length;
  }

  if (!Number.isInteger(originalOpts.offset)) {
    opts.offset = 0;
  }

  var chunkStartsAt = null;
  var whitespaceStartsAt = null;
  var firstNonwhitespaceNonseparatorCharFound = false;
  var separatorsArr = [];
  var lastNonWhitespaceCharAt = null;
  var fixable = true;

  for (var i = opts.from; i < opts.to; i++) {
    if (str[i].trim() && str[i] !== opts.separator) {
      lastNonWhitespaceCharAt = i;
    }

    if (chunkStartsAt === null && str[i].trim() && (!opts.separator || str[i] !== opts.separator)) {
      if (!firstNonwhitespaceNonseparatorCharFound) {
        firstNonwhitespaceNonseparatorCharFound = true;
      }

      if (separatorsArr.length) {
        if (separatorsArr.length > 1) {
          separatorsArr.forEach(function (separatorsIdx, orderNumber) {
            if (orderNumber) {
              opts.errCb([[separatorsIdx + opts.offset, separatorsIdx + 1 + opts.offset]], "Remove separator.", fixable);
            }
          });
        }

        separatorsArr = [];
      }

      chunkStartsAt = i;
    }

    if (Number.isInteger(chunkStartsAt) && (i > chunkStartsAt && opts.separator && str[i] === opts.separator || i + 1 === opts.to)) {
      str.slice(chunkStartsAt, i + 1 === opts.to && str[i] !== opts.separator && str[i].trim() ? i + 1 : i);

      if (typeof opts.cb === "function") {
        opts.cb(chunkStartsAt + opts.offset, (i + 1 === opts.to && str[i] !== opts.separator && str[i].trim() ? i + 1 : lastNonWhitespaceCharAt + 1) + opts.offset);
      }

      chunkStartsAt = null;
    }

    if (!str[i].trim() && whitespaceStartsAt === null) {
      whitespaceStartsAt = i;
    }

    if (whitespaceStartsAt !== null && (str[i].trim() || i + 1 === opts.to)) {
      if (whitespaceStartsAt === opts.from) {
        if (!opts.leadingWhitespaceOK && typeof opts.errCb === "function") {
          opts.errCb([[whitespaceStartsAt + opts.offset, (i + 1 === opts.to ? i + 1 : i) + opts.offset]], "Remove whitespace.", fixable);
        }
      } else if (!str[i].trim() && i + 1 === opts.to) {
        if (!opts.trailingWhitespaceOK && typeof opts.errCb === "function") {
          opts.errCb([[whitespaceStartsAt + opts.offset, i + 1 + opts.offset]], "Remove whitespace.", fixable);
        }
      } else if ((!opts.oneSpaceAfterCommaOK || !(str[i].trim() && i > opts.from + 1 && str[i - 1] === " " && str[i - 2] === ",")) && (!opts.innerWhitespaceAllowed || !(firstNonwhitespaceNonseparatorCharFound && str[whitespaceStartsAt - 1] && str[i].trim() && str[i] !== opts.separator && str[whitespaceStartsAt - 1] !== opts.separator))) {
        var startingIdx = whitespaceStartsAt;
        var endingIdx = i;

        if (i + 1 === opts.to && str[i] !== opts.separator && !str[i].trim()) {
          endingIdx += 1;
        }

        var whatToAdd = "";

        if (opts.oneSpaceAfterCommaOK) {
          if (str[whitespaceStartsAt] === " " && str[whitespaceStartsAt - 1] === opts.separator) {
            startingIdx += 1;
          } else if (str[whitespaceStartsAt] !== " ") {
            whatToAdd = " ";
          }
        }

        var message = "Remove whitespace.";

        if (!opts.innerWhitespaceAllowed && firstNonwhitespaceNonseparatorCharFound && str[whitespaceStartsAt - 1] && str[i].trim() && str[i] !== opts.separator && str[whitespaceStartsAt - 1] !== opts.separator) {
          fixable = false;
          message = "Bad whitespace.";
        }

        if (whatToAdd.length) {
          opts.errCb([[startingIdx + opts.offset, endingIdx + opts.offset, whatToAdd]], message, fixable);
        } else {
          opts.errCb([[startingIdx + opts.offset, endingIdx + opts.offset]], message, fixable);
        }

        fixable = true;
      }

      whitespaceStartsAt = null;
    }

    if (str[i] === opts.separator) {
      if (!firstNonwhitespaceNonseparatorCharFound) {
        opts.errCb([[i + opts.offset, i + 1 + opts.offset]], "Remove separator.", fixable);
      } else {
        separatorsArr.push(i);
      }
    }

    if (i + 1 === opts.to) {
      separatorsArr.forEach(function (separatorsIdx) {
        opts.errCb([[separatorsIdx + opts.offset, separatorsIdx + 1 + opts.offset]], "Remove separator.", fixable);
      });
    }
  }
}

function checkForWhitespace(str, idxOffset) {
  // insurance
  if (typeof str !== "string") {
    return {
      charStart: 0,
      charEnd: 0,
      errorArr: [],
      trimmedVal: ""
    };
  } // We'll catch surrounding whitespace and validate the value in one go. This means, we need to know where non-whitespace value is:


  var charStart = 0; // defaults

  var charEnd = str.length;
  var trimmedVal;
  var gatheredRanges = [];
  var errorArr = []; // tackle the inner wrapping whitespace first
  // ...left side:

  if (!str.length || !str[0].trim().length) {
    charStart = right(str); // returns digit or null - index of next non whitespace char on the right

    if (!str.length || charStart === null) {
      // it's just whitespace here
      charEnd = null;
      errorArr.push({
        idxFrom: +idxOffset,
        idxTo: +idxOffset + str.length,
        message: "Missing value.",
        fix: null // can't fix - value is missing completely!

      });
    } else {
      gatheredRanges.push([idxOffset, idxOffset + charStart]);
    }
  } // ...right side:


  if (charEnd && !str[str.length - 1].trim()) {
    charEnd = left(str, str.length - 1) + 1;
    gatheredRanges.push([idxOffset + charEnd, idxOffset + str.length]);
  }

  if (!gatheredRanges.length) {
    trimmedVal = str;
  } else {
    errorArr.push({
      idxFrom: gatheredRanges[0][0],
      idxTo: gatheredRanges[gatheredRanges.length - 1][1],
      message: "Remove whitespace.",
      fix: {
        ranges: lodash_clonedeep(gatheredRanges)
      } // we can fix - we delete this whitespace!

    }); // reset:

    gatheredRanges.length = 0;
    trimmedVal = str.trim();
  }
  return {
    charStart: charStart,
    charEnd: charEnd,
    errorArr: errorArr,
    trimmedVal: trimmedVal
  };
}

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash_isregexp = createCommonjsModule(function (module, exports) {
  /** `Object#toString` result references. */
  var regexpTag = '[object RegExp]';
  /** Detect free variable `global` from Node.js. */

  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  /** Detect free variable `exports`. */

  var freeExports = exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports = freeModule && freeModule.exports === freeExports;
  /** Detect free variable `process` from Node.js. */

  var freeProcess = moduleExports && freeGlobal.process;
  /** Used to access faster Node.js helpers. */

  var nodeUtil = function () {
    try {
      return freeProcess && freeProcess.binding('util');
    } catch (e) {}
  }();
  /* Node.js helper references. */


  var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */

  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }
  /** Used for built-in method references. */


  var objectProto = Object.prototype;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
   * of values.
   */

  var objectToString = objectProto.toString;
  /**
   * The base implementation of `_.isRegExp` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
   */

  function baseIsRegExp(value) {
    return isObject(value) && objectToString.call(value) == regexpTag;
  }
  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */


  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }
  /**
   * Checks if `value` is classified as a `RegExp` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
   * @example
   *
   * _.isRegExp(/abc/);
   * // => true
   *
   * _.isRegExp('/abc/');
   * // => false
   */


  var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
  module.exports = isRegExp;
});

var defaults$5 = {
  caseInsensitive: false
};

function includesWithRegex(arr, whatToMatch, originalOpts) {
  var opts = _objectSpread2(_objectSpread2({}, defaults$5), originalOpts);

  if (!Array.isArray(arr) || !arr.length) {
    // definitely does not include
    return false;
  } // console.log(
  //   `017 includesWithRegex(): ${`\u001b[${33}m${`whatToMatch`}\u001b[${39}m`} = ${JSON.stringify(
  //     whatToMatch,
  //     null,
  //     4
  //   )}`
  // );


  return arr.some(function (val) {
    return lodash_isregexp(val) && whatToMatch.match(val) || typeof val === "string" && (!opts.caseInsensitive && whatToMatch === val || opts.caseInsensitive && whatToMatch.toLowerCase() === val.toLowerCase());
  });
}

var defaults$4 = {
  caseInsensitive: false,
  canBeCommaSeparated: false,
  quickPermittedValues: [],
  permittedValues: [],
  noSpaceAfterComma: false
}; // if value is not comma-separated chain of values, whole thing is passed to this
// if value is comma-separated, each extracted chunk is passed to this
// we keep it separate to keep it DRY

function validateValue$2(str, idxOffset, opts, charStart, charEnd, errorArr) {
  var extractedValue = str.slice(charStart, charEnd);

  if (!(includesWithRegex(opts.quickPermittedValues, extractedValue, {
    caseInsensitive: opts.caseInsensitive
  }) || includesWithRegex(opts.permittedValues, extractedValue, {
    caseInsensitive: opts.caseInsensitive
  }))) {
    var fix = null;
    var message = "Unrecognised value: \"" + str.slice(charStart, charEnd) + "\".";

    if (includesWithRegex(opts.quickPermittedValues, extractedValue.toLowerCase()) || includesWithRegex(opts.permittedValues, extractedValue.toLowerCase())) {
      message = "Should be lowercase.";
      fix = {
        ranges: [[charStart + idxOffset, charEnd + idxOffset, extractedValue.toLowerCase()]]
      };
    } else if (Array.isArray(opts.quickPermittedValues) && opts.quickPermittedValues.length && opts.quickPermittedValues.length < 6 && opts.quickPermittedValues.every(function (val) {
      return typeof val === "string";
    }) && (!Array.isArray(opts.permittedValues) || !opts.permittedValues.length) && opts.quickPermittedValues.join("|").length < 40) {
      // if all reference values are strings, if the case is simple,
      // for example, <td dir="tralala">, instead of message:
      // Unrecognised value: "tralala".
      // we can say:
      // Should be "rtl|ltr"
      message = "Should be \"" + opts.quickPermittedValues.join("|") + "\".";
    } else if (Array.isArray(opts.permittedValues) && opts.permittedValues.length && opts.permittedValues.length < 6 && opts.permittedValues.every(function (val) {
      return typeof val === "string";
    }) && (!Array.isArray(opts.quickPermittedValues) || !opts.quickPermittedValues.length) && opts.permittedValues.join("|").length < 40) {
      // if all reference values are strings, if the case is simple,
      // for example, <td dir="tralala">, instead of message:
      // Unrecognised value: "tralala".
      // we can say:
      // Should be "rtl|ltr"
      message = "Should be \"" + opts.permittedValues.join("|") + "\".";
    }

    errorArr.push({
      idxFrom: charStart + idxOffset,
      idxTo: charEnd + idxOffset,
      message: message,
      fix: fix
    });
  }
}

function validateString(str, idxOffset, originalOpts) {

  var opts = _objectSpread2(_objectSpread2({}, defaults$4), originalOpts); // we get trimmed string start and end positions, also an encountered errors array


  var _checkForWhitespace = checkForWhitespace(str, idxOffset),
      charStart = _checkForWhitespace.charStart,
      charEnd = _checkForWhitespace.charEnd,
      errorArr = _checkForWhitespace.errorArr;

  if (typeof charStart === "number" && typeof charEnd === "number") {
    // continue checks only if there are non-whitespace characters in the value
    if (opts.canBeCommaSeparated) {
      processCommaSep(str, {
        offset: idxOffset,
        oneSpaceAfterCommaOK: false,
        leadingWhitespaceOK: true,
        trailingWhitespaceOK: true,
        cb: function cb(idxFrom, idxTo) {
          str.slice(idxFrom - idxOffset, idxTo - idxOffset); // if there are errors, validateValue() mutates the passed "errorArr",
          // pushing to it

          validateValue$2(str, idxOffset, opts, idxFrom - idxOffset, // processCommaSep() reports offset values so we need to restore indexes to start where this "str" above starts
          idxTo - idxOffset, errorArr);
        },
        errCb: function errCb(ranges, message) {
          errorArr.push({
            idxFrom: ranges[0][0],
            idxTo: ranges[ranges.length - 1][1],
            message: message,
            fix: {
              ranges: ranges
            }
          });
        }
      });
    } else {
      str.slice(charStart, charEnd); // if there are errors, validateValue() mutates the passed "errorArr",
      // pushing to it

      validateValue$2(str, idxOffset, opts, charStart, charEnd, errorArr);
    }
  }
  return errorArr;
}

var wholeExtensionRegex = /^\.\w+$/g; // Regex is not so strict, to cover variations without miliseconds.
// Also, we don't use capturing groups because we don't extract, only validate.
// 2019-07-09T15:03:36Z (https://www.npmjs.com/package/iso-datestring-validator)
// 2011-10-05T14:48:00.000Z (https://www.npmjs.com/package/regex-iso-date)

var isoDateRegex = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z/g;
var fontSizeRegex = /^[+-]?[1-7]$/;
var linkTypes = ["apple-touch-icon", "apple-touch-startup-image", "alternate", "archives", "appendix", "author", "bookmark", "canonical", "chapter", "contents", "copyright", "dns-prefetch", "external", "first", "glossary", "help", "icon", "import", "index", "last", "license", "manifest", "modulepreload", "next", "nofollow", "noopener", "noreferrer", "opener", "pingback", "preconnect", "prefetch", "preload", "prerender", "prev", "search", "shortlink", "section", "sidebar", "start", "stylesheet", "subsection", "tag", "up"];
var astErrMessages = {
  "tag-missing-opening": "Opening tag is missing.",
  "tag-missing-closing": "Closing tag is missing.",
  "tag-void-frontal-slash": "Remove frontal slash."
}; // -----------------------------------------------------------------------------

function isLetter(str) {
  return typeof str === "string" && str.length === 1 && str.toUpperCase() !== str.toLowerCase();
}

function isAnEnabledValue(maybeARulesValue) {
  if (Number.isInteger(maybeARulesValue) && maybeARulesValue > 0) {
    return maybeARulesValue;
  }

  if (Array.isArray(maybeARulesValue) && maybeARulesValue.length && Number.isInteger(maybeARulesValue[0]) && maybeARulesValue[0] > 0) {
    return maybeARulesValue[0];
  }

  return 0;
}

function isObj(something) {
  return !!(something && typeof something === "object" && !Array.isArray(something));
}

function isAnEnabledRule(rules, ruleId) {
  if (!ruleId) {
    return 0;
  }

  if (isObj(rules) && Object.prototype.hasOwnProperty.call(rules, ruleId)) {
    return rules[ruleId];
  }

  if (ruleId.includes("-") && Object.prototype.hasOwnProperty.call(rules, ruleId.split("-")[0])) {
    return rules[ruleId.split("-")[0]];
  }

  if (isObj(rules) && Object.prototype.hasOwnProperty.call(rules, "all")) {
    return rules.all;
  } // default return - rule's off:


  return 0; // Object.keys(rules.rules).some(
  //   ruleName =>
  //     (ruleName === "all" || // group blanket setting
  //     ruleName === "tag" || // group blanket setting
  //       ruleName.startsWith(obj.ruleId)) &&
  //     (isAnEnabledValue(rules.rules[ruleName]) ||
  //       isAnEnabledValue(processedRulesConfig[ruleName]))
  // )
} // -----------------------------------------------------------------------------

var util = /*#__PURE__*/Object.freeze({
__proto__: null,
wholeExtensionRegex: wholeExtensionRegex,
splitByWhitespace: splitByWhitespace,
isAnEnabledValue: isAnEnabledValue,
isAnEnabledRule: isAnEnabledRule,
astErrMessages: astErrMessages,
validateString: validateString,
fontSizeRegex: fontSizeRegex,
isoDateRegex: isoDateRegex,
linkTypes: linkTypes,
isLetter: isLetter,
isObj: isObj
});

// rule: bad-character-null
// -----------------------------------------------------------------------------
// Catches raw character "NULL":
// https://www.fileformat.info/info/unicode/char/0000/index.htm
function badCharacterNull(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 0) {
        context.report({
          ruleId: "bad-character-null",
          message: "Bad character - NULL.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-start-of-heading
// -----------------------------------------------------------------------------
// Catches raw character "START OF HEADING":
// https://www.fileformat.info/info/unicode/char/0001/index.htm
function badCharacterStartOfHeading(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 1) {
        context.report({
          ruleId: "bad-character-start-of-heading",
          message: "Bad character - START OF HEADING.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-start-of-text
// -----------------------------------------------------------------------------
// Catches raw character "START OF TEXT":
// https://www.fileformat.info/info/unicode/char/0002/index.htm
function badCharacterStartOfText(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 2) {
        context.report({
          ruleId: "bad-character-start-of-text",
          message: "Bad character - START OF TEXT.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-end-of-text
// -----------------------------------------------------------------------------
// Catches raw character "END OF TEXT":
// https://www.fileformat.info/info/unicode/char/0003/index.htm
function badCharacterEndOfText(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 3) {
        context.report({
          ruleId: "bad-character-end-of-text",
          message: "Bad character - END OF TEXT.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1, "\n"]] // replace with line break

          }
        });
      }
    }
  };
}

// rule: bad-character-end-of-transmission
// -----------------------------------------------------------------------------
// Catches raw character "END OF TRANSMISSION":
// https://www.fileformat.info/info/unicode/char/0004/index.htm
function badCharacterEndOfTransmission(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 4) {
        context.report({
          ruleId: "bad-character-end-of-transmission",
          message: "Bad character - END OF TRANSMISSION.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-enquiry
// -----------------------------------------------------------------------------
// Catches raw character "ENQUIRY":
// https://www.fileformat.info/info/unicode/char/0005/index.htm
function badCharacterEnquiry(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 5) {
        context.report({
          ruleId: "bad-character-enquiry",
          message: "Bad character - ENQUIRY.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-acknowledge
// -----------------------------------------------------------------------------
// Catches raw character "ACKNOWLEDGE":
// https://www.fileformat.info/info/unicode/char/0006/index.htm
function badCharacterAcknowledge(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 6) {
        context.report({
          ruleId: "bad-character-acknowledge",
          message: "Bad character - ACKNOWLEDGE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-bell
// -----------------------------------------------------------------------------
// Catches raw character "BELL":
// https://www.fileformat.info/info/unicode/char/0007/index.htm
function badCharacterBell(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 7) {
        context.report({
          ruleId: "bad-character-bell",
          message: "Bad character - BELL.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-backspace
// -----------------------------------------------------------------------------
// Catches raw character "BACKSPACE":
// https://www.fileformat.info/info/unicode/char/0008/index.htm
function badCharacterBackspace(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8) {
        context.report({
          ruleId: "bad-character-backspace",
          message: "Bad character - BACKSPACE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-tabulation

var badCharacterTabulation = function badCharacterTabulation(context) {
  for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    originalOpts[_key - 1] = arguments[_key];
  } // indentation tabs might be OK, check config.
  // tabs between text not OK.
  // tabs trailing lines, leading to EOL or line break, not OK. ("right-side indentation")
  // plan: use "leftStopAtNewLines" method, it stops at first non-whitespace
  // character or linebreaks of both kinds: CR or LF.

  var mode = "never";

  if (Array.isArray(originalOpts) && originalOpts[0] && typeof originalOpts[0] === "string" && originalOpts[0].toLowerCase() === "indentationisfine") {
    mode = "indentationIsFine";
  }

  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 9) {
        if (mode === "never") {
          // simple - there can't be any TABs, so raise it straight away
          context.report({
            ruleId: "bad-character-tabulation",
            message: "Bad character - TABULATION.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1, " "]] // replace with one space

            }
          });
        } else if (mode === "indentationIsFine") {
          // leftStopAtNewLines() will stop either at first non-whitespace character
          // on the left, or LF or CR. By evaluating the trim of it, we can
          // filter out cases where it's non-whitespace character. In other
          // words, that's TAB in the middle of the line, between letter characters.
          var charTopOnBreaksIdx = leftStopAtNewLines(context.str, i);

          if (charTopOnBreaksIdx !== null && context.str[charTopOnBreaksIdx].trim().length) {
            context.report({
              ruleId: "bad-character-tabulation",
              message: "Bad character - TABULATION.",
              idxFrom: i,
              idxTo: i + 1,
              fix: {
                ranges: [[i, i + 1, " "]] // replace with one space

              }
            });
          }
        }
      }
    }
  };
};

// rule: bad-character-line-tabulation
// -----------------------------------------------------------------------------
// Catches raw character "LINE TABULATION":
// https://www.fileformat.info/info/unicode/char/000b/index.htm
function badCharacterLineTabulation(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 11) {
        context.report({
          ruleId: "bad-character-line-tabulation",
          message: "Bad character - LINE TABULATION.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-form-feed
// -----------------------------------------------------------------------------
// Catches raw character "FORM FEED":
// https://www.fileformat.info/info/unicode/char/000c/index.htm
function badCharacterFormFeed(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 12) {
        context.report({
          ruleId: "bad-character-form-feed",
          message: "Bad character - FORM FEED.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-shift-out
// -----------------------------------------------------------------------------
// Catches raw character "SHIFT OUT":
// https://www.fileformat.info/info/unicode/char/000e/index.htm
function badCharacterShiftOut(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 14) {
        context.report({
          ruleId: "bad-character-shift-out",
          message: "Bad character - SHIFT OUT.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-shift-in
// -----------------------------------------------------------------------------
// Catches raw character "SHIFT IN":
// https://www.fileformat.info/info/unicode/char/000f/index.htm
function badCharacterShiftIn(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 15) {
        context.report({
          ruleId: "bad-character-shift-in",
          message: "Bad character - SHIFT IN.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-data-link-escape
// -----------------------------------------------------------------------------
// Catches raw character "DATA LINK ESCAPE":
// https://www.fileformat.info/info/unicode/char/0010/index.htm
function badCharacterDataLinkEscape(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 16) {
        context.report({
          ruleId: "bad-character-data-link-escape",
          message: "Bad character - DATA LINK ESCAPE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-device-control-one
// -----------------------------------------------------------------------------
// Catches raw character "DEVICE CONTROL ONE":
// https://www.fileformat.info/info/unicode/char/0011/index.htm
function badCharacterDeviceControlOne(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 17) {
        context.report({
          ruleId: "bad-character-device-control-one",
          message: "Bad character - DEVICE CONTROL ONE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-device-control-two
// -----------------------------------------------------------------------------
// Catches raw character "DEVICE CONTROL TWO":
// https://www.fileformat.info/info/unicode/char/0012/index.htm
function badCharacterDeviceControlTwo(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 18) {
        context.report({
          ruleId: "bad-character-device-control-two",
          message: "Bad character - DEVICE CONTROL TWO.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-device-control-three
// -----------------------------------------------------------------------------
// Catches raw character "DEVICE CONTROL THREE":
// https://www.fileformat.info/info/unicode/char/0013/index.htm
function badCharacterDeviceControlThree(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 19) {
        context.report({
          ruleId: "bad-character-device-control-three",
          message: "Bad character - DEVICE CONTROL THREE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-device-control-four
// -----------------------------------------------------------------------------
// Catches raw character "DEVICE CONTROL FOUR":
// https://www.fileformat.info/info/unicode/char/0014/index.htm
function badCharacterDeviceControlFour(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 20) {
        context.report({
          ruleId: "bad-character-device-control-four",
          message: "Bad character - DEVICE CONTROL FOUR.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-negative-acknowledge
// -----------------------------------------------------------------------------
// Catches raw character "NEGATIVE ACKNOWLEDGE":
// https://www.fileformat.info/info/unicode/char/0015/index.htm
function badCharacterNegativeAcknowledge(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 21) {
        context.report({
          ruleId: "bad-character-negative-acknowledge",
          message: "Bad character - NEGATIVE ACKNOWLEDGE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-synchronous-idle
// -----------------------------------------------------------------------------
// Catches raw character "SYNCHRONOUS IDLE":
// https://www.fileformat.info/info/unicode/char/0016/index.htm
function badCharacterSynchronousIdle(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 22) {
        context.report({
          ruleId: "bad-character-synchronous-idle",
          message: "Bad character - SYNCHRONOUS IDLE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-end-of-transmission-block
// -----------------------------------------------------------------------------
// Catches raw character "END OF TRANSMISSION BLOCK":
// https://www.fileformat.info/info/unicode/char/0017/index.htm
function badCharacterEndOfTransmissionBlock(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 23) {
        context.report({
          ruleId: "bad-character-end-of-transmission-block",
          message: "Bad character - END OF TRANSMISSION BLOCK.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-cancel
// -----------------------------------------------------------------------------
// Catches raw character "CANCEL":
// https://www.fileformat.info/info/unicode/char/0018/index.htm
function badCharacterCancel(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 24) {
        context.report({
          ruleId: "bad-character-cancel",
          message: "Bad character - CANCEL.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-end-of-medium
// -----------------------------------------------------------------------------
// Catches raw character "END OF MEDIUM":
// https://www.fileformat.info/info/unicode/char/0019/index.htm
function badCharacterEndOfMedium(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 25) {
        context.report({
          ruleId: "bad-character-end-of-medium",
          message: "Bad character - END OF MEDIUM.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-substitute
// -----------------------------------------------------------------------------
// Catches raw character "SUBSTITUTE":
// https://www.fileformat.info/info/unicode/char/001a/index.htm
function badCharacterSubstitute(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 26) {
        context.report({
          ruleId: "bad-character-substitute",
          message: "Bad character - SUBSTITUTE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-escape
// -----------------------------------------------------------------------------
// Catches raw character "ESCAPE":
// https://www.fileformat.info/info/unicode/char/001b/index.htm
function badCharacterEscape(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 27) {
        context.report({
          ruleId: "bad-character-escape",
          message: "Bad character - ESCAPE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-information-separator-four
// -----------------------------------------------------------------------------
// Catches raw character "INFORMATION SEPARATOR FOUR":
// https://www.fileformat.info/info/unicode/char/001c/index.htm
function badCharacterInformationSeparatorFour(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 28) {
        context.report({
          ruleId: "bad-character-information-separator-four",
          message: "Bad character - INFORMATION SEPARATOR FOUR.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-information-separator-three
// -----------------------------------------------------------------------------
// Catches raw character "INFORMATION SEPARATOR THREE":
// https://www.fileformat.info/info/unicode/char/001d/index.htm
function badCharacterInformationSeparatorThree(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 29) {
        context.report({
          ruleId: "bad-character-information-separator-three",
          message: "Bad character - INFORMATION SEPARATOR THREE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-information-separator-two
// -----------------------------------------------------------------------------
// Catches raw character "INFORMATION SEPARATOR TWO":
// https://www.fileformat.info/info/unicode/char/001e/index.htm
function badCharacterInformationSeparatorTwo$1(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 30) {
        context.report({
          ruleId: "bad-character-information-separator-two",
          message: "Bad character - INFORMATION SEPARATOR TWO.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-information-separator-one
// -----------------------------------------------------------------------------
// Catches raw character "INFORMATION SEPARATOR ONE":
// https://www.fileformat.info/info/unicode/char/001f/index.htm
function badCharacterInformationSeparatorTwo(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 31) {
        context.report({
          ruleId: "bad-character-information-separator-one",
          message: "Bad character - INFORMATION SEPARATOR ONE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-delete
// -----------------------------------------------------------------------------
// Catches raw character "DELETE":
// https://www.fileformat.info/info/unicode/char/007f/index.htm
function badCharacterDelete(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 127) {
        context.report({
          ruleId: "bad-character-delete",
          message: "Bad character - DELETE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-control-0080
// -----------------------------------------------------------------------------
// Catches raw character "CONTROL" (hex 80):
// https://www.fileformat.info/info/unicode/char/0080/index.htm
function badCharacterControl0080(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 128) {
        context.report({
          ruleId: "bad-character-control-0080",
          message: "Bad character - CONTROL.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-control-0081
// -----------------------------------------------------------------------------
// Catches raw character "CONTROL" (hex 81):
// https://www.fileformat.info/info/unicode/char/0081/index.htm
function badCharacterControl0081(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 129) {
        context.report({
          ruleId: "bad-character-control-0081",
          message: "Bad character - CONTROL.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-break-permitted-here
// -----------------------------------------------------------------------------
// Catches raw character "BREAK PERMITTED HERE":
// https://www.fileformat.info/info/unicode/char/0082/index.htm
function badCharacterBreakPermittedHere(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 130) {
        context.report({
          ruleId: "bad-character-break-permitted-here",
          message: "Bad character - BREAK PERMITTED HERE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-no-break-here
// -----------------------------------------------------------------------------
// Catches raw character "NO BREAK HERE":
// https://www.fileformat.info/info/unicode/char/0083/index.htm
function badCharacterNoBreakHere(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 131) {
        context.report({
          ruleId: "bad-character-no-break-here",
          message: "Bad character - NO BREAK HERE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-control-0084
// -----------------------------------------------------------------------------
// Catches raw character "CONTROL" (hex 84):
// https://www.fileformat.info/info/unicode/char/0084/index.htm
function badCharacterControl0084(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 132) {
        context.report({
          ruleId: "bad-character-control-0084",
          message: "Bad character - CONTROL.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-next-line
// -----------------------------------------------------------------------------
// Catches raw character "NEXT LINE":
// https://www.fileformat.info/info/unicode/char/0085/index.htm
function badCharacterNextLine(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 133) {
        context.report({
          ruleId: "bad-character-next-line",
          message: "Bad character - NEXT LINE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-start-of-selected-area
// -----------------------------------------------------------------------------
// Catches raw character "START OF SELECTED AREA":
// https://www.fileformat.info/info/unicode/char/0086/index.htm
function badCharacterStartOfSelectedArea(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 134) {
        context.report({
          ruleId: "bad-character-start-of-selected-area",
          message: "Bad character - START OF SELECTED AREA.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-end-of-selected-area
// -----------------------------------------------------------------------------
// Catches raw character "END OF SELECTED AREA":
// https://www.fileformat.info/info/unicode/char/0087/index.htm
function badCharacterEndOfSelectedArea(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 135) {
        context.report({
          ruleId: "bad-character-end-of-selected-area",
          message: "Bad character - END OF SELECTED AREA.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-character-tabulation-set
// -----------------------------------------------------------------------------
// Catches raw character "CHARACTER TABULATION SET":
// https://www.fileformat.info/info/unicode/char/0088/index.htm
function badCharacterCharacterTabulationSet(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 136) {
        context.report({
          ruleId: "bad-character-character-tabulation-set",
          message: "Bad character - CHARACTER TABULATION SET.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-character-tabulation-with-justification
// -----------------------------------------------------------------------------
// Catches raw character "CHARACTER TABULATION WITH JUSTIFICATION":
// https://www.fileformat.info/info/unicode/char/0089/index.htm
function badCharacterCharacterTabulationWithJustification(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 137) {
        context.report({
          ruleId: "bad-character-character-tabulation-with-justification",
          message: "Bad character - CHARACTER TABULATION WITH JUSTIFICATION.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-line-tabulation-set
// -----------------------------------------------------------------------------
// Catches raw character "LINE TABULATION SET":
// https://www.fileformat.info/info/unicode/char/008a/index.htm
function badCharacterLineTabulationSet(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 138) {
        context.report({
          ruleId: "bad-character-line-tabulation-set",
          message: "Bad character - LINE TABULATION SET.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-partial-line-forward
// -----------------------------------------------------------------------------
// Catches raw character "PARTIAL LINE FORWARD":
// https://www.fileformat.info/info/unicode/char/008b/index.htm
function badCharacterPartialLineForward(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 139) {
        context.report({
          ruleId: "bad-character-partial-line-forward",
          message: "Bad character - PARTIAL LINE FORWARD.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-partial-line-backward
// -----------------------------------------------------------------------------
// Catches raw character "PARTIAL LINE BACKWARD":
// https://www.fileformat.info/info/unicode/char/008c/index.htm
function badCharacterPartialLineBackward(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 140) {
        context.report({
          ruleId: "bad-character-partial-line-backward",
          message: "Bad character - PARTIAL LINE BACKWARD.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-reverse-line-feed
// -----------------------------------------------------------------------------
// Catches raw character "REVERSE LINE FEED":
// https://www.fileformat.info/info/unicode/char/008d/index.htm
function badCharacterReverseLineFeed(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 141) {
        context.report({
          ruleId: "bad-character-reverse-line-feed",
          message: "Bad character - REVERSE LINE FEED.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-single-shift-two
// -----------------------------------------------------------------------------
// Catches raw character "SINGLE SHIFT TWO":
// https://www.fileformat.info/info/unicode/char/008e/index.htm
function badCharacterSingleShiftTwo$1(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 142) {
        context.report({
          ruleId: "bad-character-single-shift-two",
          message: "Bad character - SINGLE SHIFT TWO.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-single-shift-three
// -----------------------------------------------------------------------------
// Catches raw character "SINGLE SHIFT THREE":
// https://www.fileformat.info/info/unicode/char/008f/index.htm
function badCharacterSingleShiftTwo(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 143) {
        context.report({
          ruleId: "bad-character-single-shift-three",
          message: "Bad character - SINGLE SHIFT THREE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-device-control-string
// -----------------------------------------------------------------------------
// Catches raw character "DEVICE CONTROL STRING":
// https://www.fileformat.info/info/unicode/char/0090/index.htm
function badCharacterDeviceControlString(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 144) {
        context.report({
          ruleId: "bad-character-device-control-string",
          message: "Bad character - DEVICE CONTROL STRING.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-private-use-1
// -----------------------------------------------------------------------------
// Catches raw character "PRIVATE USE ONE":
// https://www.fileformat.info/info/unicode/char/0091/index.htm
function badCharacterPrivateUseOne(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 145) {
        context.report({
          ruleId: "bad-character-private-use-1",
          message: "Bad character - PRIVATE USE ONE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-private-use-2
// -----------------------------------------------------------------------------
// Catches raw character "PRIVATE USE TWO":
// https://www.fileformat.info/info/unicode/char/0092/index.htm
function badCharacterPrivateUseTwo(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 146) {
        context.report({
          ruleId: "bad-character-private-use-2",
          message: "Bad character - PRIVATE USE TWO.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-set-transmit-state
// -----------------------------------------------------------------------------
// Catches raw character "SET TRANSMIT STATE":
// https://www.fileformat.info/info/unicode/char/0093/index.htm
function badCharacterSetTransmitState(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 147) {
        context.report({
          ruleId: "bad-character-set-transmit-state",
          message: "Bad character - SET TRANSMIT STATE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-cancel-character
// -----------------------------------------------------------------------------
// Catches raw character "CANCEL CHARACTER":
// https://www.fileformat.info/info/unicode/char/0094/index.htm
function badCharacterCancelCharacter(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 148) {
        context.report({
          ruleId: "bad-character-cancel-character",
          message: "Bad character - CANCEL CHARACTER.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-message-waiting
// -----------------------------------------------------------------------------
// Catches raw character "MESSAGE WAITING":
// https://www.fileformat.info/info/unicode/char/0095/index.htm
function badCharacterMessageWaiting(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 149) {
        context.report({
          ruleId: "bad-character-message-waiting",
          message: "Bad character - MESSAGE WAITING.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-start-of-protected-area
// -----------------------------------------------------------------------------
// Catches raw character "START OF PROTECTED AREA":
// https://www.fileformat.info/info/unicode/char/0096/index.htm
function badCharacterStartOfProtectedArea(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 150) {
        context.report({
          ruleId: "bad-character-start-of-protected-area",
          message: "Bad character - START OF PROTECTED AREA.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-end-of-protected-area
// -----------------------------------------------------------------------------
// Catches raw character "END OF PROTECTED AREA":
// https://www.fileformat.info/info/unicode/char/0097/index.htm
function badCharacterEndOfProtectedArea(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 151) {
        context.report({
          ruleId: "bad-character-end-of-protected-area",
          message: "Bad character - END OF PROTECTED AREA.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-start-of-string
// -----------------------------------------------------------------------------
// Catches raw character "START OF STRING":
// https://www.fileformat.info/info/unicode/char/0098/index.htm
function badCharacterStartOfString(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 152) {
        context.report({
          ruleId: "bad-character-start-of-string",
          message: "Bad character - START OF STRING.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-control-0099
// -----------------------------------------------------------------------------
// Catches raw character "CONTROL" (hex 99):
// https://www.fileformat.info/info/unicode/char/0099/index.htm
function badCharacterControl0099(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 153) {
        context.report({
          ruleId: "bad-character-control-0099",
          message: "Bad character - CONTROL.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-single-character-introducer
// -----------------------------------------------------------------------------
// Catches raw character "SINGLE CHARACTER INTRODUCER":
// https://www.fileformat.info/info/unicode/char/009a/index.htm
function badCharacterSingleCharacterIntroducer(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 154) {
        context.report({
          ruleId: "bad-character-single-character-introducer",
          message: "Bad character - SINGLE CHARACTER INTRODUCER.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-control-sequence-introducer
// -----------------------------------------------------------------------------
// Catches raw character "CONTROL SEQUENCE INTRODUCER":
// https://www.fileformat.info/info/unicode/char/009b/index.htm
function badCharacterControlSequenceIntroducer(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 155) {
        context.report({
          ruleId: "bad-character-control-sequence-introducer",
          message: "Bad character - CONTROL SEQUENCE INTRODUCER.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-string-terminator
// -----------------------------------------------------------------------------
// Catches raw character "STRING TERMINATOR":
// https://www.fileformat.info/info/unicode/char/009c/index.htm
function badCharacterStringTerminator(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 156) {
        context.report({
          ruleId: "bad-character-string-terminator",
          message: "Bad character - STRING TERMINATOR.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-operating-system-command
// -----------------------------------------------------------------------------
// Catches raw character "OPERATING SYSTEM COMMAND":
// https://www.fileformat.info/info/unicode/char/009d/index.htm
function badCharacterOperatingSystemCommand(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 157) {
        context.report({
          ruleId: "bad-character-operating-system-command",
          message: "Bad character - OPERATING SYSTEM COMMAND.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-private-message
// -----------------------------------------------------------------------------
// Catches raw character "PRIVATE MESSAGE":
// https://www.fileformat.info/info/unicode/char/009e/index.htm
function badCharacterPrivateMessage(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 158) {
        context.report({
          ruleId: "bad-character-private-message",
          message: "Bad character - PRIVATE MESSAGE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-application-program-command
// -----------------------------------------------------------------------------
// Catches raw character "APPLICATION PROGRAM COMMAND":
// https://www.fileformat.info/info/unicode/char/009f/index.htm
function badCharacterApplicationProgramCommand(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 159) {
        context.report({
          ruleId: "bad-character-application-program-command",
          message: "Bad character - APPLICATION PROGRAM COMMAND.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-soft-hyphen
// -----------------------------------------------------------------------------
// Catches raw character "SOFT HYPHEN":
// https://www.fileformat.info/info/unicode/char/00ad/index.htm
function badCharacterSoftHyphen(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 173) {
        context.report({
          ruleId: "bad-character-soft-hyphen",
          message: "Bad character - SOFT HYPHEN.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // replace with a normal space

          }
        });
      }
    }
  };
}

// rule: bad-character-non-breaking-space
// -----------------------------------------------------------------------------
// Catches raw character "NON-BREAKING SPACE":
// https://www.fileformat.info/info/unicode/char/00a0/index.htm
function badCharacterNonBreakingSpace(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 160) {
        context.report({
          ruleId: "bad-character-non-breaking-space",
          message: "Bad character - NON-BREAKING SPACE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1, " "]] // replace with a normal space

          }
        });
      }
    }
  };
}

// rule: bad-character-ogham-space-mark
// -----------------------------------------------------------------------------
// Catches raw character "OGHAM SPACE MARK":
// https://www.fileformat.info/info/unicode/char/1680/index.htm
function badCharacterOghamSpaceMark(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 5760) {
        context.report({
          ruleId: "bad-character-ogham-space-mark",
          message: "Bad character - OGHAM SPACE MARK.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1, " "]] // replace with a normal space

          }
        });
      }
    }
  };
}

// rule: bad-character-en-quad
// -----------------------------------------------------------------------------
// Catches raw character "EN QUAD":
// https://www.fileformat.info/info/unicode/char/2000/index.htm
function badCharacterEnQuad(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8192) {
        context.report({
          ruleId: "bad-character-en-quad",
          message: "Bad character - EN QUAD.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1, " "]] // replace with a normal space

          }
        });
      }
    }
  };
}

// rule: bad-character-em-quad
// -----------------------------------------------------------------------------
// Catches raw character "EM QUAD":
// https://www.fileformat.info/info/unicode/char/2001/index.htm
function badCharacterEmQuad(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8193) {
        context.report({
          ruleId: "bad-character-em-quad",
          message: "Bad character - EM QUAD.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1, " "]] // replace with a normal space

          }
        });
      }
    }
  };
}

// rule: bad-character-en-space
// -----------------------------------------------------------------------------
// Catches raw character "EN SPACE":
// https://www.fileformat.info/info/unicode/char/2002/index.htm
function badCharacterEnSpace(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8194) {
        context.report({
          ruleId: "bad-character-en-space",
          message: "Bad character - EN SPACE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1, " "]] // replace with a normal space

          }
        });
      }
    }
  };
}

// rule: bad-character-em-space
// -----------------------------------------------------------------------------
// Catches raw character "EM SPACE":
// https://www.fileformat.info/info/unicode/char/2003/index.htm
function badCharacterEmSpace(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8195) {
        context.report({
          ruleId: "bad-character-em-space",
          message: "Bad character - EM SPACE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1, " "]] // replace with a normal space

          }
        });
      }
    }
  };
}

// rule: bad-character-three-per-em-space
// -----------------------------------------------------------------------------
// Catches raw character "THREE-PER-EM SPACE":
// https://www.fileformat.info/info/unicode/char/2004/index.htm
function badCharacterThreePerEmSpace(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8196) {
        context.report({
          ruleId: "bad-character-three-per-em-space",
          message: "Bad character - THREE-PER-EM SPACE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1, " "]] // replace with a normal space

          }
        });
      }
    }
  };
}

// rule: bad-character-four-per-em-space
// -----------------------------------------------------------------------------
// Catches raw character "FOUR-PER-EM SPACE":
// https://www.fileformat.info/info/unicode/char/2005/index.htm
function badCharacterFourPerEmSpace(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8197) {
        context.report({
          ruleId: "bad-character-four-per-em-space",
          message: "Bad character - FOUR-PER-EM SPACE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1, " "]] // replace with a normal space

          }
        });
      }
    }
  };
}

// rule: bad-character-six-per-em-space
// -----------------------------------------------------------------------------
// Catches raw character "SIX-PER-EM SPACE":
// https://www.fileformat.info/info/unicode/char/2006/index.htm
function badCharacterSixPerEmSpace(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8198) {
        context.report({
          ruleId: "bad-character-six-per-em-space",
          message: "Bad character - SIX-PER-EM SPACE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1, " "]] // replace with a normal space

          }
        });
      }
    }
  };
}

// rule: bad-character-figure-space
// -----------------------------------------------------------------------------
// Catches raw character "FIGURE SPACE":
// https://www.fileformat.info/info/unicode/char/2007/index.htm
function badCharacterFigureSpace(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8199) {
        context.report({
          ruleId: "bad-character-figure-space",
          message: "Bad character - FIGURE SPACE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1, " "]] // replace with a normal space

          }
        });
      }
    }
  };
}

// rule: bad-character-punctuation-space
// -----------------------------------------------------------------------------
// Catches raw character "PUNCTUATION SPACE":
// https://www.fileformat.info/info/unicode/char/2008/index.htm
function badCharacterPunctuationSpace(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8200) {
        context.report({
          ruleId: "bad-character-punctuation-space",
          message: "Bad character - PUNCTUATION SPACE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1, " "]] // replace with a normal space

          }
        });
      }
    }
  };
}

// rule: bad-character-thin-space
// -----------------------------------------------------------------------------
// Catches raw character "THIN SPACE":
// https://www.fileformat.info/info/unicode/char/2009/index.htm
function badCharacterThinSpace(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8201) {
        context.report({
          ruleId: "bad-character-thin-space",
          message: "Bad character - THIN SPACE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1, " "]] // replace with a normal space

          }
        });
      }
    }
  };
}

// rule: bad-character-hair-space
// -----------------------------------------------------------------------------
// Catches raw character "HAIR SPACE":
// https://www.fileformat.info/info/unicode/char/200a/index.htm
function badCharacterHairSpace(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8202) {
        context.report({
          ruleId: "bad-character-hair-space",
          message: "Bad character - HAIR SPACE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1, " "]] // replace with a normal space

          }
        });
      }
    }
  };
}

// rule: bad-character-zero-width-space
// -----------------------------------------------------------------------------
// Catches raw character "ZERO WIDTH SPACE":
// https://www.fileformat.info/info/unicode/char/200b/index.htm
function badCharacterZeroWidthSpace(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8203) {
        context.report({
          ruleId: "bad-character-zero-width-space",
          message: "Bad character - ZERO WIDTH SPACE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1, " "]] // replace with a normal space

          }
        });
      }
    }
  };
}

// rule: bad-character-zero-width-non-joiner
// -----------------------------------------------------------------------------
// Catches raw character "ZERO WIDTH NON-JOINER":
// https://www.fileformat.info/info/unicode/char/200c/index.htm
function badCharacterZeroWidthNonJoiner(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8204) {
        context.report({
          ruleId: "bad-character-zero-width-non-joiner",
          message: "Bad character - ZERO WIDTH NON-JOINER.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-zero-width-joiner
// -----------------------------------------------------------------------------
// Catches raw character "ZERO WIDTH JOINER":
// https://www.fileformat.info/info/unicode/char/200d/index.htm
function badCharacterZeroWidthJoiner(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8205) {
        context.report({
          ruleId: "bad-character-zero-width-joiner",
          message: "Bad character - ZERO WIDTH JOINER.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-left-to-right-mark
// -----------------------------------------------------------------------------
// Catches raw character "LEFT-TO-RIGHT MARK":
// https://www.fileformat.info/info/unicode/char/200e/index.htm
function badCharacterLeftToRightMark(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8206) {
        context.report({
          ruleId: "bad-character-left-to-right-mark",
          message: "Bad character - LEFT-TO-RIGHT MARK.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-right-to-left-mark
// -----------------------------------------------------------------------------
// Catches raw character "RIGHT-TO-LEFT MARK":
// https://www.fileformat.info/info/unicode/char/200f/index.htm
function badCharacterRightToLeftMark(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8207) {
        context.report({
          ruleId: "bad-character-right-to-left-mark",
          message: "Bad character - RIGHT-TO-LEFT MARK.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-left-to-right-embedding
// -----------------------------------------------------------------------------
// Catches raw character "LEFT-TO-RIGHT EMBEDDING":
// https://www.fileformat.info/info/unicode/char/202a/index.htm
function badCharacterLeftToRightEmbedding(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8234) {
        context.report({
          ruleId: "bad-character-left-to-right-embedding",
          message: "Bad character - LEFT-TO-RIGHT EMBEDDING.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-right-to-left-embedding
// -----------------------------------------------------------------------------
// Catches raw character "RIGHT-TO-LEFT EMBEDDING":
// https://www.fileformat.info/info/unicode/char/202b/index.htm
function badCharacterRightToLeftEmbedding(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8235) {
        context.report({
          ruleId: "bad-character-right-to-left-embedding",
          message: "Bad character - RIGHT-TO-LEFT EMBEDDING.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-pop-directional-formatting
// -----------------------------------------------------------------------------
// Catches raw character "POP DIRECTIONAL FORMATTING":
// https://www.fileformat.info/info/unicode/char/202c/index.htm
function badCharacterPopDirectionalFormatting(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8236) {
        context.report({
          ruleId: "bad-character-pop-directional-formatting",
          message: "Bad character - POP DIRECTIONAL FORMATTING.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-left-to-right-override
// -----------------------------------------------------------------------------
// Catches raw character "LEFT-TO-RIGHT OVERRIDE":
// https://www.fileformat.info/info/unicode/char/202d/index.htm
function badCharacterLeftToRightOverride(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8237) {
        context.report({
          ruleId: "bad-character-left-to-right-override",
          message: "Bad character - LEFT-TO-RIGHT OVERRIDE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-right-to-left-override
// -----------------------------------------------------------------------------
// Catches raw character "RIGHT-TO-LEFT OVERRIDE":
// https://www.fileformat.info/info/unicode/char/202e/index.htm
function badCharacterRightToLeftOverride(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8238) {
        context.report({
          ruleId: "bad-character-right-to-left-override",
          message: "Bad character - RIGHT-TO-LEFT OVERRIDE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-word-joiner
// -----------------------------------------------------------------------------
// Catches raw character "WORD JOINER":
// https://www.fileformat.info/info/unicode/char/2060/index.htm
function badCharacterWordJoiner(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8288) {
        context.report({
          ruleId: "bad-character-word-joiner",
          message: "Bad character - WORD JOINER.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-function-application
// -----------------------------------------------------------------------------
// Catches raw character "FUNCTION APPLICATION":
// https://www.fileformat.info/info/unicode/char/2061/index.htm
function badCharacterFunctionApplication(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8289) {
        context.report({
          ruleId: "bad-character-function-application",
          message: "Bad character - FUNCTION APPLICATION.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-invisible-times
// -----------------------------------------------------------------------------
// Catches raw character "INVISIBLE TIMES":
// https://www.fileformat.info/info/unicode/char/2062/index.htm
function badCharacterInvisibleTimes(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8290) {
        context.report({
          ruleId: "bad-character-invisible-times",
          message: "Bad character - INVISIBLE TIMES.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-invisible-separator
// -----------------------------------------------------------------------------
// Catches raw character "INVISIBLE SEPARATOR":
// https://www.fileformat.info/info/unicode/char/2063/index.htm
function badCharacterInvisibleSeparator(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8291) {
        context.report({
          ruleId: "bad-character-invisible-separator",
          message: "Bad character - INVISIBLE SEPARATOR.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-invisible-plus
// -----------------------------------------------------------------------------
// Catches raw character "INVISIBLE PLUS":
// https://www.fileformat.info/info/unicode/char/2064/index.htm
function badCharacterInvisiblePlus(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8292) {
        context.report({
          ruleId: "bad-character-invisible-plus",
          message: "Bad character - INVISIBLE PLUS.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-left-to-right-isolate
// -----------------------------------------------------------------------------
// Catches raw character "LEFT-TO-RIGHT ISOLATE":
// https://www.fileformat.info/info/unicode/char/2066/index.htm
function badCharacterLeftToRightIsolate(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8294) {
        context.report({
          ruleId: "bad-character-left-to-right-isolate",
          message: "Bad character - LEFT-TO-RIGHT ISOLATE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-right-to-left-isolate
// -----------------------------------------------------------------------------
// Catches raw character "RIGHT-TO-LEFT ISOLATE":
// https://www.fileformat.info/info/unicode/char/2067/index.htm
function badCharacterRightToLeftIsolate(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8295) {
        context.report({
          ruleId: "bad-character-right-to-left-isolate",
          message: "Bad character - RIGHT-TO-LEFT ISOLATE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-first-strong-isolate
// -----------------------------------------------------------------------------
// Catches raw character "FIRST STRONG ISOLATE":
// https://www.fileformat.info/info/unicode/char/2068/index.htm
function badCharacterFirstStrongIsolate(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8296) {
        context.report({
          ruleId: "bad-character-first-strong-isolate",
          message: "Bad character - FIRST STRONG ISOLATE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-pop-directional-isolate
// -----------------------------------------------------------------------------
// Catches raw character "FIRST STRONG ISOLATE":
// https://www.fileformat.info/info/unicode/char/2069/index.htm
function badCharacterPopDirectionalIsolate(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8297) {
        context.report({
          ruleId: "bad-character-pop-directional-isolate",
          message: "Bad character - FIRST STRONG ISOLATE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-inhibit-symmetric-swapping
// -----------------------------------------------------------------------------
// Catches raw character "INHIBIT SYMMETRIC SWAPPING":
// https://www.fileformat.info/info/unicode/char/206a/index.htm
function badCharacterInhibitSymmetricSwapping(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8298) {
        context.report({
          ruleId: "bad-character-inhibit-symmetric-swapping",
          message: "Bad character - INHIBIT SYMMETRIC SWAPPING.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-activate-symmetric-swapping
// -----------------------------------------------------------------------------
// Catches raw character "INHIBIT SYMMETRIC SWAPPING":
// https://www.fileformat.info/info/unicode/char/206b/index.htm
function badCharacterActivateSymmetricSwapping(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8299) {
        context.report({
          ruleId: "bad-character-activate-symmetric-swapping",
          message: "Bad character - INHIBIT SYMMETRIC SWAPPING.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-inhibit-arabic-form-shaping
// -----------------------------------------------------------------------------
// Catches raw character "INHIBIT ARABIC FORM SHAPING":
// https://www.fileformat.info/info/unicode/char/206c/index.htm
function badCharacterInhibitArabicFormShaping(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8300) {
        context.report({
          ruleId: "bad-character-inhibit-arabic-form-shaping",
          message: "Bad character - INHIBIT ARABIC FORM SHAPING.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-activate-arabic-form-shaping
// -----------------------------------------------------------------------------
// Catches raw character "ACTIVATE ARABIC FORM SHAPING":
// https://www.fileformat.info/info/unicode/char/206d/index.htm
function badCharacterActivateArabicFormShaping(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8301) {
        context.report({
          ruleId: "bad-character-activate-arabic-form-shaping",
          message: "Bad character - ACTIVATE ARABIC FORM SHAPING.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-national-digit-shapes
// -----------------------------------------------------------------------------
// Catches raw character "NATIONAL DIGIT SHAPES":
// https://www.fileformat.info/info/unicode/char/206e/index.htm
function badCharacterNationalDigitShapes(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8302) {
        context.report({
          ruleId: "bad-character-national-digit-shapes",
          message: "Bad character - NATIONAL DIGIT SHAPES.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-nominal-digit-shapes
// -----------------------------------------------------------------------------
// Catches raw character "NOMINAL DIGIT SHAPES":
// https://www.fileformat.info/info/unicode/char/206f/index.htm
function badCharacterNominalDigitShapes(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8303) {
        context.report({
          ruleId: "bad-character-nominal-digit-shapes",
          message: "Bad character - NOMINAL DIGIT SHAPES.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-zero-width-no-break-space
// -----------------------------------------------------------------------------
// Catches raw character "ZERO WIDTH NO-BREAK SPACE":
// https://www.fileformat.info/info/unicode/char/feff/index.htm
function badCharacterZeroWidthNoBreakSpace(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 65279) {
        context.report({
          ruleId: "bad-character-zero-width-no-break-space",
          message: "Bad character - ZERO WIDTH NO-BREAK SPACE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-interlinear-annotation-anchor
// -----------------------------------------------------------------------------
// Catches raw character "INTERLINEAR ANNOTATION ANCHOR":
// https://www.fileformat.info/info/unicode/char/fff9/index.htm
function badCharacterInterlinearAnnotationAnchor(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 65529) {
        context.report({
          ruleId: "bad-character-interlinear-annotation-anchor",
          message: "Bad character - INTERLINEAR ANNOTATION ANCHOR.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-interlinear-annotation-separator
// -----------------------------------------------------------------------------
// Catches raw character "INTERLINEAR ANNOTATION SEPARATOR":
// https://www.fileformat.info/info/unicode/char/fffa/index.htm
function badCharacterInterlinearAnnotationSeparator(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 65530) {
        context.report({
          ruleId: "bad-character-interlinear-annotation-separator",
          message: "Bad character - INTERLINEAR ANNOTATION SEPARATOR.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-interlinear-annotation-terminator
// -----------------------------------------------------------------------------
// Catches raw character "INTERLINEAR ANNOTATION TERMINATOR":
// https://www.fileformat.info/info/unicode/char/fffb/index.htm
function badCharacterInterlinearAnnotationTerminator(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 65531) {
        context.report({
          ruleId: "bad-character-interlinear-annotation-terminator",
          message: "Bad character - INTERLINEAR ANNOTATION TERMINATOR.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-line-separator
// -----------------------------------------------------------------------------
// Catches raw character "LINE SEPARATOR":
// https://www.fileformat.info/info/unicode/char/2028/index.htm
function badCharacterLineSeparator(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8232) {
        context.report({
          ruleId: "bad-character-line-separator",
          message: "Bad character - LINE SEPARATOR.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-paragraph-separator
// -----------------------------------------------------------------------------
// Catches raw character "PARAGRAPH SEPARATOR":
// https://www.fileformat.info/info/unicode/char/2029/index.htm
function badCharacterParagraphSeparator(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8233) {
        context.report({
          ruleId: "bad-character-paragraph-separator",
          message: "Bad character - PARAGRAPH SEPARATOR.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// rule: bad-character-narrow-no-break-space
// -----------------------------------------------------------------------------
// Catches raw character "NARROW NO-BREAK SPACE":
// https://www.fileformat.info/info/unicode/char/202f/index.htm
function badCharacterNarrowNoBreakSpace(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8239) {
        context.report({
          ruleId: "bad-character-narrow-no-break-space",
          message: "Bad character - NARROW NO-BREAK SPACE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1, " "]] // replace with a normal space

          }
        });
      }
    }
  };
}

// rule: bad-character-medium-mathematical-space
// -----------------------------------------------------------------------------
// Catches raw character "MEDIUM MATHEMATICAL SPACE":
// https://www.fileformat.info/info/unicode/char/205f/index.htm
function badCharacterMediumMathematicalSpace(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 8287) {
        context.report({
          ruleId: "bad-character-medium-mathematical-space",
          message: "Bad character - MEDIUM MATHEMATICAL SPACE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1, " "]] // replace with a normal space

          }
        });
      }
    }
  };
}

// rule: bad-character-ideographic-space
// -----------------------------------------------------------------------------
// Catches raw character "IDEOGRAPHIC SPACE":
// https://www.fileformat.info/info/unicode/char/3000/index.htm
function badCharacterIdeographicSpace(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 12288) {
        context.report({
          ruleId: "bad-character-ideographic-space",
          message: "Bad character - IDEOGRAPHIC SPACE.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1, " "]] // replace with a normal space

          }
        });
      }
    }
  };
}

// rule: bad-character-replacement-character
// -----------------------------------------------------------------------------
// Catches raw character "REPLACEMENT CHARACTER":
// https://www.fileformat.info/info/unicode/char/fffd/index.htm
function badCharacterReplacementCharacter(context) {
  return {
    character: function character(_ref) {
      var chr = _ref.chr,
          i = _ref.i;

      if (chr.charCodeAt(0) === 65533) {
        context.report({
          ruleId: "bad-character-replacement-character",
          message: "Bad character - REPLACEMENT CHARACTER.",
          idxFrom: i,
          idxTo: i + 1,
          fix: {
            ranges: [[i, i + 1]] // just delete it

          }
        });
      }
    }
  };
}

// -----------------------------------------------------------------------------

function tagSpaceAfterOpeningBracket(context) {
  return {
    tag: function tag(node) {
      var ranges = []; // const wholeGap = context.str.slice(node.start + 1, node.tagNameStartsAt);
      // 1. if there's whitespace after opening bracket

      if ( // it starts on a bracket
      context.str[node.start] === "<" && // and next character exists
      context.str[node.start + 1] && // and it's a whitespace character
      !context.str[node.start + 1].trim()) {
        ranges.push([node.start + 1, right(context.str, node.start + 1) || context.str.length]);
      } // 2. if there's whitespace before tag name


      if ( // it starts on a bracket
      context.str[node.start] === "<" && // character in front of the tag's name is whitespace
      !context.str[node.tagNameStartsAt - 1].trim()) {
        var charToTheLeftOfTagNameIdx = left(context.str, node.tagNameStartsAt) || 0;

        if (charToTheLeftOfTagNameIdx !== node.start) {
          // we don't want duplication
          ranges.push([charToTheLeftOfTagNameIdx + 1, node.tagNameStartsAt]);
        }
      }

      if (ranges.length) {
        context.report({
          ruleId: "tag-space-after-opening-bracket",
          message: "Bad whitespace.",
          idxFrom: ranges[0][0],
          idxTo: ranges[ranges.length - 1][1],
          fix: {
            ranges: ranges
          }
        });
      }
    }
  };
}

// -----------------------------------------------------------------------------

var BACKSLASH$4 = "\\";

function tagSpaceBeforeClosingBracket(context, mode) {
  if (mode === void 0) {
    mode = "never";
  }

  return {
    tag: function tag(node) { // -----------------------------------------------------------------------------
      // early exit
      // if there's no closing bracket, exit early

      if (context.str[node.end - 1] !== ">") {
        return;
      } // -----------------------------------------------------------------------------
      // preparations
      // calculate the "leftmostPos" - that's slash if present or bracket
      // <br />
      //     ^
      //
      // <br /   >
      //     ^
      //
      // <div class="">
      //              ^
      // "leftmostPos" is the initial position of the closing bracket ">":


      var leftmostPos = node.end - 1; // find the first non-whitespace character on the left:

      var idxOnTheLeft = left(context.str, leftmostPos);

      if (context.str[idxOnTheLeft] === "/" || context.str[idxOnTheLeft] === BACKSLASH$4) {
        leftmostPos = idxOnTheLeft;
      } // -----------------------------------------------------------------------------
      // depends, is format-prettier enabled or not

      if ((Object.keys(context.processedRulesConfig).includes("format-prettier") && isAnEnabledValue(context.processedRulesConfig["format-prettier"]) && node.void || // OR mode is set to "always":
      mode === "always" && // format-prettier is not enabled
      !(Object.keys(context.processedRulesConfig).includes("format-prettier") && isAnEnabledValue(context.processedRulesConfig["format-prettier"]))) && context.str[leftmostPos - 1] && ( // it's not whitespace on the left
      context.str[leftmostPos - 1].trim() || // or it is, but it's not a single space
      context.str[leftmostPos - 1] !== " " || // or it is a single space but to the left of it it's whitespace
      context.str[leftmostPos - 2] && !context.str[leftmostPos - 2].trim())) {
        context.report({
          ruleId: "tag-space-before-closing-bracket",
          message: "Add a space.",
          idxFrom: node.start,
          idxTo: node.end,
          fix: {
            ranges: [[left(context.str, leftmostPos) + 1, leftmostPos, " "]]
          }
        });
      } else if ((Object.keys(context.processedRulesConfig).includes("format-prettier") && isAnEnabledValue(context.processedRulesConfig["format-prettier"]) && !node.void || // mode is "never"
      mode !== "always" && // and format-prettier is not enabled
      !(Object.keys(context.processedRulesConfig).includes("format-prettier") && isAnEnabledValue(context.processedRulesConfig["format-prettier"]))) && context.str[leftmostPos - 1] && // there's whitespace to the left of slash/closing bracket
      !context.str[leftmostPos - 1].trim()) {
        context.report({
          ruleId: "tag-space-before-closing-bracket",
          message: "Remove space.",
          idxFrom: node.start,
          idxTo: node.end,
          fix: {
            ranges: [[left(context.str, leftmostPos) + 1, leftmostPos]]
          }
        });
      }
    }
  };
}

var BACKSLASH$3 = "\\"; // rule: tag-space-between-slash-and-bracket
// -----------------------------------------------------------------------------

function tagSpaceBetweenSlashAndBracket(context) {
  return {
    tag: function tag(node) {
      // since we know the location of the closing bracket,
      // let's look to the left, is there a slash and check the distance
      var idxOnTheLeft = left(context.str, node.end - 1);

      if (Number.isInteger(node.end) && context.str[node.end - 1] === ">" && ( // necessary because in the future unclosed tags will be recognised!
      context.str[idxOnTheLeft] === "/" || context.str[idxOnTheLeft] === BACKSLASH$3) && idxOnTheLeft < node.end - 2) {
        var idxFrom = idxOnTheLeft + 1;
        context.report({
          ruleId: "tag-space-between-slash-and-bracket",
          message: "Bad whitespace.",
          idxFrom: idxFrom,
          idxTo: node.end - 1,
          fix: {
            ranges: [[idxFrom, node.end - 1]]
          }
        });
      }
    }
  };
}

// rule: tag-table
// checks the sanity in table structures
// -----------------------------------------------------------------------------
// it flags up any <bold> tags
function tagTable(context) {
  return {
    tag: function tag(node) {

      if (node.tagName === "table" && !node.closing) {

        if (node.children && node.children.length) {
          var extracted = [];
          var orderNumber = 0; // flag to check the correct sequence of opening and closing tags

          var closingTrMet = true;

          for (var i = 0, len1 = node.children.length; i < len1; i++) {

            if (node.children[i].type === "tag" && node.children[i].tagName === "tr") { // if it's a closing TR, flip the flag

              if (node.children[i].closing) {

                if (!closingTrMet) {
                  closingTrMet = true;
                } else {
                  return;
                }
              } else {

                if (closingTrMet) {
                  closingTrMet = false;
                } else {
                  return;
                }
                var finding = {
                  orderNumber: orderNumber,
                  idx: i,
                  tds: []
                };
                orderNumber++; // extract all TD's from within

                if (node.children[i].children && node.children[i].children.length) {
                  var closingTdMet = true;

                  for (var y = 0, len2 = node.children[i].children.length; y < len2; y++) {

                    if (node.children[i].children[y].type === "tag" && node.children[i].children[y].tagName === "td") {

                      if (node.children[i].children[y].closing) {

                        if (!closingTdMet) {
                          closingTdMet = true;
                        } else {
                          return;
                        }
                      } else {

                        if (closingTdMet) {
                          closingTdMet = false;
                        } else {
                          return;
                        }
                        finding.tds.push(y);
                      }
                    }
                  }

                  if (!closingTdMet) {
                    return;
                  }
                }
                extracted.push(finding);
              }
            }
          } // tags with let's say missing clashes will be nested further:
          // <table><tr><td><tr><td><td></table>
          // so the ending closingTrMet will be false, not true

          if (!closingTrMet) {
            return;
          }

          if (extracted.length) {
            var bail = false;
            var spans = extracted.map(function (findingObj) {
              return findingObj.tds.reduce(function (acc, curr) {
                var temp = 0;

                if ( // if there's colspan on this td, use that value
                node.children[findingObj.idx].children[curr].attribs && node.children[findingObj.idx].children[curr].attribs.length && node.children[findingObj.idx].children[curr].attribs.some(function (attrib) {
                  return attrib.attribName === "colspan" && attrib.attribValue && attrib.attribValue.length && attrib.attribValue.some(function (valObjNode) {
                    if (valObjNode.type === "text") {
                      if (Number.isInteger(+valObjNode.value)) {
                        // drill through and also extract the value
                        temp = +valObjNode.value;
                        return true;
                      }

                      bail = true;
                    }

                    return false;
                  });
                })) {
                  return acc + temp;
                }

                return acc + 1;
              }, 0);
            });

            if (bail) {
              return;
            }
            var uniqueSpans = new Set(spans); // console.log(
            //   `268 ${`\u001b[${32}m${`SET`}\u001b[${39}m`} ${`\u001b[${33}m${`uniqueSpans`}\u001b[${39}m`} = ${JSON.stringify(
            //     [...uniqueSpans],
            //     null,
            //     4
            //   )}`
            // );

            var tdCounts = extracted.map(function (e) {
              return e.tds.length;
            }); // The "uniqueSpans" takes into account colspan attr values, if any - this is
            // the absolute measurement, if everything is all right. If it's not allright,
            // we start from the bottom, evaluating TD's and colspan attributes and then
            // finding out what's wrong

            if (uniqueSpans.size && uniqueSpans.size !== 1) {
              var tdMaxCountPerRow = Math.max.apply(Math, tdCounts); // 1. rows where there's lesser amount of TD's and possibly colspan is missing/wrong

              extracted // rows with lesser
              .filter(function (e) {
                return e.tds.length !== tdMaxCountPerRow;
              }).forEach(function (e) {

                if (e.tds.length === 1) {

                  if (e.tds.length === spans[e.orderNumber]) { // position to insert the attribute is to the left of tag token's end,
                    // provided it ends with bracket!

                    var pos = node.children[e.idx].children[e.tds[0]].end - 1;
                    context.report({
                      ruleId: "tag-table",
                      message: "Add a collspan.",
                      idxFrom: node.children[e.idx].children[e.tds[0]].start,
                      idxTo: node.children[e.idx].children[e.tds[0]].end,
                      fix: {
                        ranges: [[pos, pos, " colspan=\"" + tdMaxCountPerRow + "\""]]
                      }
                    });
                  } else {
                    var attribsOfCulpridTd = node.children[e.idx].children[e.tds[0]].attribs;

                    for (var z = 0, len3 = attribsOfCulpridTd.length; z < len3; z++) {

                      if (attribsOfCulpridTd[z].attribName === "colspan") {
                        context.report({
                          ruleId: "tag-table",
                          message: "Should be colspan=\"" + tdMaxCountPerRow + "\".",
                          idxFrom: attribsOfCulpridTd[z].attribStarts,
                          idxTo: attribsOfCulpridTd[z].attribEnds,
                          fix: {
                            ranges: [[attribsOfCulpridTd[z].attribValueStartsAt, attribsOfCulpridTd[z].attribValueEndsAt, "" + tdMaxCountPerRow]]
                          }
                        });
                        break;
                      }
                    }
                  }
                } else {
                  context.report({
                    ruleId: "tag-table",
                    message: "Should contain " + tdMaxCountPerRow + " td's.",
                    idxFrom: node.children[e.idx].start,
                    idxTo: node.children[e.idx].end,
                    fix: null
                  });
                }
              }); // 2. td count can be even but there might be a wrong colspan:
              //
              // <table>
              //   <tr>
              //     <td colspan="2">1</td>
              //         ^^^^^^^^^^^
              //     <td>2</td>
              //   </tr>
              //   <tr>
              //     <td>1</td>
              //     <td>2</td>
              //   </tr>
              // </table>

              tdCounts.forEach(function (tdCount, idx) {
                if ( // td count is correct:
                tdCount === tdMaxCountPerRow && // but because of colspans, the total span is off
                spans[idx] > tdCount) {
                  extracted[idx].tds.forEach(function (tdIdx) {
                    // tdIdx
                    var currentTd = node.children[extracted[idx].idx].children[tdIdx]; // console.log(
                    //   `${`\u001b[${33}m${`currentTd`}\u001b[${39}m`} = ${JSON.stringify(
                    //     currentTd,
                    //     null,
                    //     4
                    //   )}`
                    // );

                    currentTd.attribs.filter(function (attrib) {
                      return attrib.attribName === "colspan";
                    }).forEach(function (attrib) {
                      context.report({
                        ruleId: "tag-table",
                        message: "Remove the colspan.",
                        idxFrom: attrib.attribStarts,
                        idxTo: attrib.attribEnds,
                        fix: {
                          ranges: [[attrib.attribLeft + 1, attrib.attribEnds]]
                        }
                      });
                    });
                  });
                }
              });
            }
          }
        }
      }
    }
  };
}

// rule: tag-malformed
// checks brackets etc
// -----------------------------------------------------------------------------

function tagMalformed(context) {
  return {
    tag: function tag(node) { // check the opening bracket

      if (context.str[node.start] !== "<") {
        context.report({
          ruleId: "tag-malformed",
          message: "Add an opening bracket.",
          idxFrom: node.start,
          idxTo: node.end,
          fix: {
            ranges: [[node.start, node.start, "<"]]
          }
        });
      } // check the closing bracket


      if (context.str[node.end - 1] !== ">") {
        var startPos = left(context.str, node.end) + 1;
        context.report({
          ruleId: "tag-malformed",
          message: "Add a closing bracket.",
          idxFrom: node.start,
          idxTo: node.end,
          fix: {
            ranges: [[startPos, startPos, ">"]]
          }
        });
      }
    }
  };
}

// rule: tag-closing-backslash
var BACKSLASH$2 = "\\";

function tagClosingBackslash(context) {
  return {
    tag: function tag(node) { // since we know the location of the closing bracket,
      // let's look to the left, is there a slash and check the distance
      var ranges = []; //
      //
      //
      //           PART 1 - backslash is after opening bracket
      //
      //
      //

      if (Number.isInteger(node.start) && Number.isInteger(node.tagNameStartsAt) && context.str.slice(node.start, node.tagNameStartsAt).includes(BACKSLASH$2)) {

        for (var i = node.start; i < node.tagNameStartsAt; i++) {
          // fish-out all backslashes
          if (context.str[i] === BACKSLASH$2) {
            // just delete the backslash because it doesn't belong here
            // if there's a need for closing (left) slash, it will be added
            // by 3rd level rules which can "see" the surrounding tag layout.
            ranges.push([i, i + 1]);
          }
        }
      } //
      //
      //
      //           PART 2 - backslash is before closing bracket
      //
      //
      //


      if (Number.isInteger(node.end) && context.str[node.end - 1] === ">" && // necessary because in the future unclosed tags will be recognised!
      context.str[left(context.str, node.end - 1)] === BACKSLASH$2) {
        var message = node.void ? "Replace backslash with slash." : "Delete this.";
        var backSlashPos = left(context.str, node.end - 1); // So we confirmed there's left slash.
        // Is it completely rogue or is it meant to be self-closing tag's closing?

        var idxFrom = left(context.str, backSlashPos) + 1;
        var whatToInsert = node.void ? "/" : "";

        if (context.processedRulesConfig["tag-space-before-closing-slash"] && (Number.isInteger(context.processedRulesConfig["tag-space-before-closing-slash"]) && context.processedRulesConfig["tag-space-before-closing-slash"] > 0 || Array.isArray(context.processedRulesConfig["tag-space-before-closing-slash"]) && context.processedRulesConfig["tag-space-before-closing-slash"][0] > 0 && context.processedRulesConfig["tag-space-before-closing-slash"][1] === "never")) {
          // include any and all the whitespace to the left as well
          idxFrom = left(context.str, backSlashPos) + 1;
        } // but if spaces are requested via "tag-space-before-closing-slash",
        // ensure they're added


        if (Array.isArray(context.processedRulesConfig["tag-space-before-closing-slash"]) && context.processedRulesConfig["tag-space-before-closing-slash"][0] > 0 && context.processedRulesConfig["tag-space-before-closing-slash"][1] === "always") {
          idxFrom = left(context.str, backSlashPos) + 1;
          whatToInsert = " " + whatToInsert; // but if space is already present at the beginning of the range at
          // index left(context.str, backSlashPos) + 1, don't add one there

          if (node.void && context.str[idxFrom + 1] === " ") {
            idxFrom += 1;
            whatToInsert = whatToInsert.trim();
          } else if (!node.void) {
            whatToInsert = whatToInsert.trim();
          }
        } // maybe slashes are forbidden on void tags?

        if (node.void && Array.isArray(context.processedRulesConfig["tag-void-slash"]) && context.processedRulesConfig["tag-void-slash"][0] > 0 && context.processedRulesConfig["tag-void-slash"][1] === "never") {
          whatToInsert = "";
          idxFrom = left(context.str, backSlashPos) + 1;
          message = "Delete this.";
        }

        context.report({
          ruleId: "tag-closing-backslash",
          message: message,
          idxFrom: idxFrom,
          idxTo: node.end - 1,
          fix: {
            ranges: [[idxFrom, node.end - 1, whatToInsert]]
          }
        });
      } // FINALLY,


      if (ranges.length) {
        context.report({
          ruleId: "tag-closing-backslash",
          message: "Wrong slash - backslash.",
          idxFrom: ranges[0][0],
          idxTo: ranges[ranges.length - 1][1],
          fix: {
            ranges: ranges
          }
        });
      }
    }
  };
}

// -----------------------------------------------------------------------------
// it controls, should we or should we not put the slashes on void tags,
// such as img. Is it <img...> or is it <img.../>?

var BACKSLASH$1 = "\\";

function tagVoidSlash(context, mode) {
  if (mode === void 0) {
    mode = "always";
  }

  return {
    tag: function tag(node) { // PROCESSING:

      var closingBracketPos = node.end - 1;
      var slashPos = left(context.str, closingBracketPos);
      var leftOfSlashPos = left(context.str, slashPos) || 0;

      if (mode === "never" && node.void && context.str[slashPos] === "/") {
        // if slashes are forbidden on void tags, delete the slash and all
        // the whitespace in front, because there's never a space before
        // non-void tag's closing bracket without a slash, for example, "<span >"
        context.report({
          ruleId: "tag-void-slash",
          message: "Remove the slash.",
          idxFrom: node.start,
          idxTo: node.end,
          fix: {
            ranges: [[leftOfSlashPos + 1, closingBracketPos]]
          }
        });
      } else if (mode === "always" && node.void && context.str[slashPos] !== "/" && ( // don't trigger if backslash rules are on:
      !context.processedRulesConfig["tag-closing-backslash"] || !(context.str[slashPos] === BACKSLASH$1 && (Number.isInteger(context.processedRulesConfig["tag-closing-backslash"]) && context.processedRulesConfig["tag-closing-backslash"] > 0 || Array.isArray(context.processedRulesConfig["tag-closing-backslash"]) && context.processedRulesConfig["tag-closing-backslash"][0] > 0 && context.processedRulesConfig["tag-closing-backslash"][1] === "always")))) { // if slashes are requested on void tags, situation is more complex,
        // because we need to take into the account the rule
        // "tag-space-before-closing-slash"

        if (Array.isArray(context.processedRulesConfig["tag-space-before-closing-slash"]) && context.processedRulesConfig["tag-space-before-closing-slash"][1] === "always") { // space is needed
          // check, maybe space is there

          if (context.str[slashPos + 1] === " ") {
            // but space exists already
            context.report({
              ruleId: "tag-void-slash",
              message: "Missing slash.",
              idxFrom: node.start,
              idxTo: node.end,
              // overwrite the closing bracket too because it will solve the
              // problem when trying to sort the fixes when attributes inside
              // operate on nearby index positions - otherwise clashes can
              // happen, for example,
              //
              // <img alt=">
              //
              // with 2 rules: attribute-malformed, tag-void-slash
              fix: {
                ranges: [[slashPos + 2, closingBracketPos + 1, "/>"]]
              }
            });
          } else {
            // space is missing so add one
            context.report({
              ruleId: "tag-void-slash",
              message: "Missing slash.",
              idxFrom: node.start,
              idxTo: node.end,
              fix: {
                ranges: [[slashPos + 1, closingBracketPos + 1, " />"]]
              }
            });
          }
        } else if (context.processedRulesConfig["tag-space-before-closing-slash"] === undefined || Array.isArray(context.processedRulesConfig["tag-space-before-closing-slash"]) && context.processedRulesConfig["tag-space-before-closing-slash"][1] === "never" || Number.isInteger(context.processedRulesConfig["tag-space-before-closing-slash"]) && context.processedRulesConfig["tag-space-before-closing-slash"] > 0) {
          // no space needed
          context.report({
            ruleId: "tag-void-slash",
            message: "Missing slash.",
            idxFrom: node.start,
            idxTo: node.end,
            fix: {
              ranges: [[closingBracketPos, closingBracketPos + 1, "/>"]]
            }
          });
        }
      }
    }
  };
}

// rule: tag-name-case
// -----------------------------------------------------------------------------
function tagNameCase(context) {
  var knownUpperCaseTags = ["CDATA"];
  var variableCaseTagNames = ["doctype"];
  return {
    tag: function tag(node) { // since we know the location of the closing bracket,
      // let's look to the left, is there a slash and check the distance

      if (node.tagName && node.recognised === true) {

        if (knownUpperCaseTags.includes(node.tagName.toUpperCase())) {
          // node.tagName will arrive lowercased, so we have to retrieve
          // the real characters by slicing from ranges
          if (context.str.slice(node.tagNameStartsAt, node.tagNameEndsAt) !== node.tagName.toUpperCase()) {
            var ranges = [[node.tagNameStartsAt, node.tagNameEndsAt, node.tagName.toUpperCase()]];
            context.report({
              ruleId: "tag-name-case",
              message: "Bad tag name case.",
              idxFrom: node.tagNameStartsAt,
              idxTo: node.tagNameEndsAt,
              fix: {
                ranges: ranges
              }
            });
          } // else - FINE

        } else if (context.str.slice(node.tagNameStartsAt, node.tagNameEndsAt) !== node.tagName && !variableCaseTagNames.includes(node.tagName.toLowerCase())) {
          var _ranges = [[node.tagNameStartsAt, node.tagNameEndsAt, node.tagName]];
          context.report({
            ruleId: "tag-name-case",
            message: "Bad tag name case.",
            idxFrom: node.tagNameStartsAt,
            idxTo: node.tagNameEndsAt,
            fix: {
              ranges: _ranges
            }
          });
        }
      }
    }
  };
}

// -----------------------------------------------------------------------------
// it flags up any tags from the blacklist

function tagIsPresent(context) {
  for (var _len = arguments.length, blacklist = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    blacklist[_key - 1] = arguments[_key];
  }

  return {
    tag: function tag(node) {

      if (Array.isArray(blacklist) && blacklist.length) {
        matcher([node.tagName], blacklist);

        if (matcher([node.tagName], blacklist).length) {
          context.report({
            ruleId: "tag-is-present",
            message: node.tagName + " is not allowed.",
            idxFrom: node.start,
            idxTo: node.end,
            fix: {
              ranges: [[node.start, node.end]]
            }
          });
        }
      }
    }
  };
}

// rule: tag-bold
// -----------------------------------------------------------------------------
// it flags up any <bold> tags
function tagBold(context, suggested) {
  if (suggested === void 0) {
    suggested = "strong";
  }

  return {
    tag: function tag(node) {

      if (node.tagName === "bold") {
        context.report({
          ruleId: "tag-bold",
          message: "Tag \"bold\" does not exist in HTML.",
          idxFrom: node.start,
          idxTo: node.end,
          fix: {
            ranges: [[node.tagNameStartsAt, node.tagNameEndsAt, suggested]]
          }
        });
      }
    }
  };
}

// -----------------------------------------------------------------------------
// flags up all self-closing non-void tags, for example: <table ... />

function tagBadSelfClosing(context) {
  return {
    tag: function tag(node) {

      if (!node.void && node.value.endsWith(">") && node.value[left(node.value, node.value.length - 1)] === "/") {
        var idxFrom = node.start + left(node.value, left(node.value, node.value.length - 1)) + 1;
        var idxTo = node.start + node.value.length - 1;
        context.report({
          ruleId: "tag-bad-self-closing",
          message: "Remove the slash.",
          idxFrom: idxFrom,
          idxTo: idxTo,
          fix: {
            ranges: [[idxFrom, idxTo]]
          }
        });
      }
    }
  };
}

var defaults$3 = {
  strictlyTwoElementsInRangeArrays: false,
  progressFn: null
};

function rSort(arrOfRanges, originalOptions) {
  if (!Array.isArray(arrOfRanges) || !arrOfRanges.length) {
    return arrOfRanges;
  }

  var opts = _objectSpread2(_objectSpread2({}, defaults$3), originalOptions);

  var culpritsIndex;
  var culpritsLen;

  if (opts.strictlyTwoElementsInRangeArrays && !arrOfRanges.filter(function (range) {
    return range;
  }).every(function (rangeArr, indx) {
    if (rangeArr.length !== 2) {
      culpritsIndex = indx;
      culpritsLen = rangeArr.length;
      return false;
    }

    return true;
  })) {
    throw new TypeError("ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, " + culpritsIndex + "th range (" + JSON.stringify(arrOfRanges[culpritsIndex], null, 4) + ") has not two but " + culpritsLen + " elements!");
  }

  if (!arrOfRanges.filter(function (range) {
    return range;
  }).every(function (rangeArr, indx) {
    if (!Number.isInteger(rangeArr[0]) || rangeArr[0] < 0 || !Number.isInteger(rangeArr[1]) || rangeArr[1] < 0) {
      culpritsIndex = indx;
      return false;
    }

    return true;
  })) {
    throw new TypeError("ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, " + culpritsIndex + "th range (" + JSON.stringify(arrOfRanges[culpritsIndex], null, 4) + ") does not consist of only natural numbers!");
  }

  var maxPossibleIterations = Math.pow(arrOfRanges.filter(function (range) {
    return range;
  }).length, 2);
  var counter = 0;
  return Array.from(arrOfRanges).filter(function (range) {
    return range;
  }).sort(function (range1, range2) {
    if (opts.progressFn) {
      counter += 1;
      opts.progressFn(Math.floor(counter * 100 / maxPossibleIterations));
    }

    if (range1[0] === range2[0]) {
      if (range1[1] < range2[1]) {
        return -1;
      }

      if (range1[1] > range2[1]) {
        return 1;
      }

      return 0;
    }

    if (range1[0] < range2[0]) {
      return -1;
    }

    return 1;
  });
}

var defaults$2 = {
  mergeType: 1,
  progressFn: null,
  joinRangesThatTouchEdges: true
};

function rMerge(arrOfRanges, originalOpts) {
  function isObj(something) {
    return something && typeof something === "object" && !Array.isArray(something);
  }

  if (!Array.isArray(arrOfRanges) || !arrOfRanges.length) {
    return null;
  }

  var opts;

  if (originalOpts) {
    if (isObj(originalOpts)) {
      opts = _objectSpread2(_objectSpread2({}, defaults$2), originalOpts);

      if (opts.progressFn && isObj(opts.progressFn) && !Object.keys(opts.progressFn).length) {
        opts.progressFn = null;
      } else if (opts.progressFn && typeof opts.progressFn !== "function") {
        throw new Error("ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: \"" + typeof opts.progressFn + "\", equal to " + JSON.stringify(opts.progressFn, null, 4));
      }

      if (opts.mergeType && +opts.mergeType !== 1 && +opts.mergeType !== 2) {
        throw new Error("ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: \"" + typeof opts.mergeType + "\", equal to " + JSON.stringify(opts.mergeType, null, 4));
      }

      if (typeof opts.joinRangesThatTouchEdges !== "boolean") {
        throw new Error("ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: \"" + typeof opts.joinRangesThatTouchEdges + "\", equal to " + JSON.stringify(opts.joinRangesThatTouchEdges, null, 4));
      }
    } else {
      throw new Error("emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:\n" + JSON.stringify(originalOpts, null, 4) + " (type " + typeof originalOpts + ")");
    }
  } else {
    opts = _objectSpread2({}, defaults$2);
  }

  var filtered = arrOfRanges.filter(function (range) {
    return range;
  }).map(function (subarr) {
    return [].concat(subarr);
  }).filter(function (rangeArr) {
    return rangeArr[2] !== undefined || rangeArr[0] !== rangeArr[1];
  });
  var sortedRanges;
  var lastPercentageDone;
  var percentageDone;

  if (opts.progressFn) {
    sortedRanges = rSort(filtered, {
      progressFn: function progressFn(percentage) {
        percentageDone = Math.floor(percentage / 5);

        if (percentageDone !== lastPercentageDone) {
          lastPercentageDone = percentageDone;
          opts.progressFn(percentageDone);
        }
      }
    });
  } else {
    sortedRanges = rSort(filtered);
  }

  if (!sortedRanges) {
    return null;
  }

  var len = sortedRanges.length - 1;

  for (var i = len; i > 0; i--) {
    if (opts.progressFn) {
      percentageDone = Math.floor((1 - i / len) * 78) + 21;

      if (percentageDone !== lastPercentageDone && percentageDone > lastPercentageDone) {
        lastPercentageDone = percentageDone;
        opts.progressFn(percentageDone);
      }
    }

    if (sortedRanges[i][0] <= sortedRanges[i - 1][0] || !opts.joinRangesThatTouchEdges && sortedRanges[i][0] < sortedRanges[i - 1][1] || opts.joinRangesThatTouchEdges && sortedRanges[i][0] <= sortedRanges[i - 1][1]) {
      sortedRanges[i - 1][0] = Math.min(sortedRanges[i][0], sortedRanges[i - 1][0]);
      sortedRanges[i - 1][1] = Math.max(sortedRanges[i][1], sortedRanges[i - 1][1]);

      if (sortedRanges[i][2] !== undefined && (sortedRanges[i - 1][0] >= sortedRanges[i][0] || sortedRanges[i - 1][1] <= sortedRanges[i][1])) {
        if (sortedRanges[i - 1][2] !== null) {
          if (sortedRanges[i][2] === null && sortedRanges[i - 1][2] !== null) {
            sortedRanges[i - 1][2] = null;
          } else if (sortedRanges[i - 1][2] != null) {
            if (+opts.mergeType === 2 && sortedRanges[i - 1][0] === sortedRanges[i][0]) {
              sortedRanges[i - 1][2] = sortedRanges[i][2];
            } else {
              sortedRanges[i - 1][2] += sortedRanges[i][2];
            }
          } else {
            sortedRanges[i - 1][2] = sortedRanges[i][2];
          }
        }
      }

      sortedRanges.splice(i, 1);
      i = sortedRanges.length;
    }
  }

  return sortedRanges.length ? sortedRanges : null;
}

// rule: attribute-duplicate

var attributeDuplicate = function attributeDuplicate(context) {
  var attributesWhichCanBeMerged = new Set(["id", "class"]); // imagine string:
  // `<a class="" class=""  >`
  // this rule will remove both classes, ending with:
  // [[2, 20]]
  // now these ranges don't include the trailing two spaces
  // when applied, yielding:
  // `<a  >` instead of `<a>`.
  // We need to extend the ending of the last range if it's on a
  // whitespace, leading up to / or >.

  function prepLast(ranges) {
    if (!Array.isArray(ranges) || !ranges.length) {
      return ranges;
    }

    if (!context.str[ranges[ranges.length - 1][1]].trim()) {
      var charOnTheRightIdx = right(context.str, ranges[ranges.length - 1][1]);

      if ("/>".includes(context.str[charOnTheRightIdx])) {
        ranges[ranges.length - 1][1] = charOnTheRightIdx;
      }
    }

    return ranges;
  }

  return {
    tag: function tag(node) { // if there is more than 1 attribute

      if (Array.isArray(node.attribs) && node.attribs.length > 1) {
        var attrsGatheredSoFar = new Set(); // record unique names

        var mergeableAttrsCaught = new Set(); // also unique

        for (var i = 0, len = node.attribs.length; i < len; i++) {

          if (node.attribs[i].attribName === undefined) {
            continue;
          }

          if (!attrsGatheredSoFar.has(node.attribs[i].attribName)) {
            attrsGatheredSoFar.add(node.attribs[i].attribName);
          } else if (!attributesWhichCanBeMerged.has(node.attribs[i].attribName) || Array.isArray(node.attribs[i].attribValue) && node.attribs[i].attribValue.length && node.attribs[i].attribValue.some(function (obj) {
            return obj.value && (obj.value.includes("'") || obj.value.includes("\""));
          })) {
            context.report({
              ruleId: "attribute-duplicate",
              message: "Duplicate attribute \"" + node.attribs[i].attribName + "\".",
              idxFrom: node.attribs[i].attribStarts,
              idxTo: node.attribs[i].attribEnds,
              fix: null
            });
          } else {
            mergeableAttrsCaught.add(node.attribs[i].attribName);
          }
        } // process all recorded attributes which can be merged:


        if (mergeableAttrsCaught && mergeableAttrsCaught.size) {
          [].concat(mergeableAttrsCaught).forEach(function (attrNameBeingMerged) { // the first attribute with its value will also be replaced,
            // in whole, except, its value will be merged string of all
            // extracted values of all same-name attributes

            var theFirstRange = [];
            var extractedValues = [];
            var allOtherRanges = []; // can't use functional way with filter+reduce
            // instead we'll loop through all attributes

            var _loop = function _loop(_i, _len) {
              if (node.attribs[_i].attribName === attrNameBeingMerged) { // make a note of the index ranges, separating the first
                // attribute occurence from the rest:

                if (!theFirstRange.length) {
                  // whole attributes goes too, including whitespace
                  // on the left - it's because we automaticaly tackle
                  // all dirty code cases, imagine a tab as whitespace
                  // character in front of class="..." or equal missing
                  // or similar issues with the first attribute
                  theFirstRange.push(node.attribs[_i].attribLeft + 1, node.attribs[_i].attribEnds);
                } else {
                  // notice we push an array into an array
                  // include whitespace to the left, unless it's the first
                  // attribute of a tag (i === 0, or falsey)
                  allOtherRanges.push([_i ? node.attribs[_i].attribLeft + 1 : node.attribs[_i].attribStarts, node.attribs[_i].attribEnds]);
                }

                if (node.attribs[_i].attribValueStartsAt) { // either way, extract the values, split by whitespace

                  splitByWhitespace(node.attribs[_i].attribValueRaw, function (_ref) {
                    var from = _ref[0],
                        to = _ref[1];
                    extractedValues.push(node.attribs[_i].attribValueRaw.slice(from, to));
                  });
                }
              }
            };

            for (var _i = 0, _len = node.attribs.length; _i < _len; _i++) {
              _loop(_i);
            }
            var mergedValue = extractedValues.sort().join(" "); // finally, raise the error:

            if (mergedValue && mergedValue.length) {
              var ranges = prepLast(rMerge([[].concat(theFirstRange, [" " + attrNameBeingMerged + "=\"" + mergedValue + "\""])].concat(allOtherRanges)));
              context.report({
                ruleId: "attribute-duplicate",
                message: "Duplicate attribute \"" + attrNameBeingMerged + "\".",
                idxFrom: node.start,
                idxTo: node.end,
                fix: {
                  ranges: ranges
                }
              });
            } else { // remove all attributes of this kind

              var _ranges = prepLast(rMerge([[].concat(theFirstRange)].concat(allOtherRanges)));
              context.report({
                ruleId: "attribute-duplicate",
                message: "Duplicate attribute \"" + attrNameBeingMerged + "\".",
                idxFrom: node.start,
                idxTo: node.end,
                fix: {
                  ranges: _ranges
                }
              });
            }
          });
        }
      }
    }
  };
};

function attributeMalformed(context) {
  for (var _len = arguments.length, config = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    config[_key - 1] = arguments[_key];
  }

  // the following tags will be processed separately
  var blacklist = ["doctype"];
  return {
    attribute: function attribute(node) {
      var inTheEndUseDoubles = true;

      if (config.includes("useSingleToEscapeDouble") && node.attribValueRaw.includes("\"") && !node.attribValueRaw.includes("'") && // it's not leading or trailing
      !node.attribValueRaw.trim().startsWith("\"") && !node.attribValueRaw.trim().endsWith("\"")) {
        inTheEndUseDoubles = false;
      }
      var repeatedQuotesPresent = false;

      if ( // exclude ESP tags etc.
      node.attribName === undefined) {
        return;
      } // if Levenshtein distance is 1 and it's not among known attribute names,
      // it's definitely mis-typed


      if (!node.attribNameRecognised && node.attribName && !node.attribName.startsWith("xmlns:") && !blacklist.includes(node.parent.tagName)) {
        var somethingMatched = false;

        for (var _iterator = _createForOfIteratorHelperLoose(allHtmlAttribs.values()), _step; !(_step = _iterator()).done;) {
          var oneOfAttribs = _step.value;

          if (oneOfAttribs === node.attribName.toLowerCase()) {
            // only the letter case is wrong, for example
            // <img SRC="spacer.gif" ALT=""/>
            context.report({
              ruleId: "attribute-malformed",
              message: "Should be lowercase.",
              idxFrom: node.attribNameStartsAt,
              idxTo: node.attribNameEndsAt,
              fix: {
                ranges: [[node.attribNameStartsAt, node.attribNameEndsAt, oneOfAttribs.toLowerCase()]]
              }
            });
            somethingMatched = true;
            break;
          } else if (leven_1(oneOfAttribs, node.attribName) === 1) {
            // <img srcc="spacer.gif" altt=""/>
            //         ^                 ^
            context.report({
              ruleId: "attribute-malformed",
              message: "Probably meant \"" + oneOfAttribs + "\".",
              idxFrom: node.attribNameStartsAt,
              idxTo: node.attribNameEndsAt,
              fix: {
                ranges: [[node.attribNameStartsAt, node.attribNameEndsAt, oneOfAttribs]]
              }
            });
            somethingMatched = true;
            break;
          }
        }

        if (!somethingMatched) {
          // the attribute was not recognised
          context.report({
            ruleId: "attribute-malformed",
            message: "Unrecognised attribute \"" + node.attribName + "\".",
            idxFrom: node.attribNameStartsAt,
            idxTo: node.attribNameEndsAt,
            fix: null
          });
        }
      } // something wrong around equal


      if (node.attribNameEndsAt && (node.attribValueStartsAt || // it's an empty value
      node.attribOpeningQuoteAt && node.attribClosingQuoteAt && node.attribClosingQuoteAt === node.attribOpeningQuoteAt + 1)) {

        if ( // if opening quotes are present, let's use their location
        node.attribOpeningQuoteAt !== null && context.str.slice(node.attribNameEndsAt, node.attribOpeningQuoteAt) !== "=") {
          var message = "Malformed around equal.";

          if (!context.str.slice(node.attribNameEndsAt, node.attribOpeningQuoteAt).includes("=")) {
            message = "Equal is missing.";
          }

          var fromRange = node.attribNameEndsAt;
          var toRange = node.attribOpeningQuoteAt;
          var whatToAdd = "="; // if equals is in a correct place, don't replace it

          if (context.str[fromRange] === "=") {
            fromRange += 1;
            whatToAdd = undefined;
          }
          context.report({
            ruleId: "attribute-malformed",
            message: message,
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            fix: {
              ranges: whatToAdd ? [[fromRange, toRange, "="]] : [[fromRange, toRange]]
            }
          });
        }
      } // repeated opening quotes


      if ( // value starts with a quote
      node.attribValueRaw && (node.attribValueRaw.startsWith("\"") || node.attribValueRaw.startsWith("'")) && node.attribValueStartsAt && node.attribOpeningQuoteAt && context.str[node.attribValueStartsAt] === context.str[node.attribOpeningQuoteAt]) {
        var _message = "Delete repeated opening quotes.";
        context.report({
          ruleId: "attribute-malformed",
          message: _message,
          idxFrom: node.attribStarts,
          idxTo: node.attribEnds,
          fix: {
            // delete the character
            ranges: [[node.attribValueStartsAt, node.attribValueStartsAt + 1]]
          }
        });
        repeatedQuotesPresent = true;
      } // repeated closing quotes


      if (node.attribValueRaw && ( // value ends with a quote
      node.attribValueRaw.endsWith("\"") || node.attribValueRaw.endsWith("'")) && node.attribValueEndsAt && node.attribClosingQuoteAt && context.str[node.attribValueEndsAt] === context.str[node.attribClosingQuoteAt]) {
        var _message2 = "Delete repeated closing quotes.";
        context.report({
          ruleId: "attribute-malformed",
          message: _message2,
          idxFrom: node.attribStarts,
          idxTo: node.attribEnds,
          fix: {
            // delete the character
            ranges: [[node.attribValueEndsAt - 1, node.attribValueEndsAt]]
          }
        });
        repeatedQuotesPresent = true;
      } // check the opening quote


      if (context.str[node.attribOpeningQuoteAt] !== (inTheEndUseDoubles ? "\"" : "'")) {
        // does it exist?
        if (node.attribOpeningQuoteAt) {
          context.report({
            ruleId: "attribute-malformed",
            message: "Wrong opening quote.",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            fix: {
              ranges: [[node.attribOpeningQuoteAt, node.attribOpeningQuoteAt + 1, inTheEndUseDoubles ? "\"" : "'"]]
            }
          });
        } else if (node.attribValueStartsAt) {
          context.report({
            ruleId: "attribute-malformed",
            message: "Add an opening quote.",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            fix: {
              ranges: [[left(context.str, node.attribValueStartsAt) + 1, node.attribValueStartsAt, inTheEndUseDoubles ? "\"" : "'"]]
            }
          });
        }
      } // check the closing quote


      if (context.str[node.attribClosingQuoteAt] !== (inTheEndUseDoubles ? "\"" : "'")) {
        if (node.attribClosingQuoteAt) {
          context.report({
            ruleId: "attribute-malformed",
            message: "Wrong closing quote.",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            fix: {
              ranges: [[node.attribClosingQuoteAt, node.attribClosingQuoteAt + 1, inTheEndUseDoubles ? "\"" : "'"]]
            }
          });
        } else if (node.attribValueEndsAt || node.attribOpeningQuoteAt) { // if the is no value, only opening quote:
          // <img alt="/>
          // value will be null, so we use opening quote's position instead

          var startPos = node.attribOpeningQuoteAt;

          if (node.attribValueStartsAt) {
            // correction for trailing whitespace,
            // <div class=“foo\n>z</div>
            //                ^^
            startPos = node.attribValueStartsAt + node.attribValueRaw.trimEnd().length;
          }

          context.report({
            ruleId: "attribute-malformed",
            message: "Add a closing quote.",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            fix: {
              ranges: [[startPos, node.attribValueEndsAt || node.attribOpeningQuoteAt, inTheEndUseDoubles ? "\"" : "'"]]
            }
          });
        }
      } // check the whitespace in front of an attribute
      // <span class="x"id="left">
      //                ^


      if (node.parent.pureHTML && node.attribLeft && node.attribStarts && (node.attribLeft + 2 !== node.attribStarts || context.str[node.attribStarts - 1] !== " ")) {
        context.report({
          ruleId: "attribute-malformed",
          message: "Add a space.",
          idxFrom: node.attribStarts,
          idxTo: node.attribEnds,
          fix: {
            ranges: [[node.attribLeft + 1, node.attribStarts, " "]]
          }
        });
      } // finally, check, do the attribute contents need to be encoded


      if (!repeatedQuotesPresent && node.attribValueStartsAt && node.attribValueEndsAt && typeof node.attribValueRaw === "string" && (inTheEndUseDoubles && node.attribValueRaw.includes("\"") || !inTheEndUseDoubles && node.attribValueRaw.includes("'"))) {
        node.attribValueRaw.split("").forEach(function (char, idx) {
          if (char === (inTheEndUseDoubles ? "\"" : "'")) {
            context.report({
              ruleId: "attribute-malformed",
              message: "Unencoded quote.",
              idxFrom: node.attribValueStartsAt,
              idxTo: node.attribValueEndsAt,
              fix: {
                ranges: [[node.attribValueStartsAt + idx, node.attribValueStartsAt + idx + 1, inTheEndUseDoubles ? "&quot;" : "&apos;"]]
              }
            });
          }
        });
      }
    }
  };
}

var attributeOnClosingTag = function attributeOnClosingTag(context) {
  return {
    tag: function tag(node) { // if there is more than 1 attribute

      if (node.closing && Array.isArray(node.attribs) && node.attribs.length) {
        context.report({
          ruleId: "attribute-on-closing-tag",
          message: "Attribute on a closing tag.",
          idxFrom: node.attribs[0].attribStarts,
          idxTo: node.attribs[node.attribs.length - 1].attribEnds,
          fix: null
        });
      }
    }
  };
};

// -----------------------------------------------------------------------------

function attributeEnforceImgAlt(context) {
  return {
    tag: function tag(node) {

      if ( // whoever reads this, I'm writing the following lines looking
      // at the terminal, at line above, "node" object printed out.
      // Normally, you can't write rules blindly, you first wire up
      // a blank rule which does nothing (the console.log above), then
      // see what's coming in, then tap those key values you want.
      node.type === "tag" && node.tagName === "img" && (!node.attribs.length || !node.attribs.some(function (attrib) {
        return !attrib.attribName || attrib.attribName.toLowerCase() === "alt";
      }))) {
        var startPos = node.attribs.length ? node.attribs[~-node.attribs.length].attribEnds : node.tagNameEndsAt;
        var endPos = startPos; // if there's excessive whitespace, extend the replacement:
        // <img   >
        //     ^^
        //     replace all this with ` alt=""`, respect whitespace being present
        // that is, don't turn `<img  >` into `<img alt="">` but into
        // `<img alt="" >`

        if (context.str[startPos + 1] && !context.str[startPos].trim() && !context.str[startPos + 1].trim() && right(context.str, startPos)) {
          endPos = right(context.str, startPos) - 1;
        }

        context.report({
          ruleId: "attribute-enforce-img-alt",
          message: "Add an alt attribute.",
          idxFrom: node.start,
          idxTo: node.end,
          fix: {
            ranges: [[startPos, endPos, ' alt=""']]
          }
        });
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateAbbr(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "abbr") {
        // validate the parent
        if (!["td", "th"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-abbr",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // only check for rogue whitespace - value can be any string


        var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
            errorArr = _checkForWhitespace.errorArr;
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-abbr"
          }));
        });
      }
    }
  };
}

var knownUnits = ["cm", "mm", "in", "px", "pt", "pc", "em", "ex", "ch", "rem", "vw", "vh", "vmin", "vmax", "%"];
var knownCharsets = ["adobe-standard-encoding", "adobe-symbol-encoding", "amiga-1251", "ansi_x3.110-1983", "asmo_449", "big5", "big5-hkscs", "bocu-1", "brf", "bs_4730", "bs_viewdata", "cesu-8", "cp50220", "cp51932", "csa_z243.4-1985-1", "csa_z243.4-1985-2", "csa_z243.4-1985-gr", "csn_369103", "dec-mcs", "din_66003", "dk-us", "ds_2089", "ebcdic-at-de", "ebcdic-at-de-a", "ebcdic-ca-fr", "ebcdic-dk-no", "ebcdic-dk-no-a", "ebcdic-es", "ebcdic-es-a", "ebcdic-es-s", "ebcdic-fi-se", "ebcdic-fi-se-a", "ebcdic-fr", "ebcdic-it", "ebcdic-pt", "ebcdic-uk", "ebcdic-us", "ecma-cyrillic", "es", "es2", "euc-kr", "extended_unix_code_fixed_width_for_japanese", "extended_unix_code_packed_format_for_japanese", "gb18030", "gb2312", "gb_1988-80", "gb_2312-80", "gbk", "gost_19768-74", "greek-ccitt", "greek7", "greek7-old", "hp-desktop", "hp-legal", "hp-math8", "hp-pi-font", "hp-roman8", "hz-gb-2312", "ibm-symbols", "ibm-thai", "ibm00858", "ibm00924", "ibm01140", "ibm01141", "ibm01142", "ibm01143", "ibm01144", "ibm01145", "ibm01146", "ibm01147", "ibm01148", "ibm01149", "ibm037", "ibm038", "ibm1026", "ibm1047", "ibm273", "ibm274", "ibm275", "ibm277", "ibm278", "ibm280", "ibm281", "ibm284", "ibm285", "ibm290", "ibm297", "ibm420", "ibm423", "ibm424", "ibm437", "ibm500", "ibm775", "ibm850", "ibm851", "ibm852", "ibm855", "ibm857", "ibm860", "ibm861", "ibm862", "ibm863", "ibm864", "ibm865", "ibm866", "ibm868", "ibm869", "ibm870", "ibm871", "ibm880", "ibm891", "ibm903", "ibm904", "ibm905", "ibm918", "iec_p27-1", "inis", "inis-8", "inis-cyrillic", "invariant", "iso-10646-j-1", "iso-10646-ucs-2", "iso-10646-ucs-4", "iso-10646-ucs-basic", "iso-10646-unicode-latin1", "iso-10646-utf-1", "iso-11548-1", "iso-2022-cn", "iso-2022-cn-ext", "iso-2022-jp", "iso-2022-jp-2", "iso-2022-kr", "iso-8859-1-windows-3.0-latin-1", "iso-8859-1-windows-3.1-latin-1", "iso-8859-10", "iso-8859-13", "iso-8859-14", "iso-8859-15", "iso-8859-16", "iso-8859-2-windows-latin-2", "iso-8859-9-windows-latin-5", "iso-ir-90", "iso-unicode-ibm-1261", "iso-unicode-ibm-1264", "iso-unicode-ibm-1265", "iso-unicode-ibm-1268", "iso-unicode-ibm-1276", "iso_10367-box", "iso_2033-1983", "iso_5427", "iso_5427:1981", "iso_5428:1980", "iso_646.basic:1983", "iso_646.irv:1983", "iso_6937-2-25", "iso_6937-2-add", "iso_8859-1:1987", "iso_8859-2:1987", "iso_8859-3:1988", "iso_8859-4:1988", "iso_8859-5:1988", "iso_8859-6-e", "iso_8859-6-i", "iso_8859-6:1987", "iso_8859-7:1987", "iso_8859-8-e", "iso_8859-8-i", "iso_8859-8:1988", "iso_8859-9:1989", "iso_8859-supp", "it", "jis_c6220-1969-jp", "jis_c6220-1969-ro", "jis_c6226-1978", "jis_c6226-1983", "jis_c6229-1984-a", "jis_c6229-1984-b", "jis_c6229-1984-b-add", "jis_c6229-1984-hand", "jis_c6229-1984-hand-add", "jis_c6229-1984-kana", "jis_encoding", "jis_x0201", "jis_x0212-1990", "jus_i.b1.002", "jus_i.b1.003-mac", "jus_i.b1.003-serb", "koi7-switched", "koi8-r", "koi8-u", "ks_c_5601-1987", "ksc5636", "kz-1048", "latin-greek", "latin-greek-1", "latin-lap", "macintosh", "microsoft-publishing", "mnem", "mnemonic", "msz_7795.3", "nats-dano", "nats-dano-add", "nats-sefi", "nats-sefi-add", "nc_nc00-10:81", "nf_z_62-010", "nf_z_62-010_(1973)", "ns_4551-1", "ns_4551-2", "osd_ebcdic_df03_irv", "osd_ebcdic_df04_1", "osd_ebcdic_df04_15", "pc8-danish-norwegian", "pc8-turkish", "pt", "pt2", "ptcp154", "scsu", "sen_850200_b", "sen_850200_c", "shift_jis", "t.101-g2", "t.61-7bit", "t.61-8bit", "tis-620", "tscii", "unicode-1-1", "unicode-1-1-utf-7", "unknown-8bit", "us-ascii", "us-dk", "utf-16", "utf-16be", "utf-16le", "utf-32", "utf-32be", "utf-32le", "utf-7", "utf-8", "ventura-international", "ventura-math", "ventura-us", "videotex-suppl", "viqr", "viscii", "windows-1250", "windows-1251", "windows-1252", "windows-1253", "windows-1254", "windows-1255", "windows-1256", "windows-1257", "windows-1258", "windows-31j", "windows-874"]; // https://www.w3.org/TR/html4/sgml/loosedtd.html#Color
// "There are also 16 widely known color names with their sRGB values"

var basicColorNames = {
  aqua: "#00ffff",
  black: "#000000",
  blue: "#0000ff",
  fuchsia: "#ff00ff",
  gray: "#808080",
  green: "#008000",
  lime: "#00ff00",
  maroon: "#800000",
  navy: "#000080",
  olive: "#808000",
  purple: "#800080",
  red: "#ff0000",
  silver: "#c0c0c0",
  teal: "#008080",
  white: "#ffffff",
  yellow: "#ffff00"
}; // https://www.w3schools.com/colors/colors_names.asp
// https://developer.mozilla.org/en-US/docs/Web/CSS/color_value

var extendedColorNames = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgrey: "#a9a9a9",
  darkgreen: "#006400",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  grey: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgrey: "#d3d3d3",
  lightgreen: "#90ee90",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
var sixDigitHexColorRegex = /^#([a-f0-9]{6})$/i;
var classNameRegex = /^-?[_a-zA-Z]+[_a-zA-Z0-9-]*$/;

// -----------------------------------------------------------------------------

function attributeValidateAcceptCharset(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "accept-charset") {
        // validate the parent
        if (!["form"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-accept-charset",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // validate against the charsets list from IANA:
        // https://www.iana.org/assignments/character-sets/character-sets.xhtml
        // https://www.w3.org/TR/html4/interact/forms.html#adef-accept-charset


        var errorArr = validateString(node.attribValueRaw, node.attribValueStartsAt, {
          canBeCommaSeparated: true,
          noSpaceAfterComma: true,
          quickPermittedValues: ["UNKNOWN"],
          permittedValues: knownCharsets
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-accept-charset"
          }));
        });
      }
    }
  };
}

var require$$0 = {
  "application/1d-interleaved-parityfec": {
    source: "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/3gpp-ims+xml": {
    source: "iana",
    compressible: true
  },
  "application/a2l": {
    source: "iana"
  },
  "application/activemessage": {
    source: "iana"
  },
  "application/activity+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-directory+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcost+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcostparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointprop+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointpropparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-error+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamcontrol+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamparams+json": {
    source: "iana",
    compressible: true
  },
  "application/aml": {
    source: "iana"
  },
  "application/andrew-inset": {
    source: "iana",
    extensions: ["ez"]
  },
  "application/applefile": {
    source: "iana"
  },
  "application/applixware": {
    source: "apache",
    extensions: ["aw"]
  },
  "application/atf": {
    source: "iana"
  },
  "application/atfx": {
    source: "iana"
  },
  "application/atom+xml": {
    source: "iana",
    compressible: true,
    extensions: ["atom"]
  },
  "application/atomcat+xml": {
    source: "iana",
    compressible: true,
    extensions: ["atomcat"]
  },
  "application/atomdeleted+xml": {
    source: "iana",
    compressible: true,
    extensions: ["atomdeleted"]
  },
  "application/atomicmail": {
    source: "iana"
  },
  "application/atomsvc+xml": {
    source: "iana",
    compressible: true,
    extensions: ["atomsvc"]
  },
  "application/atsc-dwd+xml": {
    source: "iana",
    compressible: true,
    extensions: ["dwd"]
  },
  "application/atsc-dynamic-event-message": {
    source: "iana"
  },
  "application/atsc-held+xml": {
    source: "iana",
    compressible: true,
    extensions: ["held"]
  },
  "application/atsc-rdt+json": {
    source: "iana",
    compressible: true
  },
  "application/atsc-rsat+xml": {
    source: "iana",
    compressible: true,
    extensions: ["rsat"]
  },
  "application/atxml": {
    source: "iana"
  },
  "application/auth-policy+xml": {
    source: "iana",
    compressible: true
  },
  "application/bacnet-xdd+zip": {
    source: "iana",
    compressible: false
  },
  "application/batch-smtp": {
    source: "iana"
  },
  "application/bdoc": {
    compressible: false,
    extensions: ["bdoc"]
  },
  "application/beep+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/calendar+json": {
    source: "iana",
    compressible: true
  },
  "application/calendar+xml": {
    source: "iana",
    compressible: true,
    extensions: ["xcs"]
  },
  "application/call-completion": {
    source: "iana"
  },
  "application/cals-1840": {
    source: "iana"
  },
  "application/captive+json": {
    source: "iana",
    compressible: true
  },
  "application/cbor": {
    source: "iana"
  },
  "application/cbor-seq": {
    source: "iana"
  },
  "application/cccex": {
    source: "iana"
  },
  "application/ccmp+xml": {
    source: "iana",
    compressible: true
  },
  "application/ccxml+xml": {
    source: "iana",
    compressible: true,
    extensions: ["ccxml"]
  },
  "application/cdfx+xml": {
    source: "iana",
    compressible: true,
    extensions: ["cdfx"]
  },
  "application/cdmi-capability": {
    source: "iana",
    extensions: ["cdmia"]
  },
  "application/cdmi-container": {
    source: "iana",
    extensions: ["cdmic"]
  },
  "application/cdmi-domain": {
    source: "iana",
    extensions: ["cdmid"]
  },
  "application/cdmi-object": {
    source: "iana",
    extensions: ["cdmio"]
  },
  "application/cdmi-queue": {
    source: "iana",
    extensions: ["cdmiq"]
  },
  "application/cdni": {
    source: "iana"
  },
  "application/cea": {
    source: "iana"
  },
  "application/cea-2018+xml": {
    source: "iana",
    compressible: true
  },
  "application/cellml+xml": {
    source: "iana",
    compressible: true
  },
  "application/cfw": {
    source: "iana"
  },
  "application/clr": {
    source: "iana"
  },
  "application/clue+xml": {
    source: "iana",
    compressible: true
  },
  "application/clue_info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cms": {
    source: "iana"
  },
  "application/cnrp+xml": {
    source: "iana",
    compressible: true
  },
  "application/coap-group+json": {
    source: "iana",
    compressible: true
  },
  "application/coap-payload": {
    source: "iana"
  },
  "application/commonground": {
    source: "iana"
  },
  "application/conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cose": {
    source: "iana"
  },
  "application/cose-key": {
    source: "iana"
  },
  "application/cose-key-set": {
    source: "iana"
  },
  "application/cpl+xml": {
    source: "iana",
    compressible: true
  },
  "application/csrattrs": {
    source: "iana"
  },
  "application/csta+xml": {
    source: "iana",
    compressible: true
  },
  "application/cstadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/csvm+json": {
    source: "iana",
    compressible: true
  },
  "application/cu-seeme": {
    source: "apache",
    extensions: ["cu"]
  },
  "application/cwt": {
    source: "iana"
  },
  "application/cybercash": {
    source: "iana"
  },
  "application/dart": {
    compressible: true
  },
  "application/dash+xml": {
    source: "iana",
    compressible: true,
    extensions: ["mpd"]
  },
  "application/dashdelta": {
    source: "iana"
  },
  "application/davmount+xml": {
    source: "iana",
    compressible: true,
    extensions: ["davmount"]
  },
  "application/dca-rft": {
    source: "iana"
  },
  "application/dcd": {
    source: "iana"
  },
  "application/dec-dx": {
    source: "iana"
  },
  "application/dialog-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/dicom": {
    source: "iana"
  },
  "application/dicom+json": {
    source: "iana",
    compressible: true
  },
  "application/dicom+xml": {
    source: "iana",
    compressible: true
  },
  "application/dii": {
    source: "iana"
  },
  "application/dit": {
    source: "iana"
  },
  "application/dns": {
    source: "iana"
  },
  "application/dns+json": {
    source: "iana",
    compressible: true
  },
  "application/dns-message": {
    source: "iana"
  },
  "application/docbook+xml": {
    source: "apache",
    compressible: true,
    extensions: ["dbk"]
  },
  "application/dots+cbor": {
    source: "iana"
  },
  "application/dskpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/dssc+der": {
    source: "iana",
    extensions: ["dssc"]
  },
  "application/dssc+xml": {
    source: "iana",
    compressible: true,
    extensions: ["xdssc"]
  },
  "application/dvcs": {
    source: "iana"
  },
  "application/ecmascript": {
    source: "iana",
    compressible: true,
    extensions: ["ecma", "es"]
  },
  "application/edi-consent": {
    source: "iana"
  },
  "application/edi-x12": {
    source: "iana",
    compressible: false
  },
  "application/edifact": {
    source: "iana",
    compressible: false
  },
  "application/efi": {
    source: "iana"
  },
  "application/elm+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/elm+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.cap+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/emergencycalldata.comment+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.control+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.deviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.ecall.msd": {
    source: "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.serviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.veds+xml": {
    source: "iana",
    compressible: true
  },
  "application/emma+xml": {
    source: "iana",
    compressible: true,
    extensions: ["emma"]
  },
  "application/emotionml+xml": {
    source: "iana",
    compressible: true,
    extensions: ["emotionml"]
  },
  "application/encaprtp": {
    source: "iana"
  },
  "application/epp+xml": {
    source: "iana",
    compressible: true
  },
  "application/epub+zip": {
    source: "iana",
    compressible: false,
    extensions: ["epub"]
  },
  "application/eshop": {
    source: "iana"
  },
  "application/exi": {
    source: "iana",
    extensions: ["exi"]
  },
  "application/expect-ct-report+json": {
    source: "iana",
    compressible: true
  },
  "application/fastinfoset": {
    source: "iana"
  },
  "application/fastsoap": {
    source: "iana"
  },
  "application/fdt+xml": {
    source: "iana",
    compressible: true,
    extensions: ["fdt"]
  },
  "application/fhir+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fhir+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fido.trusted-apps+json": {
    compressible: true
  },
  "application/fits": {
    source: "iana"
  },
  "application/flexfec": {
    source: "iana"
  },
  "application/font-sfnt": {
    source: "iana"
  },
  "application/font-tdpfr": {
    source: "iana",
    extensions: ["pfr"]
  },
  "application/font-woff": {
    source: "iana",
    compressible: false
  },
  "application/framework-attributes+xml": {
    source: "iana",
    compressible: true
  },
  "application/geo+json": {
    source: "iana",
    compressible: true,
    extensions: ["geojson"]
  },
  "application/geo+json-seq": {
    source: "iana"
  },
  "application/geopackage+sqlite3": {
    source: "iana"
  },
  "application/geoxacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/gltf-buffer": {
    source: "iana"
  },
  "application/gml+xml": {
    source: "iana",
    compressible: true,
    extensions: ["gml"]
  },
  "application/gpx+xml": {
    source: "apache",
    compressible: true,
    extensions: ["gpx"]
  },
  "application/gxf": {
    source: "apache",
    extensions: ["gxf"]
  },
  "application/gzip": {
    source: "iana",
    compressible: false,
    extensions: ["gz"]
  },
  "application/h224": {
    source: "iana"
  },
  "application/held+xml": {
    source: "iana",
    compressible: true
  },
  "application/hjson": {
    extensions: ["hjson"]
  },
  "application/http": {
    source: "iana"
  },
  "application/hyperstudio": {
    source: "iana",
    extensions: ["stk"]
  },
  "application/ibe-key-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pkg-reply+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pp-data": {
    source: "iana"
  },
  "application/iges": {
    source: "iana"
  },
  "application/im-iscomposing+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/index": {
    source: "iana"
  },
  "application/index.cmd": {
    source: "iana"
  },
  "application/index.obj": {
    source: "iana"
  },
  "application/index.response": {
    source: "iana"
  },
  "application/index.vnd": {
    source: "iana"
  },
  "application/inkml+xml": {
    source: "iana",
    compressible: true,
    extensions: ["ink", "inkml"]
  },
  "application/iotp": {
    source: "iana"
  },
  "application/ipfix": {
    source: "iana",
    extensions: ["ipfix"]
  },
  "application/ipp": {
    source: "iana"
  },
  "application/isup": {
    source: "iana"
  },
  "application/its+xml": {
    source: "iana",
    compressible: true,
    extensions: ["its"]
  },
  "application/java-archive": {
    source: "apache",
    compressible: false,
    extensions: ["jar", "war", "ear"]
  },
  "application/java-serialized-object": {
    source: "apache",
    compressible: false,
    extensions: ["ser"]
  },
  "application/java-vm": {
    source: "apache",
    compressible: false,
    extensions: ["class"]
  },
  "application/javascript": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: ["js", "mjs"]
  },
  "application/jf2feed+json": {
    source: "iana",
    compressible: true
  },
  "application/jose": {
    source: "iana"
  },
  "application/jose+json": {
    source: "iana",
    compressible: true
  },
  "application/jrd+json": {
    source: "iana",
    compressible: true
  },
  "application/jscalendar+json": {
    source: "iana",
    compressible: true
  },
  "application/json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: ["json", "map"]
  },
  "application/json-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/json-seq": {
    source: "iana"
  },
  "application/json5": {
    extensions: ["json5"]
  },
  "application/jsonml+json": {
    source: "apache",
    compressible: true,
    extensions: ["jsonml"]
  },
  "application/jwk+json": {
    source: "iana",
    compressible: true
  },
  "application/jwk-set+json": {
    source: "iana",
    compressible: true
  },
  "application/jwt": {
    source: "iana"
  },
  "application/kpml-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/kpml-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/ld+json": {
    source: "iana",
    compressible: true,
    extensions: ["jsonld"]
  },
  "application/lgr+xml": {
    source: "iana",
    compressible: true,
    extensions: ["lgr"]
  },
  "application/link-format": {
    source: "iana"
  },
  "application/load-control+xml": {
    source: "iana",
    compressible: true
  },
  "application/lost+xml": {
    source: "iana",
    compressible: true,
    extensions: ["lostxml"]
  },
  "application/lostsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/lpf+zip": {
    source: "iana",
    compressible: false
  },
  "application/lxf": {
    source: "iana"
  },
  "application/mac-binhex40": {
    source: "iana",
    extensions: ["hqx"]
  },
  "application/mac-compactpro": {
    source: "apache",
    extensions: ["cpt"]
  },
  "application/macwriteii": {
    source: "iana"
  },
  "application/mads+xml": {
    source: "iana",
    compressible: true,
    extensions: ["mads"]
  },
  "application/manifest+json": {
    charset: "UTF-8",
    compressible: true,
    extensions: ["webmanifest"]
  },
  "application/marc": {
    source: "iana",
    extensions: ["mrc"]
  },
  "application/marcxml+xml": {
    source: "iana",
    compressible: true,
    extensions: ["mrcx"]
  },
  "application/mathematica": {
    source: "iana",
    extensions: ["ma", "nb", "mb"]
  },
  "application/mathml+xml": {
    source: "iana",
    compressible: true,
    extensions: ["mathml"]
  },
  "application/mathml-content+xml": {
    source: "iana",
    compressible: true
  },
  "application/mathml-presentation+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-associated-procedure-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-deregister+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-envelope+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-protection-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-reception-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-schedule+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-user-service-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbox": {
    source: "iana",
    extensions: ["mbox"]
  },
  "application/media-policy-dataset+xml": {
    source: "iana",
    compressible: true
  },
  "application/media_control+xml": {
    source: "iana",
    compressible: true
  },
  "application/mediaservercontrol+xml": {
    source: "iana",
    compressible: true,
    extensions: ["mscml"]
  },
  "application/merge-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/metalink+xml": {
    source: "apache",
    compressible: true,
    extensions: ["metalink"]
  },
  "application/metalink4+xml": {
    source: "iana",
    compressible: true,
    extensions: ["meta4"]
  },
  "application/mets+xml": {
    source: "iana",
    compressible: true,
    extensions: ["mets"]
  },
  "application/mf4": {
    source: "iana"
  },
  "application/mikey": {
    source: "iana"
  },
  "application/mipc": {
    source: "iana"
  },
  "application/mmt-aei+xml": {
    source: "iana",
    compressible: true,
    extensions: ["maei"]
  },
  "application/mmt-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: ["musd"]
  },
  "application/mods+xml": {
    source: "iana",
    compressible: true,
    extensions: ["mods"]
  },
  "application/moss-keys": {
    source: "iana"
  },
  "application/moss-signature": {
    source: "iana"
  },
  "application/mosskey-data": {
    source: "iana"
  },
  "application/mosskey-request": {
    source: "iana"
  },
  "application/mp21": {
    source: "iana",
    extensions: ["m21", "mp21"]
  },
  "application/mp4": {
    source: "iana",
    extensions: ["mp4s", "m4p"]
  },
  "application/mpeg4-generic": {
    source: "iana"
  },
  "application/mpeg4-iod": {
    source: "iana"
  },
  "application/mpeg4-iod-xmt": {
    source: "iana"
  },
  "application/mrb-consumer+xml": {
    source: "iana",
    compressible: true,
    extensions: ["xdf"]
  },
  "application/mrb-publish+xml": {
    source: "iana",
    compressible: true,
    extensions: ["xdf"]
  },
  "application/msc-ivr+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msc-mixer+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msword": {
    source: "iana",
    compressible: false,
    extensions: ["doc", "dot"]
  },
  "application/mud+json": {
    source: "iana",
    compressible: true
  },
  "application/multipart-core": {
    source: "iana"
  },
  "application/mxf": {
    source: "iana",
    extensions: ["mxf"]
  },
  "application/n-quads": {
    source: "iana",
    extensions: ["nq"]
  },
  "application/n-triples": {
    source: "iana",
    extensions: ["nt"]
  },
  "application/nasdata": {
    source: "iana"
  },
  "application/news-checkgroups": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-groupinfo": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-transmission": {
    source: "iana"
  },
  "application/nlsml+xml": {
    source: "iana",
    compressible: true
  },
  "application/node": {
    source: "iana",
    extensions: ["cjs"]
  },
  "application/nss": {
    source: "iana"
  },
  "application/ocsp-request": {
    source: "iana"
  },
  "application/ocsp-response": {
    source: "iana"
  },
  "application/octet-stream": {
    source: "iana",
    compressible: false,
    extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
  },
  "application/oda": {
    source: "iana",
    extensions: ["oda"]
  },
  "application/odm+xml": {
    source: "iana",
    compressible: true
  },
  "application/odx": {
    source: "iana"
  },
  "application/oebps-package+xml": {
    source: "iana",
    compressible: true,
    extensions: ["opf"]
  },
  "application/ogg": {
    source: "iana",
    compressible: false,
    extensions: ["ogx"]
  },
  "application/omdoc+xml": {
    source: "apache",
    compressible: true,
    extensions: ["omdoc"]
  },
  "application/onenote": {
    source: "apache",
    extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
  },
  "application/opc-nodeset+xml": {
    source: "iana",
    compressible: true
  },
  "application/oscore": {
    source: "iana"
  },
  "application/oxps": {
    source: "iana",
    extensions: ["oxps"]
  },
  "application/p2p-overlay+xml": {
    source: "iana",
    compressible: true,
    extensions: ["relo"]
  },
  "application/parityfec": {
    source: "iana"
  },
  "application/passport": {
    source: "iana"
  },
  "application/patch-ops-error+xml": {
    source: "iana",
    compressible: true,
    extensions: ["xer"]
  },
  "application/pdf": {
    source: "iana",
    compressible: false,
    extensions: ["pdf"]
  },
  "application/pdx": {
    source: "iana"
  },
  "application/pem-certificate-chain": {
    source: "iana"
  },
  "application/pgp-encrypted": {
    source: "iana",
    compressible: false,
    extensions: ["pgp"]
  },
  "application/pgp-keys": {
    source: "iana"
  },
  "application/pgp-signature": {
    source: "iana",
    extensions: ["asc", "sig"]
  },
  "application/pics-rules": {
    source: "apache",
    extensions: ["prf"]
  },
  "application/pidf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pidf-diff+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pkcs10": {
    source: "iana",
    extensions: ["p10"]
  },
  "application/pkcs12": {
    source: "iana"
  },
  "application/pkcs7-mime": {
    source: "iana",
    extensions: ["p7m", "p7c"]
  },
  "application/pkcs7-signature": {
    source: "iana",
    extensions: ["p7s"]
  },
  "application/pkcs8": {
    source: "iana",
    extensions: ["p8"]
  },
  "application/pkcs8-encrypted": {
    source: "iana"
  },
  "application/pkix-attr-cert": {
    source: "iana",
    extensions: ["ac"]
  },
  "application/pkix-cert": {
    source: "iana",
    extensions: ["cer"]
  },
  "application/pkix-crl": {
    source: "iana",
    extensions: ["crl"]
  },
  "application/pkix-pkipath": {
    source: "iana",
    extensions: ["pkipath"]
  },
  "application/pkixcmp": {
    source: "iana",
    extensions: ["pki"]
  },
  "application/pls+xml": {
    source: "iana",
    compressible: true,
    extensions: ["pls"]
  },
  "application/poc-settings+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/postscript": {
    source: "iana",
    compressible: true,
    extensions: ["ai", "eps", "ps"]
  },
  "application/ppsp-tracker+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+xml": {
    source: "iana",
    compressible: true
  },
  "application/provenance+xml": {
    source: "iana",
    compressible: true,
    extensions: ["provx"]
  },
  "application/prs.alvestrand.titrax-sheet": {
    source: "iana"
  },
  "application/prs.cww": {
    source: "iana",
    extensions: ["cww"]
  },
  "application/prs.cyn": {
    source: "iana",
    charset: "7-BIT"
  },
  "application/prs.hpub+zip": {
    source: "iana",
    compressible: false
  },
  "application/prs.nprend": {
    source: "iana"
  },
  "application/prs.plucker": {
    source: "iana"
  },
  "application/prs.rdf-xml-crypt": {
    source: "iana"
  },
  "application/prs.xsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/pskc+xml": {
    source: "iana",
    compressible: true,
    extensions: ["pskcxml"]
  },
  "application/pvd+json": {
    source: "iana",
    compressible: true
  },
  "application/qsig": {
    source: "iana"
  },
  "application/raml+yaml": {
    compressible: true,
    extensions: ["raml"]
  },
  "application/raptorfec": {
    source: "iana"
  },
  "application/rdap+json": {
    source: "iana",
    compressible: true
  },
  "application/rdf+xml": {
    source: "iana",
    compressible: true,
    extensions: ["rdf", "owl"]
  },
  "application/reginfo+xml": {
    source: "iana",
    compressible: true,
    extensions: ["rif"]
  },
  "application/relax-ng-compact-syntax": {
    source: "iana",
    extensions: ["rnc"]
  },
  "application/remote-printing": {
    source: "iana"
  },
  "application/reputon+json": {
    source: "iana",
    compressible: true
  },
  "application/resource-lists+xml": {
    source: "iana",
    compressible: true,
    extensions: ["rl"]
  },
  "application/resource-lists-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: ["rld"]
  },
  "application/rfc+xml": {
    source: "iana",
    compressible: true
  },
  "application/riscos": {
    source: "iana"
  },
  "application/rlmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/rls-services+xml": {
    source: "iana",
    compressible: true,
    extensions: ["rs"]
  },
  "application/route-apd+xml": {
    source: "iana",
    compressible: true,
    extensions: ["rapd"]
  },
  "application/route-s-tsid+xml": {
    source: "iana",
    compressible: true,
    extensions: ["sls"]
  },
  "application/route-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: ["rusd"]
  },
  "application/rpki-ghostbusters": {
    source: "iana",
    extensions: ["gbr"]
  },
  "application/rpki-manifest": {
    source: "iana",
    extensions: ["mft"]
  },
  "application/rpki-publication": {
    source: "iana"
  },
  "application/rpki-roa": {
    source: "iana",
    extensions: ["roa"]
  },
  "application/rpki-updown": {
    source: "iana"
  },
  "application/rsd+xml": {
    source: "apache",
    compressible: true,
    extensions: ["rsd"]
  },
  "application/rss+xml": {
    source: "apache",
    compressible: true,
    extensions: ["rss"]
  },
  "application/rtf": {
    source: "iana",
    compressible: true,
    extensions: ["rtf"]
  },
  "application/rtploopback": {
    source: "iana"
  },
  "application/rtx": {
    source: "iana"
  },
  "application/samlassertion+xml": {
    source: "iana",
    compressible: true
  },
  "application/samlmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/sarif+json": {
    source: "iana",
    compressible: true
  },
  "application/sbe": {
    source: "iana"
  },
  "application/sbml+xml": {
    source: "iana",
    compressible: true,
    extensions: ["sbml"]
  },
  "application/scaip+xml": {
    source: "iana",
    compressible: true
  },
  "application/scim+json": {
    source: "iana",
    compressible: true
  },
  "application/scvp-cv-request": {
    source: "iana",
    extensions: ["scq"]
  },
  "application/scvp-cv-response": {
    source: "iana",
    extensions: ["scs"]
  },
  "application/scvp-vp-request": {
    source: "iana",
    extensions: ["spq"]
  },
  "application/scvp-vp-response": {
    source: "iana",
    extensions: ["spp"]
  },
  "application/sdp": {
    source: "iana",
    extensions: ["sdp"]
  },
  "application/secevent+jwt": {
    source: "iana"
  },
  "application/senml+cbor": {
    source: "iana"
  },
  "application/senml+json": {
    source: "iana",
    compressible: true
  },
  "application/senml+xml": {
    source: "iana",
    compressible: true,
    extensions: ["senmlx"]
  },
  "application/senml-etch+cbor": {
    source: "iana"
  },
  "application/senml-etch+json": {
    source: "iana",
    compressible: true
  },
  "application/senml-exi": {
    source: "iana"
  },
  "application/sensml+cbor": {
    source: "iana"
  },
  "application/sensml+json": {
    source: "iana",
    compressible: true
  },
  "application/sensml+xml": {
    source: "iana",
    compressible: true,
    extensions: ["sensmlx"]
  },
  "application/sensml-exi": {
    source: "iana"
  },
  "application/sep+xml": {
    source: "iana",
    compressible: true
  },
  "application/sep-exi": {
    source: "iana"
  },
  "application/session-info": {
    source: "iana"
  },
  "application/set-payment": {
    source: "iana"
  },
  "application/set-payment-initiation": {
    source: "iana",
    extensions: ["setpay"]
  },
  "application/set-registration": {
    source: "iana"
  },
  "application/set-registration-initiation": {
    source: "iana",
    extensions: ["setreg"]
  },
  "application/sgml": {
    source: "iana"
  },
  "application/sgml-open-catalog": {
    source: "iana"
  },
  "application/shf+xml": {
    source: "iana",
    compressible: true,
    extensions: ["shf"]
  },
  "application/sieve": {
    source: "iana",
    extensions: ["siv", "sieve"]
  },
  "application/simple-filter+xml": {
    source: "iana",
    compressible: true
  },
  "application/simple-message-summary": {
    source: "iana"
  },
  "application/simplesymbolcontainer": {
    source: "iana"
  },
  "application/sipc": {
    source: "iana"
  },
  "application/slate": {
    source: "iana"
  },
  "application/smil": {
    source: "iana"
  },
  "application/smil+xml": {
    source: "iana",
    compressible: true,
    extensions: ["smi", "smil"]
  },
  "application/smpte336m": {
    source: "iana"
  },
  "application/soap+fastinfoset": {
    source: "iana"
  },
  "application/soap+xml": {
    source: "iana",
    compressible: true
  },
  "application/sparql-query": {
    source: "iana",
    extensions: ["rq"]
  },
  "application/sparql-results+xml": {
    source: "iana",
    compressible: true,
    extensions: ["srx"]
  },
  "application/spirits-event+xml": {
    source: "iana",
    compressible: true
  },
  "application/sql": {
    source: "iana"
  },
  "application/srgs": {
    source: "iana",
    extensions: ["gram"]
  },
  "application/srgs+xml": {
    source: "iana",
    compressible: true,
    extensions: ["grxml"]
  },
  "application/sru+xml": {
    source: "iana",
    compressible: true,
    extensions: ["sru"]
  },
  "application/ssdl+xml": {
    source: "apache",
    compressible: true,
    extensions: ["ssdl"]
  },
  "application/ssml+xml": {
    source: "iana",
    compressible: true,
    extensions: ["ssml"]
  },
  "application/stix+json": {
    source: "iana",
    compressible: true
  },
  "application/swid+xml": {
    source: "iana",
    compressible: true,
    extensions: ["swidtag"]
  },
  "application/tamp-apex-update": {
    source: "iana"
  },
  "application/tamp-apex-update-confirm": {
    source: "iana"
  },
  "application/tamp-community-update": {
    source: "iana"
  },
  "application/tamp-community-update-confirm": {
    source: "iana"
  },
  "application/tamp-error": {
    source: "iana"
  },
  "application/tamp-sequence-adjust": {
    source: "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    source: "iana"
  },
  "application/tamp-status-query": {
    source: "iana"
  },
  "application/tamp-status-response": {
    source: "iana"
  },
  "application/tamp-update": {
    source: "iana"
  },
  "application/tamp-update-confirm": {
    source: "iana"
  },
  "application/tar": {
    compressible: true
  },
  "application/taxii+json": {
    source: "iana",
    compressible: true
  },
  "application/td+json": {
    source: "iana",
    compressible: true
  },
  "application/tei+xml": {
    source: "iana",
    compressible: true,
    extensions: ["tei", "teicorpus"]
  },
  "application/tetra_isi": {
    source: "iana"
  },
  "application/thraud+xml": {
    source: "iana",
    compressible: true,
    extensions: ["tfi"]
  },
  "application/timestamp-query": {
    source: "iana"
  },
  "application/timestamp-reply": {
    source: "iana"
  },
  "application/timestamped-data": {
    source: "iana",
    extensions: ["tsd"]
  },
  "application/tlsrpt+gzip": {
    source: "iana"
  },
  "application/tlsrpt+json": {
    source: "iana",
    compressible: true
  },
  "application/tnauthlist": {
    source: "iana"
  },
  "application/toml": {
    compressible: true,
    extensions: ["toml"]
  },
  "application/trickle-ice-sdpfrag": {
    source: "iana"
  },
  "application/trig": {
    source: "iana"
  },
  "application/ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: ["ttml"]
  },
  "application/tve-trigger": {
    source: "iana"
  },
  "application/tzif": {
    source: "iana"
  },
  "application/tzif-leap": {
    source: "iana"
  },
  "application/ubjson": {
    compressible: false,
    extensions: ["ubj"]
  },
  "application/ulpfec": {
    source: "iana"
  },
  "application/urc-grpsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/urc-ressheet+xml": {
    source: "iana",
    compressible: true,
    extensions: ["rsheet"]
  },
  "application/urc-targetdesc+xml": {
    source: "iana",
    compressible: true,
    extensions: ["td"]
  },
  "application/urc-uisocketdesc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vcard+json": {
    source: "iana",
    compressible: true
  },
  "application/vcard+xml": {
    source: "iana",
    compressible: true
  },
  "application/vemmi": {
    source: "iana"
  },
  "application/vividence.scriptfile": {
    source: "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    source: "iana",
    compressible: true,
    extensions: ["1km"]
  },
  "application/vnd.3gpp-prose+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    source: "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.bsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.gmop+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.interworking-data": {
    source: "iana"
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-payload": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-signalling": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mid-call+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.pic-bw-large": {
    source: "iana",
    extensions: ["plb"]
  },
  "application/vnd.3gpp.pic-bw-small": {
    source: "iana",
    extensions: ["psb"]
  },
  "application/vnd.3gpp.pic-bw-var": {
    source: "iana",
    extensions: ["pvb"]
  },
  "application/vnd.3gpp.sms": {
    source: "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.ussd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.sms": {
    source: "iana"
  },
  "application/vnd.3gpp2.tcap": {
    source: "iana",
    extensions: ["tcap"]
  },
  "application/vnd.3lightssoftware.imagescal": {
    source: "iana"
  },
  "application/vnd.3m.post-it-notes": {
    source: "iana",
    extensions: ["pwn"]
  },
  "application/vnd.accpac.simply.aso": {
    source: "iana",
    extensions: ["aso"]
  },
  "application/vnd.accpac.simply.imp": {
    source: "iana",
    extensions: ["imp"]
  },
  "application/vnd.acucobol": {
    source: "iana",
    extensions: ["acu"]
  },
  "application/vnd.acucorp": {
    source: "iana",
    extensions: ["atc", "acutc"]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    source: "apache",
    compressible: false,
    extensions: ["air"]
  },
  "application/vnd.adobe.flash.movie": {
    source: "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    source: "iana",
    extensions: ["fcdt"]
  },
  "application/vnd.adobe.fxp": {
    source: "iana",
    extensions: ["fxp", "fxpl"]
  },
  "application/vnd.adobe.partial-upload": {
    source: "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    source: "iana",
    compressible: true,
    extensions: ["xdp"]
  },
  "application/vnd.adobe.xfdf": {
    source: "iana",
    extensions: ["xfdf"]
  },
  "application/vnd.aether.imp": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata-pagedef": {
    source: "iana"
  },
  "application/vnd.afpc.cmoca-cmresource": {
    source: "iana"
  },
  "application/vnd.afpc.foca-charset": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codedfont": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codepage": {
    source: "iana"
  },
  "application/vnd.afpc.modca": {
    source: "iana"
  },
  "application/vnd.afpc.modca-cmtable": {
    source: "iana"
  },
  "application/vnd.afpc.modca-formdef": {
    source: "iana"
  },
  "application/vnd.afpc.modca-mediummap": {
    source: "iana"
  },
  "application/vnd.afpc.modca-objectcontainer": {
    source: "iana"
  },
  "application/vnd.afpc.modca-overlay": {
    source: "iana"
  },
  "application/vnd.afpc.modca-pagesegment": {
    source: "iana"
  },
  "application/vnd.ah-barcode": {
    source: "iana"
  },
  "application/vnd.ahead.space": {
    source: "iana",
    extensions: ["ahead"]
  },
  "application/vnd.airzip.filesecure.azf": {
    source: "iana",
    extensions: ["azf"]
  },
  "application/vnd.airzip.filesecure.azs": {
    source: "iana",
    extensions: ["azs"]
  },
  "application/vnd.amadeus+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.amazon.ebook": {
    source: "apache",
    extensions: ["azw"]
  },
  "application/vnd.amazon.mobi8-ebook": {
    source: "iana"
  },
  "application/vnd.americandynamics.acc": {
    source: "iana",
    extensions: ["acc"]
  },
  "application/vnd.amiga.ami": {
    source: "iana",
    extensions: ["ami"]
  },
  "application/vnd.amundsen.maze+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.android.ota": {
    source: "iana"
  },
  "application/vnd.android.package-archive": {
    source: "apache",
    compressible: false,
    extensions: ["apk"]
  },
  "application/vnd.anki": {
    source: "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    source: "iana",
    extensions: ["cii"]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    source: "apache",
    extensions: ["fti"]
  },
  "application/vnd.antix.game-component": {
    source: "iana",
    extensions: ["atx"]
  },
  "application/vnd.apache.thrift.binary": {
    source: "iana"
  },
  "application/vnd.apache.thrift.compact": {
    source: "iana"
  },
  "application/vnd.apache.thrift.json": {
    source: "iana"
  },
  "application/vnd.api+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.aplextor.warrp+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apothekende.reservation+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apple.installer+xml": {
    source: "iana",
    compressible: true,
    extensions: ["mpkg"]
  },
  "application/vnd.apple.keynote": {
    source: "iana",
    extensions: ["key"]
  },
  "application/vnd.apple.mpegurl": {
    source: "iana",
    extensions: ["m3u8"]
  },
  "application/vnd.apple.numbers": {
    source: "iana",
    extensions: ["numbers"]
  },
  "application/vnd.apple.pages": {
    source: "iana",
    extensions: ["pages"]
  },
  "application/vnd.apple.pkpass": {
    compressible: false,
    extensions: ["pkpass"]
  },
  "application/vnd.arastra.swi": {
    source: "iana"
  },
  "application/vnd.aristanetworks.swi": {
    source: "iana",
    extensions: ["swi"]
  },
  "application/vnd.artisan+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.artsquare": {
    source: "iana"
  },
  "application/vnd.astraea-software.iota": {
    source: "iana",
    extensions: ["iota"]
  },
  "application/vnd.audiograph": {
    source: "iana",
    extensions: ["aep"]
  },
  "application/vnd.autopackage": {
    source: "iana"
  },
  "application/vnd.avalon+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.avistar+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.balsamiq.bmml+xml": {
    source: "iana",
    compressible: true,
    extensions: ["bmml"]
  },
  "application/vnd.balsamiq.bmpr": {
    source: "iana"
  },
  "application/vnd.banana-accounting": {
    source: "iana"
  },
  "application/vnd.bbf.usp.error": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bekitzur-stech+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bint.med-content": {
    source: "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.blink-idb-value-wrapper": {
    source: "iana"
  },
  "application/vnd.blueice.multipass": {
    source: "iana",
    extensions: ["mpm"]
  },
  "application/vnd.bluetooth.ep.oob": {
    source: "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    source: "iana"
  },
  "application/vnd.bmi": {
    source: "iana",
    extensions: ["bmi"]
  },
  "application/vnd.bpf": {
    source: "iana"
  },
  "application/vnd.bpf3": {
    source: "iana"
  },
  "application/vnd.businessobjects": {
    source: "iana",
    extensions: ["rep"]
  },
  "application/vnd.byu.uapi+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cab-jscript": {
    source: "iana"
  },
  "application/vnd.canon-cpdl": {
    source: "iana"
  },
  "application/vnd.canon-lips": {
    source: "iana"
  },
  "application/vnd.capasystems-pg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    source: "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    source: "iana"
  },
  "application/vnd.chemdraw+xml": {
    source: "iana",
    compressible: true,
    extensions: ["cdxml"]
  },
  "application/vnd.chess-pgn": {
    source: "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    source: "iana",
    extensions: ["mmd"]
  },
  "application/vnd.ciedi": {
    source: "iana"
  },
  "application/vnd.cinderella": {
    source: "iana",
    extensions: ["cdy"]
  },
  "application/vnd.cirpack.isdn-ext": {
    source: "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    source: "iana",
    compressible: true,
    extensions: ["csl"]
  },
  "application/vnd.claymore": {
    source: "iana",
    extensions: ["cla"]
  },
  "application/vnd.cloanto.rp9": {
    source: "iana",
    extensions: ["rp9"]
  },
  "application/vnd.clonk.c4group": {
    source: "iana",
    extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    source: "iana",
    extensions: ["c11amc"]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    source: "iana",
    extensions: ["c11amz"]
  },
  "application/vnd.coffeescript": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    source: "iana"
  },
  "application/vnd.collection+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.doc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.next+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.comicbook+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.comicbook-rar": {
    source: "iana"
  },
  "application/vnd.commerce-battelle": {
    source: "iana"
  },
  "application/vnd.commonspace": {
    source: "iana",
    extensions: ["csp"]
  },
  "application/vnd.contact.cmsg": {
    source: "iana",
    extensions: ["cdbcmsg"]
  },
  "application/vnd.coreos.ignition+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cosmocaller": {
    source: "iana",
    extensions: ["cmc"]
  },
  "application/vnd.crick.clicker": {
    source: "iana",
    extensions: ["clkx"]
  },
  "application/vnd.crick.clicker.keyboard": {
    source: "iana",
    extensions: ["clkk"]
  },
  "application/vnd.crick.clicker.palette": {
    source: "iana",
    extensions: ["clkp"]
  },
  "application/vnd.crick.clicker.template": {
    source: "iana",
    extensions: ["clkt"]
  },
  "application/vnd.crick.clicker.wordbank": {
    source: "iana",
    extensions: ["clkw"]
  },
  "application/vnd.criticaltools.wbs+xml": {
    source: "iana",
    compressible: true,
    extensions: ["wbs"]
  },
  "application/vnd.cryptii.pipe+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.crypto-shade-file": {
    source: "iana"
  },
  "application/vnd.ctc-posml": {
    source: "iana",
    extensions: ["pml"]
  },
  "application/vnd.ctct.ws+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cups-pdf": {
    source: "iana"
  },
  "application/vnd.cups-postscript": {
    source: "iana"
  },
  "application/vnd.cups-ppd": {
    source: "iana",
    extensions: ["ppd"]
  },
  "application/vnd.cups-raster": {
    source: "iana"
  },
  "application/vnd.cups-raw": {
    source: "iana"
  },
  "application/vnd.curl": {
    source: "iana"
  },
  "application/vnd.curl.car": {
    source: "apache",
    extensions: ["car"]
  },
  "application/vnd.curl.pcurl": {
    source: "apache",
    extensions: ["pcurl"]
  },
  "application/vnd.cyan.dean.root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cybank": {
    source: "iana"
  },
  "application/vnd.cyclonedx+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cyclonedx+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.d3m-dataset": {
    source: "iana"
  },
  "application/vnd.d3m-problem": {
    source: "iana"
  },
  "application/vnd.dart": {
    source: "iana",
    compressible: true,
    extensions: ["dart"]
  },
  "application/vnd.data-vision.rdz": {
    source: "iana",
    extensions: ["rdz"]
  },
  "application/vnd.datapackage+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dataresource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dbf": {
    source: "iana",
    extensions: ["dbf"]
  },
  "application/vnd.debian.binary-package": {
    source: "iana"
  },
  "application/vnd.dece.data": {
    source: "iana",
    extensions: ["uvf", "uvvf", "uvd", "uvvd"]
  },
  "application/vnd.dece.ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: ["uvt", "uvvt"]
  },
  "application/vnd.dece.unspecified": {
    source: "iana",
    extensions: ["uvx", "uvvx"]
  },
  "application/vnd.dece.zip": {
    source: "iana",
    extensions: ["uvz", "uvvz"]
  },
  "application/vnd.denovo.fcselayout-link": {
    source: "iana",
    extensions: ["fe_launch"]
  },
  "application/vnd.desmume.movie": {
    source: "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    source: "iana"
  },
  "application/vnd.dm.delegation+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dna": {
    source: "iana",
    extensions: ["dna"]
  },
  "application/vnd.document+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dolby.mlp": {
    source: "apache",
    extensions: ["mlp"]
  },
  "application/vnd.dolby.mobile.1": {
    source: "iana"
  },
  "application/vnd.dolby.mobile.2": {
    source: "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    source: "iana"
  },
  "application/vnd.dpgraph": {
    source: "iana",
    extensions: ["dpg"]
  },
  "application/vnd.dreamfactory": {
    source: "iana",
    extensions: ["dfac"]
  },
  "application/vnd.drive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ds-keypoint": {
    source: "apache",
    extensions: ["kpxx"]
  },
  "application/vnd.dtg.local": {
    source: "iana"
  },
  "application/vnd.dtg.local.flash": {
    source: "iana"
  },
  "application/vnd.dtg.local.html": {
    source: "iana"
  },
  "application/vnd.dvb.ait": {
    source: "iana",
    extensions: ["ait"]
  },
  "application/vnd.dvb.dvbisl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.dvbj": {
    source: "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    source: "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-container+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-generic+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-init+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.pfr": {
    source: "iana"
  },
  "application/vnd.dvb.service": {
    source: "iana",
    extensions: ["svc"]
  },
  "application/vnd.dxr": {
    source: "iana"
  },
  "application/vnd.dynageo": {
    source: "iana",
    extensions: ["geo"]
  },
  "application/vnd.dzr": {
    source: "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    source: "iana"
  },
  "application/vnd.ecdis-update": {
    source: "iana"
  },
  "application/vnd.ecip.rlp": {
    source: "iana"
  },
  "application/vnd.ecowin.chart": {
    source: "iana",
    extensions: ["mag"]
  },
  "application/vnd.ecowin.filerequest": {
    source: "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    source: "iana"
  },
  "application/vnd.ecowin.series": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    source: "iana"
  },
  "application/vnd.efi.img": {
    source: "iana"
  },
  "application/vnd.efi.iso": {
    source: "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.enliven": {
    source: "iana",
    extensions: ["nml"]
  },
  "application/vnd.enphase.envoy": {
    source: "iana"
  },
  "application/vnd.eprints.data+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.epson.esf": {
    source: "iana",
    extensions: ["esf"]
  },
  "application/vnd.epson.msf": {
    source: "iana",
    extensions: ["msf"]
  },
  "application/vnd.epson.quickanime": {
    source: "iana",
    extensions: ["qam"]
  },
  "application/vnd.epson.salt": {
    source: "iana",
    extensions: ["slt"]
  },
  "application/vnd.epson.ssf": {
    source: "iana",
    extensions: ["ssf"]
  },
  "application/vnd.ericsson.quickcall": {
    source: "iana"
  },
  "application/vnd.espass-espass+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.eszigno3+xml": {
    source: "iana",
    compressible: true,
    extensions: ["es3", "et3"]
  },
  "application/vnd.etsi.aoc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.asic-e+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.asic-s+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.cug+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvcommand+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvservice+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mcid+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mheg5": {
    source: "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.pstn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.sci+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.simservs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.timestamp-token": {
    source: "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.tsl.der": {
    source: "iana"
  },
  "application/vnd.eudora.data": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    source: "iana"
  },
  "application/vnd.exstream-empower+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.exstream-package": {
    source: "iana"
  },
  "application/vnd.ezpix-album": {
    source: "iana",
    extensions: ["ez2"]
  },
  "application/vnd.ezpix-package": {
    source: "iana",
    extensions: ["ez3"]
  },
  "application/vnd.f-secure.mobile": {
    source: "iana"
  },
  "application/vnd.fastcopy-disk-image": {
    source: "iana"
  },
  "application/vnd.fdf": {
    source: "iana",
    extensions: ["fdf"]
  },
  "application/vnd.fdsn.mseed": {
    source: "iana",
    extensions: ["mseed"]
  },
  "application/vnd.fdsn.seed": {
    source: "iana",
    extensions: ["seed", "dataless"]
  },
  "application/vnd.ffsns": {
    source: "iana"
  },
  "application/vnd.ficlab.flb+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.filmit.zfc": {
    source: "iana"
  },
  "application/vnd.fints": {
    source: "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    source: "iana"
  },
  "application/vnd.flographit": {
    source: "iana",
    extensions: ["gph"]
  },
  "application/vnd.fluxtime.clip": {
    source: "iana",
    extensions: ["ftc"]
  },
  "application/vnd.font-fontforge-sfd": {
    source: "iana"
  },
  "application/vnd.framemaker": {
    source: "iana",
    extensions: ["fm", "frame", "maker", "book"]
  },
  "application/vnd.frogans.fnc": {
    source: "iana",
    extensions: ["fnc"]
  },
  "application/vnd.frogans.ltf": {
    source: "iana",
    extensions: ["ltf"]
  },
  "application/vnd.fsc.weblaunch": {
    source: "iana",
    extensions: ["fsc"]
  },
  "application/vnd.fujitsu.oasys": {
    source: "iana",
    extensions: ["oas"]
  },
  "application/vnd.fujitsu.oasys2": {
    source: "iana",
    extensions: ["oa2"]
  },
  "application/vnd.fujitsu.oasys3": {
    source: "iana",
    extensions: ["oa3"]
  },
  "application/vnd.fujitsu.oasysgp": {
    source: "iana",
    extensions: ["fg5"]
  },
  "application/vnd.fujitsu.oasysprs": {
    source: "iana",
    extensions: ["bh2"]
  },
  "application/vnd.fujixerox.art-ex": {
    source: "iana"
  },
  "application/vnd.fujixerox.art4": {
    source: "iana"
  },
  "application/vnd.fujixerox.ddd": {
    source: "iana",
    extensions: ["ddd"]
  },
  "application/vnd.fujixerox.docuworks": {
    source: "iana",
    extensions: ["xdw"]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    source: "iana",
    extensions: ["xbd"]
  },
  "application/vnd.fujixerox.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    source: "iana"
  },
  "application/vnd.fut-misnet": {
    source: "iana"
  },
  "application/vnd.futoin+cbor": {
    source: "iana"
  },
  "application/vnd.futoin+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.fuzzysheet": {
    source: "iana",
    extensions: ["fzs"]
  },
  "application/vnd.genomatix.tuxedo": {
    source: "iana",
    extensions: ["txd"]
  },
  "application/vnd.gentics.grd+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geo+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geocube+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geogebra.file": {
    source: "iana",
    extensions: ["ggb"]
  },
  "application/vnd.geogebra.slides": {
    source: "iana"
  },
  "application/vnd.geogebra.tool": {
    source: "iana",
    extensions: ["ggt"]
  },
  "application/vnd.geometry-explorer": {
    source: "iana",
    extensions: ["gex", "gre"]
  },
  "application/vnd.geonext": {
    source: "iana",
    extensions: ["gxt"]
  },
  "application/vnd.geoplan": {
    source: "iana",
    extensions: ["g2w"]
  },
  "application/vnd.geospace": {
    source: "iana",
    extensions: ["g3w"]
  },
  "application/vnd.gerber": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    source: "iana"
  },
  "application/vnd.gmx": {
    source: "iana",
    extensions: ["gmx"]
  },
  "application/vnd.google-apps.document": {
    compressible: false,
    extensions: ["gdoc"]
  },
  "application/vnd.google-apps.presentation": {
    compressible: false,
    extensions: ["gslides"]
  },
  "application/vnd.google-apps.spreadsheet": {
    compressible: false,
    extensions: ["gsheet"]
  },
  "application/vnd.google-earth.kml+xml": {
    source: "iana",
    compressible: true,
    extensions: ["kml"]
  },
  "application/vnd.google-earth.kmz": {
    source: "iana",
    compressible: false,
    extensions: ["kmz"]
  },
  "application/vnd.gov.sk.e-form+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.gov.sk.e-form+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.grafeq": {
    source: "iana",
    extensions: ["gqf", "gqs"]
  },
  "application/vnd.gridmp": {
    source: "iana"
  },
  "application/vnd.groove-account": {
    source: "iana",
    extensions: ["gac"]
  },
  "application/vnd.groove-help": {
    source: "iana",
    extensions: ["ghf"]
  },
  "application/vnd.groove-identity-message": {
    source: "iana",
    extensions: ["gim"]
  },
  "application/vnd.groove-injector": {
    source: "iana",
    extensions: ["grv"]
  },
  "application/vnd.groove-tool-message": {
    source: "iana",
    extensions: ["gtm"]
  },
  "application/vnd.groove-tool-template": {
    source: "iana",
    extensions: ["tpl"]
  },
  "application/vnd.groove-vcard": {
    source: "iana",
    extensions: ["vcg"]
  },
  "application/vnd.hal+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hal+xml": {
    source: "iana",
    compressible: true,
    extensions: ["hal"]
  },
  "application/vnd.handheld-entertainment+xml": {
    source: "iana",
    compressible: true,
    extensions: ["zmm"]
  },
  "application/vnd.hbci": {
    source: "iana",
    extensions: ["hbci"]
  },
  "application/vnd.hc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hcl-bireports": {
    source: "iana"
  },
  "application/vnd.hdt": {
    source: "iana"
  },
  "application/vnd.heroku+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hhe.lesson-player": {
    source: "iana",
    extensions: ["les"]
  },
  "application/vnd.hp-hpgl": {
    source: "iana",
    extensions: ["hpgl"]
  },
  "application/vnd.hp-hpid": {
    source: "iana",
    extensions: ["hpid"]
  },
  "application/vnd.hp-hps": {
    source: "iana",
    extensions: ["hps"]
  },
  "application/vnd.hp-jlyt": {
    source: "iana",
    extensions: ["jlt"]
  },
  "application/vnd.hp-pcl": {
    source: "iana",
    extensions: ["pcl"]
  },
  "application/vnd.hp-pclxl": {
    source: "iana",
    extensions: ["pclxl"]
  },
  "application/vnd.httphone": {
    source: "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    source: "iana",
    extensions: ["sfd-hdstx"]
  },
  "application/vnd.hyper+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyper-item+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyperdrive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hzn-3d-crossword": {
    source: "iana"
  },
  "application/vnd.ibm.afplinedata": {
    source: "iana"
  },
  "application/vnd.ibm.electronic-media": {
    source: "iana"
  },
  "application/vnd.ibm.minipay": {
    source: "iana",
    extensions: ["mpy"]
  },
  "application/vnd.ibm.modcap": {
    source: "iana",
    extensions: ["afp", "listafp", "list3820"]
  },
  "application/vnd.ibm.rights-management": {
    source: "iana",
    extensions: ["irm"]
  },
  "application/vnd.ibm.secure-container": {
    source: "iana",
    extensions: ["sc"]
  },
  "application/vnd.iccprofile": {
    source: "iana",
    extensions: ["icc", "icm"]
  },
  "application/vnd.ieee.1905": {
    source: "iana"
  },
  "application/vnd.igloader": {
    source: "iana",
    extensions: ["igl"]
  },
  "application/vnd.imagemeter.folder+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.imagemeter.image+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.immervision-ivp": {
    source: "iana",
    extensions: ["ivp"]
  },
  "application/vnd.immervision-ivu": {
    source: "iana",
    extensions: ["ivu"]
  },
  "application/vnd.ims.imsccv1p1": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    source: "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informedcontrol.rms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informix-visionary": {
    source: "iana"
  },
  "application/vnd.infotech.project": {
    source: "iana"
  },
  "application/vnd.infotech.project+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.innopath.wamp.notification": {
    source: "iana"
  },
  "application/vnd.insors.igm": {
    source: "iana",
    extensions: ["igm"]
  },
  "application/vnd.intercon.formnet": {
    source: "iana",
    extensions: ["xpw", "xpx"]
  },
  "application/vnd.intergeo": {
    source: "iana",
    extensions: ["i2g"]
  },
  "application/vnd.intertrust.digibox": {
    source: "iana"
  },
  "application/vnd.intertrust.nncp": {
    source: "iana"
  },
  "application/vnd.intu.qbo": {
    source: "iana",
    extensions: ["qbo"]
  },
  "application/vnd.intu.qfx": {
    source: "iana",
    extensions: ["qfx"]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ipunplugged.rcprofile": {
    source: "iana",
    extensions: ["rcprofile"]
  },
  "application/vnd.irepository.package+xml": {
    source: "iana",
    compressible: true,
    extensions: ["irp"]
  },
  "application/vnd.is-xpr": {
    source: "iana",
    extensions: ["xpr"]
  },
  "application/vnd.isac.fcs": {
    source: "iana",
    extensions: ["fcs"]
  },
  "application/vnd.iso11783-10+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.jam": {
    source: "iana",
    extensions: ["jam"]
  },
  "application/vnd.japannet-directory-service": {
    source: "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-registration": {
    source: "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-verification": {
    source: "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    source: "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    source: "iana",
    extensions: ["rms"]
  },
  "application/vnd.jisp": {
    source: "iana",
    extensions: ["jisp"]
  },
  "application/vnd.joost.joda-archive": {
    source: "iana",
    extensions: ["joda"]
  },
  "application/vnd.jsk.isdn-ngn": {
    source: "iana"
  },
  "application/vnd.kahootz": {
    source: "iana",
    extensions: ["ktz", "ktr"]
  },
  "application/vnd.kde.karbon": {
    source: "iana",
    extensions: ["karbon"]
  },
  "application/vnd.kde.kchart": {
    source: "iana",
    extensions: ["chrt"]
  },
  "application/vnd.kde.kformula": {
    source: "iana",
    extensions: ["kfo"]
  },
  "application/vnd.kde.kivio": {
    source: "iana",
    extensions: ["flw"]
  },
  "application/vnd.kde.kontour": {
    source: "iana",
    extensions: ["kon"]
  },
  "application/vnd.kde.kpresenter": {
    source: "iana",
    extensions: ["kpr", "kpt"]
  },
  "application/vnd.kde.kspread": {
    source: "iana",
    extensions: ["ksp"]
  },
  "application/vnd.kde.kword": {
    source: "iana",
    extensions: ["kwd", "kwt"]
  },
  "application/vnd.kenameaapp": {
    source: "iana",
    extensions: ["htke"]
  },
  "application/vnd.kidspiration": {
    source: "iana",
    extensions: ["kia"]
  },
  "application/vnd.kinar": {
    source: "iana",
    extensions: ["kne", "knp"]
  },
  "application/vnd.koan": {
    source: "iana",
    extensions: ["skp", "skd", "skt", "skm"]
  },
  "application/vnd.kodak-descriptor": {
    source: "iana",
    extensions: ["sse"]
  },
  "application/vnd.las": {
    source: "iana"
  },
  "application/vnd.las.las+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.las.las+xml": {
    source: "iana",
    compressible: true,
    extensions: ["lasxml"]
  },
  "application/vnd.laszip": {
    source: "iana"
  },
  "application/vnd.leap+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.liberty-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    source: "iana",
    extensions: ["lbd"]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    source: "iana",
    compressible: true,
    extensions: ["lbe"]
  },
  "application/vnd.logipipe.circuit+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.loom": {
    source: "iana"
  },
  "application/vnd.lotus-1-2-3": {
    source: "iana",
    extensions: ["123"]
  },
  "application/vnd.lotus-approach": {
    source: "iana",
    extensions: ["apr"]
  },
  "application/vnd.lotus-freelance": {
    source: "iana",
    extensions: ["pre"]
  },
  "application/vnd.lotus-notes": {
    source: "iana",
    extensions: ["nsf"]
  },
  "application/vnd.lotus-organizer": {
    source: "iana",
    extensions: ["org"]
  },
  "application/vnd.lotus-screencam": {
    source: "iana",
    extensions: ["scm"]
  },
  "application/vnd.lotus-wordpro": {
    source: "iana",
    extensions: ["lwp"]
  },
  "application/vnd.macports.portpkg": {
    source: "iana",
    extensions: ["portpkg"]
  },
  "application/vnd.mapbox-vector-tile": {
    source: "iana"
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.license+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.mdcf": {
    source: "iana"
  },
  "application/vnd.mason+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.maxmind.maxmind-db": {
    source: "iana"
  },
  "application/vnd.mcd": {
    source: "iana",
    extensions: ["mcd"]
  },
  "application/vnd.medcalcdata": {
    source: "iana",
    extensions: ["mc1"]
  },
  "application/vnd.mediastation.cdkey": {
    source: "iana",
    extensions: ["cdkey"]
  },
  "application/vnd.meridian-slingshot": {
    source: "iana"
  },
  "application/vnd.mfer": {
    source: "iana",
    extensions: ["mwf"]
  },
  "application/vnd.mfmp": {
    source: "iana",
    extensions: ["mfm"]
  },
  "application/vnd.micro+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.micrografx.flo": {
    source: "iana",
    extensions: ["flo"]
  },
  "application/vnd.micrografx.igx": {
    source: "iana",
    extensions: ["igx"]
  },
  "application/vnd.microsoft.portable-executable": {
    source: "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    source: "iana"
  },
  "application/vnd.miele+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.mif": {
    source: "iana",
    extensions: ["mif"]
  },
  "application/vnd.minisoft-hp3000-save": {
    source: "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    source: "iana"
  },
  "application/vnd.mobius.daf": {
    source: "iana",
    extensions: ["daf"]
  },
  "application/vnd.mobius.dis": {
    source: "iana",
    extensions: ["dis"]
  },
  "application/vnd.mobius.mbk": {
    source: "iana",
    extensions: ["mbk"]
  },
  "application/vnd.mobius.mqy": {
    source: "iana",
    extensions: ["mqy"]
  },
  "application/vnd.mobius.msl": {
    source: "iana",
    extensions: ["msl"]
  },
  "application/vnd.mobius.plc": {
    source: "iana",
    extensions: ["plc"]
  },
  "application/vnd.mobius.txf": {
    source: "iana",
    extensions: ["txf"]
  },
  "application/vnd.mophun.application": {
    source: "iana",
    extensions: ["mpn"]
  },
  "application/vnd.mophun.certificate": {
    source: "iana",
    extensions: ["mpc"]
  },
  "application/vnd.motorola.flexsuite": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    source: "iana"
  },
  "application/vnd.motorola.iprm": {
    source: "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    source: "iana",
    compressible: true,
    extensions: ["xul"]
  },
  "application/vnd.ms-3mfdocument": {
    source: "iana"
  },
  "application/vnd.ms-artgalry": {
    source: "iana",
    extensions: ["cil"]
  },
  "application/vnd.ms-asf": {
    source: "iana"
  },
  "application/vnd.ms-cab-compressed": {
    source: "iana",
    extensions: ["cab"]
  },
  "application/vnd.ms-color.iccprofile": {
    source: "apache"
  },
  "application/vnd.ms-excel": {
    source: "iana",
    compressible: false,
    extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    source: "iana",
    extensions: ["xlam"]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    source: "iana",
    extensions: ["xlsb"]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    source: "iana",
    extensions: ["xlsm"]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    source: "iana",
    extensions: ["xltm"]
  },
  "application/vnd.ms-fontobject": {
    source: "iana",
    compressible: true,
    extensions: ["eot"]
  },
  "application/vnd.ms-htmlhelp": {
    source: "iana",
    extensions: ["chm"]
  },
  "application/vnd.ms-ims": {
    source: "iana",
    extensions: ["ims"]
  },
  "application/vnd.ms-lrm": {
    source: "iana",
    extensions: ["lrm"]
  },
  "application/vnd.ms-office.activex+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-officetheme": {
    source: "iana",
    extensions: ["thmx"]
  },
  "application/vnd.ms-opentype": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-outlook": {
    compressible: false,
    extensions: ["msg"]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    source: "apache"
  },
  "application/vnd.ms-pki.seccat": {
    source: "apache",
    extensions: ["cat"]
  },
  "application/vnd.ms-pki.stl": {
    source: "apache",
    extensions: ["stl"]
  },
  "application/vnd.ms-playready.initiator+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-powerpoint": {
    source: "iana",
    compressible: false,
    extensions: ["ppt", "pps", "pot"]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    source: "iana",
    extensions: ["ppam"]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    source: "iana",
    extensions: ["pptm"]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    source: "iana",
    extensions: ["sldm"]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    source: "iana",
    extensions: ["ppsm"]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    source: "iana",
    extensions: ["potm"]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-printing.printticket+xml": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-printschematicket+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-project": {
    source: "iana",
    extensions: ["mpp", "mpt"]
  },
  "application/vnd.ms-tnef": {
    source: "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    source: "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    source: "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    source: "iana",
    extensions: ["docm"]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    source: "iana",
    extensions: ["dotm"]
  },
  "application/vnd.ms-works": {
    source: "iana",
    extensions: ["wps", "wks", "wcm", "wdb"]
  },
  "application/vnd.ms-wpl": {
    source: "iana",
    extensions: ["wpl"]
  },
  "application/vnd.ms-xpsdocument": {
    source: "iana",
    compressible: false,
    extensions: ["xps"]
  },
  "application/vnd.msa-disk-image": {
    source: "iana"
  },
  "application/vnd.mseq": {
    source: "iana",
    extensions: ["mseq"]
  },
  "application/vnd.msign": {
    source: "iana"
  },
  "application/vnd.multiad.creator": {
    source: "iana"
  },
  "application/vnd.multiad.creator.cif": {
    source: "iana"
  },
  "application/vnd.music-niff": {
    source: "iana"
  },
  "application/vnd.musician": {
    source: "iana",
    extensions: ["mus"]
  },
  "application/vnd.muvee.style": {
    source: "iana",
    extensions: ["msty"]
  },
  "application/vnd.mynfc": {
    source: "iana",
    extensions: ["taglet"]
  },
  "application/vnd.ncd.control": {
    source: "iana"
  },
  "application/vnd.ncd.reference": {
    source: "iana"
  },
  "application/vnd.nearst.inv+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nervana": {
    source: "iana"
  },
  "application/vnd.netfpx": {
    source: "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    source: "iana",
    extensions: ["nlu"]
  },
  "application/vnd.nimn": {
    source: "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    source: "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    source: "iana"
  },
  "application/vnd.nitf": {
    source: "iana",
    extensions: ["ntf", "nitf"]
  },
  "application/vnd.noblenet-directory": {
    source: "iana",
    extensions: ["nnd"]
  },
  "application/vnd.noblenet-sealer": {
    source: "iana",
    extensions: ["nns"]
  },
  "application/vnd.noblenet-web": {
    source: "iana",
    extensions: ["nnw"]
  },
  "application/vnd.nokia.catalogs": {
    source: "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.conml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.iptv.config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.isds-radio-presets": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    source: "iana",
    compressible: true,
    extensions: ["ac"]
  },
  "application/vnd.nokia.n-gage.data": {
    source: "iana",
    extensions: ["ngdat"]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    source: "iana",
    extensions: ["n-gage"]
  },
  "application/vnd.nokia.ncd": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.radio-preset": {
    source: "iana",
    extensions: ["rpst"]
  },
  "application/vnd.nokia.radio-presets": {
    source: "iana",
    extensions: ["rpss"]
  },
  "application/vnd.novadigm.edm": {
    source: "iana",
    extensions: ["edm"]
  },
  "application/vnd.novadigm.edx": {
    source: "iana",
    extensions: ["edx"]
  },
  "application/vnd.novadigm.ext": {
    source: "iana",
    extensions: ["ext"]
  },
  "application/vnd.ntt-local.content-share": {
    source: "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    source: "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    source: "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    source: "iana",
    extensions: ["odc"]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    source: "iana",
    extensions: ["otc"]
  },
  "application/vnd.oasis.opendocument.database": {
    source: "iana",
    extensions: ["odb"]
  },
  "application/vnd.oasis.opendocument.formula": {
    source: "iana",
    extensions: ["odf"]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    source: "iana",
    extensions: ["odft"]
  },
  "application/vnd.oasis.opendocument.graphics": {
    source: "iana",
    compressible: false,
    extensions: ["odg"]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    source: "iana",
    extensions: ["otg"]
  },
  "application/vnd.oasis.opendocument.image": {
    source: "iana",
    extensions: ["odi"]
  },
  "application/vnd.oasis.opendocument.image-template": {
    source: "iana",
    extensions: ["oti"]
  },
  "application/vnd.oasis.opendocument.presentation": {
    source: "iana",
    compressible: false,
    extensions: ["odp"]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    source: "iana",
    extensions: ["otp"]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    source: "iana",
    compressible: false,
    extensions: ["ods"]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    source: "iana",
    extensions: ["ots"]
  },
  "application/vnd.oasis.opendocument.text": {
    source: "iana",
    compressible: false,
    extensions: ["odt"]
  },
  "application/vnd.oasis.opendocument.text-master": {
    source: "iana",
    extensions: ["odm"]
  },
  "application/vnd.oasis.opendocument.text-template": {
    source: "iana",
    extensions: ["ott"]
  },
  "application/vnd.oasis.opendocument.text-web": {
    source: "iana",
    extensions: ["oth"]
  },
  "application/vnd.obn": {
    source: "iana"
  },
  "application/vnd.ocf+cbor": {
    source: "iana"
  },
  "application/vnd.oci.image.manifest.v1+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oftn.l10n+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.cspg-hexbinary": {
    source: "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.pae.gem": {
    source: "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.spdlist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.ueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.userprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.olpc-sugar": {
    source: "iana",
    extensions: ["xo"]
  },
  "application/vnd.oma-scws-config": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-request": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-response": {
    source: "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.imd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.ltkm": {
    source: "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sgdu": {
    source: "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    source: "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sprov+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.stkm": {
    source: "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-pcc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.dcd": {
    source: "iana"
  },
  "application/vnd.oma.dcdc": {
    source: "iana"
  },
  "application/vnd.oma.dd2+xml": {
    source: "iana",
    compressible: true,
    extensions: ["dd2"]
  },
  "application/vnd.oma.drm.risd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.group-usage-list+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+cbor": {
    source: "iana"
  },
  "application/vnd.oma.lwm2m+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+tlv": {
    source: "iana"
  },
  "application/vnd.oma.pal+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.final-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.groups+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.push": {
    source: "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.xcap-directory+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.omads-email+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-file+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-folder+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omaloc-supl-init": {
    source: "iana"
  },
  "application/vnd.onepager": {
    source: "iana"
  },
  "application/vnd.onepagertamp": {
    source: "iana"
  },
  "application/vnd.onepagertamx": {
    source: "iana"
  },
  "application/vnd.onepagertat": {
    source: "iana"
  },
  "application/vnd.onepagertatp": {
    source: "iana"
  },
  "application/vnd.onepagertatx": {
    source: "iana"
  },
  "application/vnd.openblox.game+xml": {
    source: "iana",
    compressible: true,
    extensions: ["obgx"]
  },
  "application/vnd.openblox.game-binary": {
    source: "iana"
  },
  "application/vnd.openeye.oeb": {
    source: "iana"
  },
  "application/vnd.openofficeorg.extension": {
    source: "apache",
    extensions: ["oxt"]
  },
  "application/vnd.openstreetmap.data+xml": {
    source: "iana",
    compressible: true,
    extensions: ["osm"]
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    source: "iana",
    compressible: false,
    extensions: ["pptx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    source: "iana",
    extensions: ["sldx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    source: "iana",
    extensions: ["ppsx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    source: "iana",
    extensions: ["potx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    source: "iana",
    compressible: false,
    extensions: ["xlsx"]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    source: "iana",
    extensions: ["xltx"]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    source: "iana",
    compressible: false,
    extensions: ["docx"]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    source: "iana",
    extensions: ["dotx"]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oracle.resource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.orange.indata": {
    source: "iana"
  },
  "application/vnd.osa.netdeploy": {
    source: "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    source: "iana",
    extensions: ["mgp"]
  },
  "application/vnd.osgi.bundle": {
    source: "iana"
  },
  "application/vnd.osgi.dp": {
    source: "iana",
    extensions: ["dp"]
  },
  "application/vnd.osgi.subsystem": {
    source: "iana",
    extensions: ["esa"]
  },
  "application/vnd.otps.ct-kip+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oxli.countgraph": {
    source: "iana"
  },
  "application/vnd.pagerduty+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.palm": {
    source: "iana",
    extensions: ["pdb", "pqa", "oprc"]
  },
  "application/vnd.panoply": {
    source: "iana"
  },
  "application/vnd.paos.xml": {
    source: "iana"
  },
  "application/vnd.patentdive": {
    source: "iana"
  },
  "application/vnd.patientecommsdoc": {
    source: "iana"
  },
  "application/vnd.pawaafile": {
    source: "iana",
    extensions: ["paw"]
  },
  "application/vnd.pcos": {
    source: "iana"
  },
  "application/vnd.pg.format": {
    source: "iana",
    extensions: ["str"]
  },
  "application/vnd.pg.osasli": {
    source: "iana",
    extensions: ["ei6"]
  },
  "application/vnd.piaccess.application-licence": {
    source: "iana"
  },
  "application/vnd.picsel": {
    source: "iana",
    extensions: ["efif"]
  },
  "application/vnd.pmi.widget": {
    source: "iana",
    extensions: ["wg"]
  },
  "application/vnd.poc.group-advertisement+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.pocketlearn": {
    source: "iana",
    extensions: ["plf"]
  },
  "application/vnd.powerbuilder6": {
    source: "iana",
    extensions: ["pbd"]
  },
  "application/vnd.powerbuilder6-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder7": {
    source: "iana"
  },
  "application/vnd.powerbuilder7-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder75": {
    source: "iana"
  },
  "application/vnd.powerbuilder75-s": {
    source: "iana"
  },
  "application/vnd.preminet": {
    source: "iana"
  },
  "application/vnd.previewsystems.box": {
    source: "iana",
    extensions: ["box"]
  },
  "application/vnd.proteus.magazine": {
    source: "iana",
    extensions: ["mgz"]
  },
  "application/vnd.psfs": {
    source: "iana"
  },
  "application/vnd.publishare-delta-tree": {
    source: "iana",
    extensions: ["qps"]
  },
  "application/vnd.pvi.ptid1": {
    source: "iana",
    extensions: ["ptid"]
  },
  "application/vnd.pwg-multiplexed": {
    source: "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.qualcomm.brew-app-res": {
    source: "iana"
  },
  "application/vnd.quarantainenet": {
    source: "iana"
  },
  "application/vnd.quark.quarkxpress": {
    source: "iana",
    extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
  },
  "application/vnd.quobject-quoxdocument": {
    source: "iana"
  },
  "application/vnd.radisys.moml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rainstor.data": {
    source: "iana"
  },
  "application/vnd.rapid": {
    source: "iana"
  },
  "application/vnd.rar": {
    source: "iana",
    extensions: ["rar"]
  },
  "application/vnd.realvnc.bed": {
    source: "iana",
    extensions: ["bed"]
  },
  "application/vnd.recordare.musicxml": {
    source: "iana",
    extensions: ["mxl"]
  },
  "application/vnd.recordare.musicxml+xml": {
    source: "iana",
    compressible: true,
    extensions: ["musicxml"]
  },
  "application/vnd.renlearn.rlprint": {
    source: "iana"
  },
  "application/vnd.restful+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rig.cryptonote": {
    source: "iana",
    extensions: ["cryptonote"]
  },
  "application/vnd.rim.cod": {
    source: "apache",
    extensions: ["cod"]
  },
  "application/vnd.rn-realmedia": {
    source: "apache",
    extensions: ["rm"]
  },
  "application/vnd.rn-realmedia-vbr": {
    source: "apache",
    extensions: ["rmvb"]
  },
  "application/vnd.route66.link66+xml": {
    source: "iana",
    compressible: true,
    extensions: ["link66"]
  },
  "application/vnd.rs-274x": {
    source: "iana"
  },
  "application/vnd.ruckus.download": {
    source: "iana"
  },
  "application/vnd.s3sms": {
    source: "iana"
  },
  "application/vnd.sailingtracker.track": {
    source: "iana",
    extensions: ["st"]
  },
  "application/vnd.sar": {
    source: "iana"
  },
  "application/vnd.sbm.cid": {
    source: "iana"
  },
  "application/vnd.sbm.mid2": {
    source: "iana"
  },
  "application/vnd.scribus": {
    source: "iana"
  },
  "application/vnd.sealed.3df": {
    source: "iana"
  },
  "application/vnd.sealed.csf": {
    source: "iana"
  },
  "application/vnd.sealed.doc": {
    source: "iana"
  },
  "application/vnd.sealed.eml": {
    source: "iana"
  },
  "application/vnd.sealed.mht": {
    source: "iana"
  },
  "application/vnd.sealed.net": {
    source: "iana"
  },
  "application/vnd.sealed.ppt": {
    source: "iana"
  },
  "application/vnd.sealed.tiff": {
    source: "iana"
  },
  "application/vnd.sealed.xls": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    source: "iana"
  },
  "application/vnd.seemail": {
    source: "iana",
    extensions: ["see"]
  },
  "application/vnd.seis+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.sema": {
    source: "iana",
    extensions: ["sema"]
  },
  "application/vnd.semd": {
    source: "iana",
    extensions: ["semd"]
  },
  "application/vnd.semf": {
    source: "iana",
    extensions: ["semf"]
  },
  "application/vnd.shade-save-file": {
    source: "iana"
  },
  "application/vnd.shana.informed.formdata": {
    source: "iana",
    extensions: ["ifm"]
  },
  "application/vnd.shana.informed.formtemplate": {
    source: "iana",
    extensions: ["itp"]
  },
  "application/vnd.shana.informed.interchange": {
    source: "iana",
    extensions: ["iif"]
  },
  "application/vnd.shana.informed.package": {
    source: "iana",
    extensions: ["ipk"]
  },
  "application/vnd.shootproof+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shopkick+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shp": {
    source: "iana"
  },
  "application/vnd.shx": {
    source: "iana"
  },
  "application/vnd.sigrok.session": {
    source: "iana"
  },
  "application/vnd.simtech-mindmapper": {
    source: "iana",
    extensions: ["twd", "twds"]
  },
  "application/vnd.siren+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.smaf": {
    source: "iana",
    extensions: ["mmf"]
  },
  "application/vnd.smart.notebook": {
    source: "iana"
  },
  "application/vnd.smart.teacher": {
    source: "iana",
    extensions: ["teacher"]
  },
  "application/vnd.snesdev-page-table": {
    source: "iana"
  },
  "application/vnd.software602.filler.form+xml": {
    source: "iana",
    compressible: true,
    extensions: ["fo"]
  },
  "application/vnd.software602.filler.form-xml-zip": {
    source: "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    source: "iana",
    compressible: true,
    extensions: ["sdkm", "sdkd"]
  },
  "application/vnd.spotfire.dxp": {
    source: "iana",
    extensions: ["dxp"]
  },
  "application/vnd.spotfire.sfs": {
    source: "iana",
    extensions: ["sfs"]
  },
  "application/vnd.sqlite3": {
    source: "iana"
  },
  "application/vnd.sss-cod": {
    source: "iana"
  },
  "application/vnd.sss-dtf": {
    source: "iana"
  },
  "application/vnd.sss-ntf": {
    source: "iana"
  },
  "application/vnd.stardivision.calc": {
    source: "apache",
    extensions: ["sdc"]
  },
  "application/vnd.stardivision.draw": {
    source: "apache",
    extensions: ["sda"]
  },
  "application/vnd.stardivision.impress": {
    source: "apache",
    extensions: ["sdd"]
  },
  "application/vnd.stardivision.math": {
    source: "apache",
    extensions: ["smf"]
  },
  "application/vnd.stardivision.writer": {
    source: "apache",
    extensions: ["sdw", "vor"]
  },
  "application/vnd.stardivision.writer-global": {
    source: "apache",
    extensions: ["sgl"]
  },
  "application/vnd.stepmania.package": {
    source: "iana",
    extensions: ["smzip"]
  },
  "application/vnd.stepmania.stepchart": {
    source: "iana",
    extensions: ["sm"]
  },
  "application/vnd.street-stream": {
    source: "iana"
  },
  "application/vnd.sun.wadl+xml": {
    source: "iana",
    compressible: true,
    extensions: ["wadl"]
  },
  "application/vnd.sun.xml.calc": {
    source: "apache",
    extensions: ["sxc"]
  },
  "application/vnd.sun.xml.calc.template": {
    source: "apache",
    extensions: ["stc"]
  },
  "application/vnd.sun.xml.draw": {
    source: "apache",
    extensions: ["sxd"]
  },
  "application/vnd.sun.xml.draw.template": {
    source: "apache",
    extensions: ["std"]
  },
  "application/vnd.sun.xml.impress": {
    source: "apache",
    extensions: ["sxi"]
  },
  "application/vnd.sun.xml.impress.template": {
    source: "apache",
    extensions: ["sti"]
  },
  "application/vnd.sun.xml.math": {
    source: "apache",
    extensions: ["sxm"]
  },
  "application/vnd.sun.xml.writer": {
    source: "apache",
    extensions: ["sxw"]
  },
  "application/vnd.sun.xml.writer.global": {
    source: "apache",
    extensions: ["sxg"]
  },
  "application/vnd.sun.xml.writer.template": {
    source: "apache",
    extensions: ["stw"]
  },
  "application/vnd.sus-calendar": {
    source: "iana",
    extensions: ["sus", "susp"]
  },
  "application/vnd.svd": {
    source: "iana",
    extensions: ["svd"]
  },
  "application/vnd.swiftview-ics": {
    source: "iana"
  },
  "application/vnd.sycle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.symbian.install": {
    source: "apache",
    extensions: ["sis", "sisx"]
  },
  "application/vnd.syncml+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: ["xsm"]
  },
  "application/vnd.syncml.dm+wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: ["bdm"]
  },
  "application/vnd.syncml.dm+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: ["xdm"]
  },
  "application/vnd.syncml.dm.notification": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: ["ddf"]
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.syncml.ds.notification": {
    source: "iana"
  },
  "application/vnd.tableschema+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tao.intent-module-archive": {
    source: "iana",
    extensions: ["tao"]
  },
  "application/vnd.tcpdump.pcap": {
    source: "iana",
    extensions: ["pcap", "cap", "dmp"]
  },
  "application/vnd.think-cell.ppttc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tml": {
    source: "iana"
  },
  "application/vnd.tmobile-livetv": {
    source: "iana",
    extensions: ["tmo"]
  },
  "application/vnd.tri.onesource": {
    source: "iana"
  },
  "application/vnd.trid.tpt": {
    source: "iana",
    extensions: ["tpt"]
  },
  "application/vnd.triscape.mxs": {
    source: "iana",
    extensions: ["mxs"]
  },
  "application/vnd.trueapp": {
    source: "iana",
    extensions: ["tra"]
  },
  "application/vnd.truedoc": {
    source: "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    source: "iana"
  },
  "application/vnd.ufdl": {
    source: "iana",
    extensions: ["ufd", "ufdl"]
  },
  "application/vnd.uiq.theme": {
    source: "iana",
    extensions: ["utz"]
  },
  "application/vnd.umajin": {
    source: "iana",
    extensions: ["umj"]
  },
  "application/vnd.unity": {
    source: "iana",
    extensions: ["unityweb"]
  },
  "application/vnd.uoml+xml": {
    source: "iana",
    compressible: true,
    extensions: ["uoml"]
  },
  "application/vnd.uplanet.alert": {
    source: "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.channel": {
    source: "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.list": {
    source: "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.signal": {
    source: "iana"
  },
  "application/vnd.uri-map": {
    source: "iana"
  },
  "application/vnd.valve.source.material": {
    source: "iana"
  },
  "application/vnd.vcx": {
    source: "iana",
    extensions: ["vcx"]
  },
  "application/vnd.vd-study": {
    source: "iana"
  },
  "application/vnd.vectorworks": {
    source: "iana"
  },
  "application/vnd.vel+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.verimatrix.vcas": {
    source: "iana"
  },
  "application/vnd.veryant.thin": {
    source: "iana"
  },
  "application/vnd.ves.encrypted": {
    source: "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    source: "iana"
  },
  "application/vnd.visio": {
    source: "iana",
    extensions: ["vsd", "vst", "vss", "vsw"]
  },
  "application/vnd.visionary": {
    source: "iana",
    extensions: ["vis"]
  },
  "application/vnd.vividence.scriptfile": {
    source: "iana"
  },
  "application/vnd.vsf": {
    source: "iana",
    extensions: ["vsf"]
  },
  "application/vnd.wap.sic": {
    source: "iana"
  },
  "application/vnd.wap.slc": {
    source: "iana"
  },
  "application/vnd.wap.wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: ["wbxml"]
  },
  "application/vnd.wap.wmlc": {
    source: "iana",
    extensions: ["wmlc"]
  },
  "application/vnd.wap.wmlscriptc": {
    source: "iana",
    extensions: ["wmlsc"]
  },
  "application/vnd.webturbo": {
    source: "iana",
    extensions: ["wtb"]
  },
  "application/vnd.wfa.dpp": {
    source: "iana"
  },
  "application/vnd.wfa.p2p": {
    source: "iana"
  },
  "application/vnd.wfa.wsc": {
    source: "iana"
  },
  "application/vnd.windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.wmc": {
    source: "iana"
  },
  "application/vnd.wmf.bootstrap": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    source: "iana"
  },
  "application/vnd.wolfram.player": {
    source: "iana",
    extensions: ["nbp"]
  },
  "application/vnd.wordperfect": {
    source: "iana",
    extensions: ["wpd"]
  },
  "application/vnd.wqd": {
    source: "iana",
    extensions: ["wqd"]
  },
  "application/vnd.wrq-hp3000-labelled": {
    source: "iana"
  },
  "application/vnd.wt.stf": {
    source: "iana",
    extensions: ["stf"]
  },
  "application/vnd.wv.csp+wbxml": {
    source: "iana"
  },
  "application/vnd.wv.csp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.wv.ssp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xacml+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xara": {
    source: "iana",
    extensions: ["xar"]
  },
  "application/vnd.xfdl": {
    source: "iana",
    extensions: ["xfdl"]
  },
  "application/vnd.xfdl.webform": {
    source: "iana"
  },
  "application/vnd.xmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xmpie.cpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.dpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.plan": {
    source: "iana"
  },
  "application/vnd.xmpie.ppkg": {
    source: "iana"
  },
  "application/vnd.xmpie.xlim": {
    source: "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    source: "iana",
    extensions: ["hvd"]
  },
  "application/vnd.yamaha.hv-script": {
    source: "iana",
    extensions: ["hvs"]
  },
  "application/vnd.yamaha.hv-voice": {
    source: "iana",
    extensions: ["hvp"]
  },
  "application/vnd.yamaha.openscoreformat": {
    source: "iana",
    extensions: ["osf"]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    source: "iana",
    compressible: true,
    extensions: ["osfpvg"]
  },
  "application/vnd.yamaha.remote-setup": {
    source: "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    source: "iana",
    extensions: ["saf"]
  },
  "application/vnd.yamaha.smaf-phrase": {
    source: "iana",
    extensions: ["spf"]
  },
  "application/vnd.yamaha.through-ngn": {
    source: "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    source: "iana"
  },
  "application/vnd.yaoweme": {
    source: "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    source: "iana",
    extensions: ["cmp"]
  },
  "application/vnd.youtube.yt": {
    source: "iana"
  },
  "application/vnd.zul": {
    source: "iana",
    extensions: ["zir", "zirz"]
  },
  "application/vnd.zzazz.deck+xml": {
    source: "iana",
    compressible: true,
    extensions: ["zaz"]
  },
  "application/voicexml+xml": {
    source: "iana",
    compressible: true,
    extensions: ["vxml"]
  },
  "application/voucher-cms+json": {
    source: "iana",
    compressible: true
  },
  "application/vq-rtcpxr": {
    source: "iana"
  },
  "application/wasm": {
    compressible: true,
    extensions: ["wasm"]
  },
  "application/watcherinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/webpush-options+json": {
    source: "iana",
    compressible: true
  },
  "application/whoispp-query": {
    source: "iana"
  },
  "application/whoispp-response": {
    source: "iana"
  },
  "application/widget": {
    source: "iana",
    extensions: ["wgt"]
  },
  "application/winhlp": {
    source: "apache",
    extensions: ["hlp"]
  },
  "application/wita": {
    source: "iana"
  },
  "application/wordperfect5.1": {
    source: "iana"
  },
  "application/wsdl+xml": {
    source: "iana",
    compressible: true,
    extensions: ["wsdl"]
  },
  "application/wspolicy+xml": {
    source: "iana",
    compressible: true,
    extensions: ["wspolicy"]
  },
  "application/x-7z-compressed": {
    source: "apache",
    compressible: false,
    extensions: ["7z"]
  },
  "application/x-abiword": {
    source: "apache",
    extensions: ["abw"]
  },
  "application/x-ace-compressed": {
    source: "apache",
    extensions: ["ace"]
  },
  "application/x-amf": {
    source: "apache"
  },
  "application/x-apple-diskimage": {
    source: "apache",
    extensions: ["dmg"]
  },
  "application/x-arj": {
    compressible: false,
    extensions: ["arj"]
  },
  "application/x-authorware-bin": {
    source: "apache",
    extensions: ["aab", "x32", "u32", "vox"]
  },
  "application/x-authorware-map": {
    source: "apache",
    extensions: ["aam"]
  },
  "application/x-authorware-seg": {
    source: "apache",
    extensions: ["aas"]
  },
  "application/x-bcpio": {
    source: "apache",
    extensions: ["bcpio"]
  },
  "application/x-bdoc": {
    compressible: false,
    extensions: ["bdoc"]
  },
  "application/x-bittorrent": {
    source: "apache",
    extensions: ["torrent"]
  },
  "application/x-blorb": {
    source: "apache",
    extensions: ["blb", "blorb"]
  },
  "application/x-bzip": {
    source: "apache",
    compressible: false,
    extensions: ["bz"]
  },
  "application/x-bzip2": {
    source: "apache",
    compressible: false,
    extensions: ["bz2", "boz"]
  },
  "application/x-cbr": {
    source: "apache",
    extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
  },
  "application/x-cdlink": {
    source: "apache",
    extensions: ["vcd"]
  },
  "application/x-cfs-compressed": {
    source: "apache",
    extensions: ["cfs"]
  },
  "application/x-chat": {
    source: "apache",
    extensions: ["chat"]
  },
  "application/x-chess-pgn": {
    source: "apache",
    extensions: ["pgn"]
  },
  "application/x-chrome-extension": {
    extensions: ["crx"]
  },
  "application/x-cocoa": {
    source: "nginx",
    extensions: ["cco"]
  },
  "application/x-compress": {
    source: "apache"
  },
  "application/x-conference": {
    source: "apache",
    extensions: ["nsc"]
  },
  "application/x-cpio": {
    source: "apache",
    extensions: ["cpio"]
  },
  "application/x-csh": {
    source: "apache",
    extensions: ["csh"]
  },
  "application/x-deb": {
    compressible: false
  },
  "application/x-debian-package": {
    source: "apache",
    extensions: ["deb", "udeb"]
  },
  "application/x-dgc-compressed": {
    source: "apache",
    extensions: ["dgc"]
  },
  "application/x-director": {
    source: "apache",
    extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
  },
  "application/x-doom": {
    source: "apache",
    extensions: ["wad"]
  },
  "application/x-dtbncx+xml": {
    source: "apache",
    compressible: true,
    extensions: ["ncx"]
  },
  "application/x-dtbook+xml": {
    source: "apache",
    compressible: true,
    extensions: ["dtb"]
  },
  "application/x-dtbresource+xml": {
    source: "apache",
    compressible: true,
    extensions: ["res"]
  },
  "application/x-dvi": {
    source: "apache",
    compressible: false,
    extensions: ["dvi"]
  },
  "application/x-envoy": {
    source: "apache",
    extensions: ["evy"]
  },
  "application/x-eva": {
    source: "apache",
    extensions: ["eva"]
  },
  "application/x-font-bdf": {
    source: "apache",
    extensions: ["bdf"]
  },
  "application/x-font-dos": {
    source: "apache"
  },
  "application/x-font-framemaker": {
    source: "apache"
  },
  "application/x-font-ghostscript": {
    source: "apache",
    extensions: ["gsf"]
  },
  "application/x-font-libgrx": {
    source: "apache"
  },
  "application/x-font-linux-psf": {
    source: "apache",
    extensions: ["psf"]
  },
  "application/x-font-pcf": {
    source: "apache",
    extensions: ["pcf"]
  },
  "application/x-font-snf": {
    source: "apache",
    extensions: ["snf"]
  },
  "application/x-font-speedo": {
    source: "apache"
  },
  "application/x-font-sunos-news": {
    source: "apache"
  },
  "application/x-font-type1": {
    source: "apache",
    extensions: ["pfa", "pfb", "pfm", "afm"]
  },
  "application/x-font-vfont": {
    source: "apache"
  },
  "application/x-freearc": {
    source: "apache",
    extensions: ["arc"]
  },
  "application/x-futuresplash": {
    source: "apache",
    extensions: ["spl"]
  },
  "application/x-gca-compressed": {
    source: "apache",
    extensions: ["gca"]
  },
  "application/x-glulx": {
    source: "apache",
    extensions: ["ulx"]
  },
  "application/x-gnumeric": {
    source: "apache",
    extensions: ["gnumeric"]
  },
  "application/x-gramps-xml": {
    source: "apache",
    extensions: ["gramps"]
  },
  "application/x-gtar": {
    source: "apache",
    extensions: ["gtar"]
  },
  "application/x-gzip": {
    source: "apache"
  },
  "application/x-hdf": {
    source: "apache",
    extensions: ["hdf"]
  },
  "application/x-httpd-php": {
    compressible: true,
    extensions: ["php"]
  },
  "application/x-install-instructions": {
    source: "apache",
    extensions: ["install"]
  },
  "application/x-iso9660-image": {
    source: "apache",
    extensions: ["iso"]
  },
  "application/x-java-archive-diff": {
    source: "nginx",
    extensions: ["jardiff"]
  },
  "application/x-java-jnlp-file": {
    source: "apache",
    compressible: false,
    extensions: ["jnlp"]
  },
  "application/x-javascript": {
    compressible: true
  },
  "application/x-keepass2": {
    extensions: ["kdbx"]
  },
  "application/x-latex": {
    source: "apache",
    compressible: false,
    extensions: ["latex"]
  },
  "application/x-lua-bytecode": {
    extensions: ["luac"]
  },
  "application/x-lzh-compressed": {
    source: "apache",
    extensions: ["lzh", "lha"]
  },
  "application/x-makeself": {
    source: "nginx",
    extensions: ["run"]
  },
  "application/x-mie": {
    source: "apache",
    extensions: ["mie"]
  },
  "application/x-mobipocket-ebook": {
    source: "apache",
    extensions: ["prc", "mobi"]
  },
  "application/x-mpegurl": {
    compressible: false
  },
  "application/x-ms-application": {
    source: "apache",
    extensions: ["application"]
  },
  "application/x-ms-shortcut": {
    source: "apache",
    extensions: ["lnk"]
  },
  "application/x-ms-wmd": {
    source: "apache",
    extensions: ["wmd"]
  },
  "application/x-ms-wmz": {
    source: "apache",
    extensions: ["wmz"]
  },
  "application/x-ms-xbap": {
    source: "apache",
    extensions: ["xbap"]
  },
  "application/x-msaccess": {
    source: "apache",
    extensions: ["mdb"]
  },
  "application/x-msbinder": {
    source: "apache",
    extensions: ["obd"]
  },
  "application/x-mscardfile": {
    source: "apache",
    extensions: ["crd"]
  },
  "application/x-msclip": {
    source: "apache",
    extensions: ["clp"]
  },
  "application/x-msdos-program": {
    extensions: ["exe"]
  },
  "application/x-msdownload": {
    source: "apache",
    extensions: ["exe", "dll", "com", "bat", "msi"]
  },
  "application/x-msmediaview": {
    source: "apache",
    extensions: ["mvb", "m13", "m14"]
  },
  "application/x-msmetafile": {
    source: "apache",
    extensions: ["wmf", "wmz", "emf", "emz"]
  },
  "application/x-msmoney": {
    source: "apache",
    extensions: ["mny"]
  },
  "application/x-mspublisher": {
    source: "apache",
    extensions: ["pub"]
  },
  "application/x-msschedule": {
    source: "apache",
    extensions: ["scd"]
  },
  "application/x-msterminal": {
    source: "apache",
    extensions: ["trm"]
  },
  "application/x-mswrite": {
    source: "apache",
    extensions: ["wri"]
  },
  "application/x-netcdf": {
    source: "apache",
    extensions: ["nc", "cdf"]
  },
  "application/x-ns-proxy-autoconfig": {
    compressible: true,
    extensions: ["pac"]
  },
  "application/x-nzb": {
    source: "apache",
    extensions: ["nzb"]
  },
  "application/x-perl": {
    source: "nginx",
    extensions: ["pl", "pm"]
  },
  "application/x-pilot": {
    source: "nginx",
    extensions: ["prc", "pdb"]
  },
  "application/x-pkcs12": {
    source: "apache",
    compressible: false,
    extensions: ["p12", "pfx"]
  },
  "application/x-pkcs7-certificates": {
    source: "apache",
    extensions: ["p7b", "spc"]
  },
  "application/x-pkcs7-certreqresp": {
    source: "apache",
    extensions: ["p7r"]
  },
  "application/x-pki-message": {
    source: "iana"
  },
  "application/x-rar-compressed": {
    source: "apache",
    compressible: false,
    extensions: ["rar"]
  },
  "application/x-redhat-package-manager": {
    source: "nginx",
    extensions: ["rpm"]
  },
  "application/x-research-info-systems": {
    source: "apache",
    extensions: ["ris"]
  },
  "application/x-sea": {
    source: "nginx",
    extensions: ["sea"]
  },
  "application/x-sh": {
    source: "apache",
    compressible: true,
    extensions: ["sh"]
  },
  "application/x-shar": {
    source: "apache",
    extensions: ["shar"]
  },
  "application/x-shockwave-flash": {
    source: "apache",
    compressible: false,
    extensions: ["swf"]
  },
  "application/x-silverlight-app": {
    source: "apache",
    extensions: ["xap"]
  },
  "application/x-sql": {
    source: "apache",
    extensions: ["sql"]
  },
  "application/x-stuffit": {
    source: "apache",
    compressible: false,
    extensions: ["sit"]
  },
  "application/x-stuffitx": {
    source: "apache",
    extensions: ["sitx"]
  },
  "application/x-subrip": {
    source: "apache",
    extensions: ["srt"]
  },
  "application/x-sv4cpio": {
    source: "apache",
    extensions: ["sv4cpio"]
  },
  "application/x-sv4crc": {
    source: "apache",
    extensions: ["sv4crc"]
  },
  "application/x-t3vm-image": {
    source: "apache",
    extensions: ["t3"]
  },
  "application/x-tads": {
    source: "apache",
    extensions: ["gam"]
  },
  "application/x-tar": {
    source: "apache",
    compressible: true,
    extensions: ["tar"]
  },
  "application/x-tcl": {
    source: "apache",
    extensions: ["tcl", "tk"]
  },
  "application/x-tex": {
    source: "apache",
    extensions: ["tex"]
  },
  "application/x-tex-tfm": {
    source: "apache",
    extensions: ["tfm"]
  },
  "application/x-texinfo": {
    source: "apache",
    extensions: ["texinfo", "texi"]
  },
  "application/x-tgif": {
    source: "apache",
    extensions: ["obj"]
  },
  "application/x-ustar": {
    source: "apache",
    extensions: ["ustar"]
  },
  "application/x-virtualbox-hdd": {
    compressible: true,
    extensions: ["hdd"]
  },
  "application/x-virtualbox-ova": {
    compressible: true,
    extensions: ["ova"]
  },
  "application/x-virtualbox-ovf": {
    compressible: true,
    extensions: ["ovf"]
  },
  "application/x-virtualbox-vbox": {
    compressible: true,
    extensions: ["vbox"]
  },
  "application/x-virtualbox-vbox-extpack": {
    compressible: false,
    extensions: ["vbox-extpack"]
  },
  "application/x-virtualbox-vdi": {
    compressible: true,
    extensions: ["vdi"]
  },
  "application/x-virtualbox-vhd": {
    compressible: true,
    extensions: ["vhd"]
  },
  "application/x-virtualbox-vmdk": {
    compressible: true,
    extensions: ["vmdk"]
  },
  "application/x-wais-source": {
    source: "apache",
    extensions: ["src"]
  },
  "application/x-web-app-manifest+json": {
    compressible: true,
    extensions: ["webapp"]
  },
  "application/x-www-form-urlencoded": {
    source: "iana",
    compressible: true
  },
  "application/x-x509-ca-cert": {
    source: "iana",
    extensions: ["der", "crt", "pem"]
  },
  "application/x-x509-ca-ra-cert": {
    source: "iana"
  },
  "application/x-x509-next-ca-cert": {
    source: "iana"
  },
  "application/x-xfig": {
    source: "apache",
    extensions: ["fig"]
  },
  "application/x-xliff+xml": {
    source: "apache",
    compressible: true,
    extensions: ["xlf"]
  },
  "application/x-xpinstall": {
    source: "apache",
    compressible: false,
    extensions: ["xpi"]
  },
  "application/x-xz": {
    source: "apache",
    extensions: ["xz"]
  },
  "application/x-zmachine": {
    source: "apache",
    extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
  },
  "application/x400-bp": {
    source: "iana"
  },
  "application/xacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/xaml+xml": {
    source: "apache",
    compressible: true,
    extensions: ["xaml"]
  },
  "application/xcap-att+xml": {
    source: "iana",
    compressible: true,
    extensions: ["xav"]
  },
  "application/xcap-caps+xml": {
    source: "iana",
    compressible: true,
    extensions: ["xca"]
  },
  "application/xcap-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: ["xdf"]
  },
  "application/xcap-el+xml": {
    source: "iana",
    compressible: true,
    extensions: ["xel"]
  },
  "application/xcap-error+xml": {
    source: "iana",
    compressible: true,
    extensions: ["xer"]
  },
  "application/xcap-ns+xml": {
    source: "iana",
    compressible: true,
    extensions: ["xns"]
  },
  "application/xcon-conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcon-conference-info-diff+xml": {
    source: "iana",
    compressible: true
  },
  "application/xenc+xml": {
    source: "iana",
    compressible: true,
    extensions: ["xenc"]
  },
  "application/xhtml+xml": {
    source: "iana",
    compressible: true,
    extensions: ["xhtml", "xht"]
  },
  "application/xhtml-voice+xml": {
    source: "apache",
    compressible: true
  },
  "application/xliff+xml": {
    source: "iana",
    compressible: true,
    extensions: ["xlf"]
  },
  "application/xml": {
    source: "iana",
    compressible: true,
    extensions: ["xml", "xsl", "xsd", "rng"]
  },
  "application/xml-dtd": {
    source: "iana",
    compressible: true,
    extensions: ["dtd"]
  },
  "application/xml-external-parsed-entity": {
    source: "iana"
  },
  "application/xml-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/xmpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/xop+xml": {
    source: "iana",
    compressible: true,
    extensions: ["xop"]
  },
  "application/xproc+xml": {
    source: "apache",
    compressible: true,
    extensions: ["xpl"]
  },
  "application/xslt+xml": {
    source: "iana",
    compressible: true,
    extensions: ["xsl", "xslt"]
  },
  "application/xspf+xml": {
    source: "apache",
    compressible: true,
    extensions: ["xspf"]
  },
  "application/xv+xml": {
    source: "iana",
    compressible: true,
    extensions: ["mxml", "xhvml", "xvml", "xvm"]
  },
  "application/yang": {
    source: "iana",
    extensions: ["yang"]
  },
  "application/yang-data+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-data+xml": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/yin+xml": {
    source: "iana",
    compressible: true,
    extensions: ["yin"]
  },
  "application/zip": {
    source: "iana",
    compressible: false,
    extensions: ["zip"]
  },
  "application/zlib": {
    source: "iana"
  },
  "application/zstd": {
    source: "iana"
  },
  "audio/1d-interleaved-parityfec": {
    source: "iana"
  },
  "audio/32kadpcm": {
    source: "iana"
  },
  "audio/3gpp": {
    source: "iana",
    compressible: false,
    extensions: ["3gpp"]
  },
  "audio/3gpp2": {
    source: "iana"
  },
  "audio/aac": {
    source: "iana"
  },
  "audio/ac3": {
    source: "iana"
  },
  "audio/adpcm": {
    source: "apache",
    extensions: ["adp"]
  },
  "audio/amr": {
    source: "iana",
    extensions: ["amr"]
  },
  "audio/amr-wb": {
    source: "iana"
  },
  "audio/amr-wb+": {
    source: "iana"
  },
  "audio/aptx": {
    source: "iana"
  },
  "audio/asc": {
    source: "iana"
  },
  "audio/atrac-advanced-lossless": {
    source: "iana"
  },
  "audio/atrac-x": {
    source: "iana"
  },
  "audio/atrac3": {
    source: "iana"
  },
  "audio/basic": {
    source: "iana",
    compressible: false,
    extensions: ["au", "snd"]
  },
  "audio/bv16": {
    source: "iana"
  },
  "audio/bv32": {
    source: "iana"
  },
  "audio/clearmode": {
    source: "iana"
  },
  "audio/cn": {
    source: "iana"
  },
  "audio/dat12": {
    source: "iana"
  },
  "audio/dls": {
    source: "iana"
  },
  "audio/dsr-es201108": {
    source: "iana"
  },
  "audio/dsr-es202050": {
    source: "iana"
  },
  "audio/dsr-es202211": {
    source: "iana"
  },
  "audio/dsr-es202212": {
    source: "iana"
  },
  "audio/dv": {
    source: "iana"
  },
  "audio/dvi4": {
    source: "iana"
  },
  "audio/eac3": {
    source: "iana"
  },
  "audio/encaprtp": {
    source: "iana"
  },
  "audio/evrc": {
    source: "iana"
  },
  "audio/evrc-qcp": {
    source: "iana"
  },
  "audio/evrc0": {
    source: "iana"
  },
  "audio/evrc1": {
    source: "iana"
  },
  "audio/evrcb": {
    source: "iana"
  },
  "audio/evrcb0": {
    source: "iana"
  },
  "audio/evrcb1": {
    source: "iana"
  },
  "audio/evrcnw": {
    source: "iana"
  },
  "audio/evrcnw0": {
    source: "iana"
  },
  "audio/evrcnw1": {
    source: "iana"
  },
  "audio/evrcwb": {
    source: "iana"
  },
  "audio/evrcwb0": {
    source: "iana"
  },
  "audio/evrcwb1": {
    source: "iana"
  },
  "audio/evs": {
    source: "iana"
  },
  "audio/flexfec": {
    source: "iana"
  },
  "audio/fwdred": {
    source: "iana"
  },
  "audio/g711-0": {
    source: "iana"
  },
  "audio/g719": {
    source: "iana"
  },
  "audio/g722": {
    source: "iana"
  },
  "audio/g7221": {
    source: "iana"
  },
  "audio/g723": {
    source: "iana"
  },
  "audio/g726-16": {
    source: "iana"
  },
  "audio/g726-24": {
    source: "iana"
  },
  "audio/g726-32": {
    source: "iana"
  },
  "audio/g726-40": {
    source: "iana"
  },
  "audio/g728": {
    source: "iana"
  },
  "audio/g729": {
    source: "iana"
  },
  "audio/g7291": {
    source: "iana"
  },
  "audio/g729d": {
    source: "iana"
  },
  "audio/g729e": {
    source: "iana"
  },
  "audio/gsm": {
    source: "iana"
  },
  "audio/gsm-efr": {
    source: "iana"
  },
  "audio/gsm-hr-08": {
    source: "iana"
  },
  "audio/ilbc": {
    source: "iana"
  },
  "audio/ip-mr_v2.5": {
    source: "iana"
  },
  "audio/isac": {
    source: "apache"
  },
  "audio/l16": {
    source: "iana"
  },
  "audio/l20": {
    source: "iana"
  },
  "audio/l24": {
    source: "iana",
    compressible: false
  },
  "audio/l8": {
    source: "iana"
  },
  "audio/lpc": {
    source: "iana"
  },
  "audio/melp": {
    source: "iana"
  },
  "audio/melp1200": {
    source: "iana"
  },
  "audio/melp2400": {
    source: "iana"
  },
  "audio/melp600": {
    source: "iana"
  },
  "audio/mhas": {
    source: "iana"
  },
  "audio/midi": {
    source: "apache",
    extensions: ["mid", "midi", "kar", "rmi"]
  },
  "audio/mobile-xmf": {
    source: "iana",
    extensions: ["mxmf"]
  },
  "audio/mp3": {
    compressible: false,
    extensions: ["mp3"]
  },
  "audio/mp4": {
    source: "iana",
    compressible: false,
    extensions: ["m4a", "mp4a"]
  },
  "audio/mp4a-latm": {
    source: "iana"
  },
  "audio/mpa": {
    source: "iana"
  },
  "audio/mpa-robust": {
    source: "iana"
  },
  "audio/mpeg": {
    source: "iana",
    compressible: false,
    extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
  },
  "audio/mpeg4-generic": {
    source: "iana"
  },
  "audio/musepack": {
    source: "apache"
  },
  "audio/ogg": {
    source: "iana",
    compressible: false,
    extensions: ["oga", "ogg", "spx", "opus"]
  },
  "audio/opus": {
    source: "iana"
  },
  "audio/parityfec": {
    source: "iana"
  },
  "audio/pcma": {
    source: "iana"
  },
  "audio/pcma-wb": {
    source: "iana"
  },
  "audio/pcmu": {
    source: "iana"
  },
  "audio/pcmu-wb": {
    source: "iana"
  },
  "audio/prs.sid": {
    source: "iana"
  },
  "audio/qcelp": {
    source: "iana"
  },
  "audio/raptorfec": {
    source: "iana"
  },
  "audio/red": {
    source: "iana"
  },
  "audio/rtp-enc-aescm128": {
    source: "iana"
  },
  "audio/rtp-midi": {
    source: "iana"
  },
  "audio/rtploopback": {
    source: "iana"
  },
  "audio/rtx": {
    source: "iana"
  },
  "audio/s3m": {
    source: "apache",
    extensions: ["s3m"]
  },
  "audio/scip": {
    source: "iana"
  },
  "audio/silk": {
    source: "apache",
    extensions: ["sil"]
  },
  "audio/smv": {
    source: "iana"
  },
  "audio/smv-qcp": {
    source: "iana"
  },
  "audio/smv0": {
    source: "iana"
  },
  "audio/sofa": {
    source: "iana"
  },
  "audio/sp-midi": {
    source: "iana"
  },
  "audio/speex": {
    source: "iana"
  },
  "audio/t140c": {
    source: "iana"
  },
  "audio/t38": {
    source: "iana"
  },
  "audio/telephone-event": {
    source: "iana"
  },
  "audio/tetra_acelp": {
    source: "iana"
  },
  "audio/tetra_acelp_bb": {
    source: "iana"
  },
  "audio/tone": {
    source: "iana"
  },
  "audio/tsvcis": {
    source: "iana"
  },
  "audio/uemclip": {
    source: "iana"
  },
  "audio/ulpfec": {
    source: "iana"
  },
  "audio/usac": {
    source: "iana"
  },
  "audio/vdvi": {
    source: "iana"
  },
  "audio/vmr-wb": {
    source: "iana"
  },
  "audio/vnd.3gpp.iufp": {
    source: "iana"
  },
  "audio/vnd.4sb": {
    source: "iana"
  },
  "audio/vnd.audiokoz": {
    source: "iana"
  },
  "audio/vnd.celp": {
    source: "iana"
  },
  "audio/vnd.cisco.nse": {
    source: "iana"
  },
  "audio/vnd.cmles.radio-events": {
    source: "iana"
  },
  "audio/vnd.cns.anp1": {
    source: "iana"
  },
  "audio/vnd.cns.inf1": {
    source: "iana"
  },
  "audio/vnd.dece.audio": {
    source: "iana",
    extensions: ["uva", "uvva"]
  },
  "audio/vnd.digital-winds": {
    source: "iana",
    extensions: ["eol"]
  },
  "audio/vnd.dlna.adts": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    source: "iana"
  },
  "audio/vnd.dolby.mlp": {
    source: "iana"
  },
  "audio/vnd.dolby.mps": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2x": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2z": {
    source: "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    source: "iana"
  },
  "audio/vnd.dra": {
    source: "iana",
    extensions: ["dra"]
  },
  "audio/vnd.dts": {
    source: "iana",
    extensions: ["dts"]
  },
  "audio/vnd.dts.hd": {
    source: "iana",
    extensions: ["dtshd"]
  },
  "audio/vnd.dts.uhd": {
    source: "iana"
  },
  "audio/vnd.dvb.file": {
    source: "iana"
  },
  "audio/vnd.everad.plj": {
    source: "iana"
  },
  "audio/vnd.hns.audio": {
    source: "iana"
  },
  "audio/vnd.lucent.voice": {
    source: "iana",
    extensions: ["lvp"]
  },
  "audio/vnd.ms-playready.media.pya": {
    source: "iana",
    extensions: ["pya"]
  },
  "audio/vnd.nokia.mobile-xmf": {
    source: "iana"
  },
  "audio/vnd.nortel.vbk": {
    source: "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    source: "iana",
    extensions: ["ecelp4800"]
  },
  "audio/vnd.nuera.ecelp7470": {
    source: "iana",
    extensions: ["ecelp7470"]
  },
  "audio/vnd.nuera.ecelp9600": {
    source: "iana",
    extensions: ["ecelp9600"]
  },
  "audio/vnd.octel.sbc": {
    source: "iana"
  },
  "audio/vnd.presonus.multitrack": {
    source: "iana"
  },
  "audio/vnd.qcelp": {
    source: "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    source: "iana"
  },
  "audio/vnd.rip": {
    source: "iana",
    extensions: ["rip"]
  },
  "audio/vnd.rn-realaudio": {
    compressible: false
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    source: "iana"
  },
  "audio/vnd.vmx.cvsd": {
    source: "iana"
  },
  "audio/vnd.wave": {
    compressible: false
  },
  "audio/vorbis": {
    source: "iana",
    compressible: false
  },
  "audio/vorbis-config": {
    source: "iana"
  },
  "audio/wav": {
    compressible: false,
    extensions: ["wav"]
  },
  "audio/wave": {
    compressible: false,
    extensions: ["wav"]
  },
  "audio/webm": {
    source: "apache",
    compressible: false,
    extensions: ["weba"]
  },
  "audio/x-aac": {
    source: "apache",
    compressible: false,
    extensions: ["aac"]
  },
  "audio/x-aiff": {
    source: "apache",
    extensions: ["aif", "aiff", "aifc"]
  },
  "audio/x-caf": {
    source: "apache",
    compressible: false,
    extensions: ["caf"]
  },
  "audio/x-flac": {
    source: "apache",
    extensions: ["flac"]
  },
  "audio/x-m4a": {
    source: "nginx",
    extensions: ["m4a"]
  },
  "audio/x-matroska": {
    source: "apache",
    extensions: ["mka"]
  },
  "audio/x-mpegurl": {
    source: "apache",
    extensions: ["m3u"]
  },
  "audio/x-ms-wax": {
    source: "apache",
    extensions: ["wax"]
  },
  "audio/x-ms-wma": {
    source: "apache",
    extensions: ["wma"]
  },
  "audio/x-pn-realaudio": {
    source: "apache",
    extensions: ["ram", "ra"]
  },
  "audio/x-pn-realaudio-plugin": {
    source: "apache",
    extensions: ["rmp"]
  },
  "audio/x-realaudio": {
    source: "nginx",
    extensions: ["ra"]
  },
  "audio/x-tta": {
    source: "apache"
  },
  "audio/x-wav": {
    source: "apache",
    extensions: ["wav"]
  },
  "audio/xm": {
    source: "apache",
    extensions: ["xm"]
  },
  "chemical/x-cdx": {
    source: "apache",
    extensions: ["cdx"]
  },
  "chemical/x-cif": {
    source: "apache",
    extensions: ["cif"]
  },
  "chemical/x-cmdf": {
    source: "apache",
    extensions: ["cmdf"]
  },
  "chemical/x-cml": {
    source: "apache",
    extensions: ["cml"]
  },
  "chemical/x-csml": {
    source: "apache",
    extensions: ["csml"]
  },
  "chemical/x-pdb": {
    source: "apache"
  },
  "chemical/x-xyz": {
    source: "apache",
    extensions: ["xyz"]
  },
  "font/collection": {
    source: "iana",
    extensions: ["ttc"]
  },
  "font/otf": {
    source: "iana",
    compressible: true,
    extensions: ["otf"]
  },
  "font/sfnt": {
    source: "iana"
  },
  "font/ttf": {
    source: "iana",
    compressible: true,
    extensions: ["ttf"]
  },
  "font/woff": {
    source: "iana",
    extensions: ["woff"]
  },
  "font/woff2": {
    source: "iana",
    extensions: ["woff2"]
  },
  "image/aces": {
    source: "iana",
    extensions: ["exr"]
  },
  "image/apng": {
    compressible: false,
    extensions: ["apng"]
  },
  "image/avci": {
    source: "iana"
  },
  "image/avcs": {
    source: "iana"
  },
  "image/avif": {
    source: "iana",
    compressible: false,
    extensions: ["avif"]
  },
  "image/bmp": {
    source: "iana",
    compressible: true,
    extensions: ["bmp"]
  },
  "image/cgm": {
    source: "iana",
    extensions: ["cgm"]
  },
  "image/dicom-rle": {
    source: "iana",
    extensions: ["drle"]
  },
  "image/emf": {
    source: "iana",
    extensions: ["emf"]
  },
  "image/fits": {
    source: "iana",
    extensions: ["fits"]
  },
  "image/g3fax": {
    source: "iana",
    extensions: ["g3"]
  },
  "image/gif": {
    source: "iana",
    compressible: false,
    extensions: ["gif"]
  },
  "image/heic": {
    source: "iana",
    extensions: ["heic"]
  },
  "image/heic-sequence": {
    source: "iana",
    extensions: ["heics"]
  },
  "image/heif": {
    source: "iana",
    extensions: ["heif"]
  },
  "image/heif-sequence": {
    source: "iana",
    extensions: ["heifs"]
  },
  "image/hej2k": {
    source: "iana",
    extensions: ["hej2"]
  },
  "image/hsj2": {
    source: "iana",
    extensions: ["hsj2"]
  },
  "image/ief": {
    source: "iana",
    extensions: ["ief"]
  },
  "image/jls": {
    source: "iana",
    extensions: ["jls"]
  },
  "image/jp2": {
    source: "iana",
    compressible: false,
    extensions: ["jp2", "jpg2"]
  },
  "image/jpeg": {
    source: "iana",
    compressible: false,
    extensions: ["jpeg", "jpg", "jpe"]
  },
  "image/jph": {
    source: "iana",
    extensions: ["jph"]
  },
  "image/jphc": {
    source: "iana",
    extensions: ["jhc"]
  },
  "image/jpm": {
    source: "iana",
    compressible: false,
    extensions: ["jpm"]
  },
  "image/jpx": {
    source: "iana",
    compressible: false,
    extensions: ["jpx", "jpf"]
  },
  "image/jxr": {
    source: "iana",
    extensions: ["jxr"]
  },
  "image/jxra": {
    source: "iana",
    extensions: ["jxra"]
  },
  "image/jxrs": {
    source: "iana",
    extensions: ["jxrs"]
  },
  "image/jxs": {
    source: "iana",
    extensions: ["jxs"]
  },
  "image/jxsc": {
    source: "iana",
    extensions: ["jxsc"]
  },
  "image/jxsi": {
    source: "iana",
    extensions: ["jxsi"]
  },
  "image/jxss": {
    source: "iana",
    extensions: ["jxss"]
  },
  "image/ktx": {
    source: "iana",
    extensions: ["ktx"]
  },
  "image/ktx2": {
    source: "iana",
    extensions: ["ktx2"]
  },
  "image/naplps": {
    source: "iana"
  },
  "image/pjpeg": {
    compressible: false
  },
  "image/png": {
    source: "iana",
    compressible: false,
    extensions: ["png"]
  },
  "image/prs.btif": {
    source: "iana",
    extensions: ["btif"]
  },
  "image/prs.pti": {
    source: "iana",
    extensions: ["pti"]
  },
  "image/pwg-raster": {
    source: "iana"
  },
  "image/sgi": {
    source: "apache",
    extensions: ["sgi"]
  },
  "image/svg+xml": {
    source: "iana",
    compressible: true,
    extensions: ["svg", "svgz"]
  },
  "image/t38": {
    source: "iana",
    extensions: ["t38"]
  },
  "image/tiff": {
    source: "iana",
    compressible: false,
    extensions: ["tif", "tiff"]
  },
  "image/tiff-fx": {
    source: "iana",
    extensions: ["tfx"]
  },
  "image/vnd.adobe.photoshop": {
    source: "iana",
    compressible: true,
    extensions: ["psd"]
  },
  "image/vnd.airzip.accelerator.azv": {
    source: "iana",
    extensions: ["azv"]
  },
  "image/vnd.cns.inf2": {
    source: "iana"
  },
  "image/vnd.dece.graphic": {
    source: "iana",
    extensions: ["uvi", "uvvi", "uvg", "uvvg"]
  },
  "image/vnd.djvu": {
    source: "iana",
    extensions: ["djvu", "djv"]
  },
  "image/vnd.dvb.subtitle": {
    source: "iana",
    extensions: ["sub"]
  },
  "image/vnd.dwg": {
    source: "iana",
    extensions: ["dwg"]
  },
  "image/vnd.dxf": {
    source: "iana",
    extensions: ["dxf"]
  },
  "image/vnd.fastbidsheet": {
    source: "iana",
    extensions: ["fbs"]
  },
  "image/vnd.fpx": {
    source: "iana",
    extensions: ["fpx"]
  },
  "image/vnd.fst": {
    source: "iana",
    extensions: ["fst"]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    source: "iana",
    extensions: ["mmr"]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    source: "iana",
    extensions: ["rlc"]
  },
  "image/vnd.globalgraphics.pgb": {
    source: "iana"
  },
  "image/vnd.microsoft.icon": {
    source: "iana",
    extensions: ["ico"]
  },
  "image/vnd.mix": {
    source: "iana"
  },
  "image/vnd.mozilla.apng": {
    source: "iana"
  },
  "image/vnd.ms-dds": {
    extensions: ["dds"]
  },
  "image/vnd.ms-modi": {
    source: "iana",
    extensions: ["mdi"]
  },
  "image/vnd.ms-photo": {
    source: "apache",
    extensions: ["wdp"]
  },
  "image/vnd.net-fpx": {
    source: "iana",
    extensions: ["npx"]
  },
  "image/vnd.pco.b16": {
    source: "iana",
    extensions: ["b16"]
  },
  "image/vnd.radiance": {
    source: "iana"
  },
  "image/vnd.sealed.png": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    source: "iana"
  },
  "image/vnd.svf": {
    source: "iana"
  },
  "image/vnd.tencent.tap": {
    source: "iana",
    extensions: ["tap"]
  },
  "image/vnd.valve.source.texture": {
    source: "iana",
    extensions: ["vtf"]
  },
  "image/vnd.wap.wbmp": {
    source: "iana",
    extensions: ["wbmp"]
  },
  "image/vnd.xiff": {
    source: "iana",
    extensions: ["xif"]
  },
  "image/vnd.zbrush.pcx": {
    source: "iana",
    extensions: ["pcx"]
  },
  "image/webp": {
    source: "apache",
    extensions: ["webp"]
  },
  "image/wmf": {
    source: "iana",
    extensions: ["wmf"]
  },
  "image/x-3ds": {
    source: "apache",
    extensions: ["3ds"]
  },
  "image/x-cmu-raster": {
    source: "apache",
    extensions: ["ras"]
  },
  "image/x-cmx": {
    source: "apache",
    extensions: ["cmx"]
  },
  "image/x-freehand": {
    source: "apache",
    extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
  },
  "image/x-icon": {
    source: "apache",
    compressible: true,
    extensions: ["ico"]
  },
  "image/x-jng": {
    source: "nginx",
    extensions: ["jng"]
  },
  "image/x-mrsid-image": {
    source: "apache",
    extensions: ["sid"]
  },
  "image/x-ms-bmp": {
    source: "nginx",
    compressible: true,
    extensions: ["bmp"]
  },
  "image/x-pcx": {
    source: "apache",
    extensions: ["pcx"]
  },
  "image/x-pict": {
    source: "apache",
    extensions: ["pic", "pct"]
  },
  "image/x-portable-anymap": {
    source: "apache",
    extensions: ["pnm"]
  },
  "image/x-portable-bitmap": {
    source: "apache",
    extensions: ["pbm"]
  },
  "image/x-portable-graymap": {
    source: "apache",
    extensions: ["pgm"]
  },
  "image/x-portable-pixmap": {
    source: "apache",
    extensions: ["ppm"]
  },
  "image/x-rgb": {
    source: "apache",
    extensions: ["rgb"]
  },
  "image/x-tga": {
    source: "apache",
    extensions: ["tga"]
  },
  "image/x-xbitmap": {
    source: "apache",
    extensions: ["xbm"]
  },
  "image/x-xcf": {
    compressible: false
  },
  "image/x-xpixmap": {
    source: "apache",
    extensions: ["xpm"]
  },
  "image/x-xwindowdump": {
    source: "apache",
    extensions: ["xwd"]
  },
  "message/cpim": {
    source: "iana"
  },
  "message/delivery-status": {
    source: "iana"
  },
  "message/disposition-notification": {
    source: "iana",
    extensions: ["disposition-notification"]
  },
  "message/external-body": {
    source: "iana"
  },
  "message/feedback-report": {
    source: "iana"
  },
  "message/global": {
    source: "iana",
    extensions: ["u8msg"]
  },
  "message/global-delivery-status": {
    source: "iana",
    extensions: ["u8dsn"]
  },
  "message/global-disposition-notification": {
    source: "iana",
    extensions: ["u8mdn"]
  },
  "message/global-headers": {
    source: "iana",
    extensions: ["u8hdr"]
  },
  "message/http": {
    source: "iana",
    compressible: false
  },
  "message/imdn+xml": {
    source: "iana",
    compressible: true
  },
  "message/news": {
    source: "iana"
  },
  "message/partial": {
    source: "iana",
    compressible: false
  },
  "message/rfc822": {
    source: "iana",
    compressible: true,
    extensions: ["eml", "mime"]
  },
  "message/s-http": {
    source: "iana"
  },
  "message/sip": {
    source: "iana"
  },
  "message/sipfrag": {
    source: "iana"
  },
  "message/tracking-status": {
    source: "iana"
  },
  "message/vnd.si.simp": {
    source: "iana"
  },
  "message/vnd.wfa.wsc": {
    source: "iana",
    extensions: ["wsc"]
  },
  "model/3mf": {
    source: "iana",
    extensions: ["3mf"]
  },
  "model/e57": {
    source: "iana"
  },
  "model/gltf+json": {
    source: "iana",
    compressible: true,
    extensions: ["gltf"]
  },
  "model/gltf-binary": {
    source: "iana",
    compressible: true,
    extensions: ["glb"]
  },
  "model/iges": {
    source: "iana",
    compressible: false,
    extensions: ["igs", "iges"]
  },
  "model/mesh": {
    source: "iana",
    compressible: false,
    extensions: ["msh", "mesh", "silo"]
  },
  "model/mtl": {
    source: "iana",
    extensions: ["mtl"]
  },
  "model/obj": {
    source: "iana",
    extensions: ["obj"]
  },
  "model/stl": {
    source: "iana",
    extensions: ["stl"]
  },
  "model/vnd.collada+xml": {
    source: "iana",
    compressible: true,
    extensions: ["dae"]
  },
  "model/vnd.dwf": {
    source: "iana",
    extensions: ["dwf"]
  },
  "model/vnd.flatland.3dml": {
    source: "iana"
  },
  "model/vnd.gdl": {
    source: "iana",
    extensions: ["gdl"]
  },
  "model/vnd.gs-gdl": {
    source: "apache"
  },
  "model/vnd.gs.gdl": {
    source: "iana"
  },
  "model/vnd.gtw": {
    source: "iana",
    extensions: ["gtw"]
  },
  "model/vnd.moml+xml": {
    source: "iana",
    compressible: true
  },
  "model/vnd.mts": {
    source: "iana",
    extensions: ["mts"]
  },
  "model/vnd.opengex": {
    source: "iana",
    extensions: ["ogex"]
  },
  "model/vnd.parasolid.transmit.binary": {
    source: "iana",
    extensions: ["x_b"]
  },
  "model/vnd.parasolid.transmit.text": {
    source: "iana",
    extensions: ["x_t"]
  },
  "model/vnd.rosette.annotated-data-model": {
    source: "iana"
  },
  "model/vnd.usdz+zip": {
    source: "iana",
    compressible: false,
    extensions: ["usdz"]
  },
  "model/vnd.valve.source.compiled-map": {
    source: "iana",
    extensions: ["bsp"]
  },
  "model/vnd.vtu": {
    source: "iana",
    extensions: ["vtu"]
  },
  "model/vrml": {
    source: "iana",
    compressible: false,
    extensions: ["wrl", "vrml"]
  },
  "model/x3d+binary": {
    source: "apache",
    compressible: false,
    extensions: ["x3db", "x3dbz"]
  },
  "model/x3d+fastinfoset": {
    source: "iana",
    extensions: ["x3db"]
  },
  "model/x3d+vrml": {
    source: "apache",
    compressible: false,
    extensions: ["x3dv", "x3dvz"]
  },
  "model/x3d+xml": {
    source: "iana",
    compressible: true,
    extensions: ["x3d", "x3dz"]
  },
  "model/x3d-vrml": {
    source: "iana",
    extensions: ["x3dv"]
  },
  "multipart/alternative": {
    source: "iana",
    compressible: false
  },
  "multipart/appledouble": {
    source: "iana"
  },
  "multipart/byteranges": {
    source: "iana"
  },
  "multipart/digest": {
    source: "iana"
  },
  "multipart/encrypted": {
    source: "iana",
    compressible: false
  },
  "multipart/form-data": {
    source: "iana",
    compressible: false
  },
  "multipart/header-set": {
    source: "iana"
  },
  "multipart/mixed": {
    source: "iana"
  },
  "multipart/multilingual": {
    source: "iana"
  },
  "multipart/parallel": {
    source: "iana"
  },
  "multipart/related": {
    source: "iana",
    compressible: false
  },
  "multipart/report": {
    source: "iana"
  },
  "multipart/signed": {
    source: "iana",
    compressible: false
  },
  "multipart/vnd.bint.med-plus": {
    source: "iana"
  },
  "multipart/voice-message": {
    source: "iana"
  },
  "multipart/x-mixed-replace": {
    source: "iana"
  },
  "text/1d-interleaved-parityfec": {
    source: "iana"
  },
  "text/cache-manifest": {
    source: "iana",
    compressible: true,
    extensions: ["appcache", "manifest"]
  },
  "text/calendar": {
    source: "iana",
    extensions: ["ics", "ifb"]
  },
  "text/calender": {
    compressible: true
  },
  "text/cmd": {
    compressible: true
  },
  "text/coffeescript": {
    extensions: ["coffee", "litcoffee"]
  },
  "text/cql": {
    source: "iana"
  },
  "text/cql-expression": {
    source: "iana"
  },
  "text/cql-identifier": {
    source: "iana"
  },
  "text/css": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: ["css"]
  },
  "text/csv": {
    source: "iana",
    compressible: true,
    extensions: ["csv"]
  },
  "text/csv-schema": {
    source: "iana"
  },
  "text/directory": {
    source: "iana"
  },
  "text/dns": {
    source: "iana"
  },
  "text/ecmascript": {
    source: "iana"
  },
  "text/encaprtp": {
    source: "iana"
  },
  "text/enriched": {
    source: "iana"
  },
  "text/fhirpath": {
    source: "iana"
  },
  "text/flexfec": {
    source: "iana"
  },
  "text/fwdred": {
    source: "iana"
  },
  "text/gff3": {
    source: "iana"
  },
  "text/grammar-ref-list": {
    source: "iana"
  },
  "text/html": {
    source: "iana",
    compressible: true,
    extensions: ["html", "htm", "shtml"]
  },
  "text/jade": {
    extensions: ["jade"]
  },
  "text/javascript": {
    source: "iana",
    compressible: true
  },
  "text/jcr-cnd": {
    source: "iana"
  },
  "text/jsx": {
    compressible: true,
    extensions: ["jsx"]
  },
  "text/less": {
    compressible: true,
    extensions: ["less"]
  },
  "text/markdown": {
    source: "iana",
    compressible: true,
    extensions: ["markdown", "md"]
  },
  "text/mathml": {
    source: "nginx",
    extensions: ["mml"]
  },
  "text/mdx": {
    compressible: true,
    extensions: ["mdx"]
  },
  "text/mizar": {
    source: "iana"
  },
  "text/n3": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: ["n3"]
  },
  "text/parameters": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/parityfec": {
    source: "iana"
  },
  "text/plain": {
    source: "iana",
    compressible: true,
    extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
  },
  "text/provenance-notation": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/prs.fallenstein.rst": {
    source: "iana"
  },
  "text/prs.lines.tag": {
    source: "iana",
    extensions: ["dsc"]
  },
  "text/prs.prop.logic": {
    source: "iana"
  },
  "text/raptorfec": {
    source: "iana"
  },
  "text/red": {
    source: "iana"
  },
  "text/rfc822-headers": {
    source: "iana"
  },
  "text/richtext": {
    source: "iana",
    compressible: true,
    extensions: ["rtx"]
  },
  "text/rtf": {
    source: "iana",
    compressible: true,
    extensions: ["rtf"]
  },
  "text/rtp-enc-aescm128": {
    source: "iana"
  },
  "text/rtploopback": {
    source: "iana"
  },
  "text/rtx": {
    source: "iana"
  },
  "text/sgml": {
    source: "iana",
    extensions: ["sgml", "sgm"]
  },
  "text/shaclc": {
    source: "iana"
  },
  "text/shex": {
    extensions: ["shex"]
  },
  "text/slim": {
    extensions: ["slim", "slm"]
  },
  "text/spdx": {
    source: "iana",
    extensions: ["spdx"]
  },
  "text/strings": {
    source: "iana"
  },
  "text/stylus": {
    extensions: ["stylus", "styl"]
  },
  "text/t140": {
    source: "iana"
  },
  "text/tab-separated-values": {
    source: "iana",
    compressible: true,
    extensions: ["tsv"]
  },
  "text/troff": {
    source: "iana",
    extensions: ["t", "tr", "roff", "man", "me", "ms"]
  },
  "text/turtle": {
    source: "iana",
    charset: "UTF-8",
    extensions: ["ttl"]
  },
  "text/ulpfec": {
    source: "iana"
  },
  "text/uri-list": {
    source: "iana",
    compressible: true,
    extensions: ["uri", "uris", "urls"]
  },
  "text/vcard": {
    source: "iana",
    compressible: true,
    extensions: ["vcard"]
  },
  "text/vnd.a": {
    source: "iana"
  },
  "text/vnd.abc": {
    source: "iana"
  },
  "text/vnd.ascii-art": {
    source: "iana"
  },
  "text/vnd.curl": {
    source: "iana",
    extensions: ["curl"]
  },
  "text/vnd.curl.dcurl": {
    source: "apache",
    extensions: ["dcurl"]
  },
  "text/vnd.curl.mcurl": {
    source: "apache",
    extensions: ["mcurl"]
  },
  "text/vnd.curl.scurl": {
    source: "apache",
    extensions: ["scurl"]
  },
  "text/vnd.debian.copyright": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.dmclientscript": {
    source: "iana"
  },
  "text/vnd.dvb.subtitle": {
    source: "iana",
    extensions: ["sub"]
  },
  "text/vnd.esmertec.theme-descriptor": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.ficlab.flt": {
    source: "iana"
  },
  "text/vnd.fly": {
    source: "iana",
    extensions: ["fly"]
  },
  "text/vnd.fmi.flexstor": {
    source: "iana",
    extensions: ["flx"]
  },
  "text/vnd.gml": {
    source: "iana"
  },
  "text/vnd.graphviz": {
    source: "iana",
    extensions: ["gv"]
  },
  "text/vnd.hans": {
    source: "iana"
  },
  "text/vnd.hgl": {
    source: "iana"
  },
  "text/vnd.in3d.3dml": {
    source: "iana",
    extensions: ["3dml"]
  },
  "text/vnd.in3d.spot": {
    source: "iana",
    extensions: ["spot"]
  },
  "text/vnd.iptc.newsml": {
    source: "iana"
  },
  "text/vnd.iptc.nitf": {
    source: "iana"
  },
  "text/vnd.latex-z": {
    source: "iana"
  },
  "text/vnd.motorola.reflex": {
    source: "iana"
  },
  "text/vnd.ms-mediapackage": {
    source: "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    source: "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    source: "iana"
  },
  "text/vnd.senx.warpscript": {
    source: "iana"
  },
  "text/vnd.si.uricatalogue": {
    source: "iana"
  },
  "text/vnd.sosi": {
    source: "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    source: "iana",
    charset: "UTF-8",
    extensions: ["jad"]
  },
  "text/vnd.trolltech.linguist": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.wap.si": {
    source: "iana"
  },
  "text/vnd.wap.sl": {
    source: "iana"
  },
  "text/vnd.wap.wml": {
    source: "iana",
    extensions: ["wml"]
  },
  "text/vnd.wap.wmlscript": {
    source: "iana",
    extensions: ["wmls"]
  },
  "text/vtt": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: ["vtt"]
  },
  "text/x-asm": {
    source: "apache",
    extensions: ["s", "asm"]
  },
  "text/x-c": {
    source: "apache",
    extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
  },
  "text/x-component": {
    source: "nginx",
    extensions: ["htc"]
  },
  "text/x-fortran": {
    source: "apache",
    extensions: ["f", "for", "f77", "f90"]
  },
  "text/x-gwt-rpc": {
    compressible: true
  },
  "text/x-handlebars-template": {
    extensions: ["hbs"]
  },
  "text/x-java-source": {
    source: "apache",
    extensions: ["java"]
  },
  "text/x-jquery-tmpl": {
    compressible: true
  },
  "text/x-lua": {
    extensions: ["lua"]
  },
  "text/x-markdown": {
    compressible: true,
    extensions: ["mkd"]
  },
  "text/x-nfo": {
    source: "apache",
    extensions: ["nfo"]
  },
  "text/x-opml": {
    source: "apache",
    extensions: ["opml"]
  },
  "text/x-org": {
    compressible: true,
    extensions: ["org"]
  },
  "text/x-pascal": {
    source: "apache",
    extensions: ["p", "pas"]
  },
  "text/x-processing": {
    compressible: true,
    extensions: ["pde"]
  },
  "text/x-sass": {
    extensions: ["sass"]
  },
  "text/x-scss": {
    extensions: ["scss"]
  },
  "text/x-setext": {
    source: "apache",
    extensions: ["etx"]
  },
  "text/x-sfv": {
    source: "apache",
    extensions: ["sfv"]
  },
  "text/x-suse-ymp": {
    compressible: true,
    extensions: ["ymp"]
  },
  "text/x-uuencode": {
    source: "apache",
    extensions: ["uu"]
  },
  "text/x-vcalendar": {
    source: "apache",
    extensions: ["vcs"]
  },
  "text/x-vcard": {
    source: "apache",
    extensions: ["vcf"]
  },
  "text/xml": {
    source: "iana",
    compressible: true,
    extensions: ["xml"]
  },
  "text/xml-external-parsed-entity": {
    source: "iana"
  },
  "text/yaml": {
    extensions: ["yaml", "yml"]
  },
  "video/1d-interleaved-parityfec": {
    source: "iana"
  },
  "video/3gpp": {
    source: "iana",
    extensions: ["3gp", "3gpp"]
  },
  "video/3gpp-tt": {
    source: "iana"
  },
  "video/3gpp2": {
    source: "iana",
    extensions: ["3g2"]
  },
  "video/av1": {
    source: "iana"
  },
  "video/bmpeg": {
    source: "iana"
  },
  "video/bt656": {
    source: "iana"
  },
  "video/celb": {
    source: "iana"
  },
  "video/dv": {
    source: "iana"
  },
  "video/encaprtp": {
    source: "iana"
  },
  "video/flexfec": {
    source: "iana"
  },
  "video/h261": {
    source: "iana",
    extensions: ["h261"]
  },
  "video/h263": {
    source: "iana",
    extensions: ["h263"]
  },
  "video/h263-1998": {
    source: "iana"
  },
  "video/h263-2000": {
    source: "iana"
  },
  "video/h264": {
    source: "iana",
    extensions: ["h264"]
  },
  "video/h264-rcdo": {
    source: "iana"
  },
  "video/h264-svc": {
    source: "iana"
  },
  "video/h265": {
    source: "iana"
  },
  "video/iso.segment": {
    source: "iana",
    extensions: ["m4s"]
  },
  "video/jpeg": {
    source: "iana",
    extensions: ["jpgv"]
  },
  "video/jpeg2000": {
    source: "iana"
  },
  "video/jpm": {
    source: "apache",
    extensions: ["jpm", "jpgm"]
  },
  "video/mj2": {
    source: "iana",
    extensions: ["mj2", "mjp2"]
  },
  "video/mp1s": {
    source: "iana"
  },
  "video/mp2p": {
    source: "iana"
  },
  "video/mp2t": {
    source: "iana",
    extensions: ["ts"]
  },
  "video/mp4": {
    source: "iana",
    compressible: false,
    extensions: ["mp4", "mp4v", "mpg4"]
  },
  "video/mp4v-es": {
    source: "iana"
  },
  "video/mpeg": {
    source: "iana",
    compressible: false,
    extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
  },
  "video/mpeg4-generic": {
    source: "iana"
  },
  "video/mpv": {
    source: "iana"
  },
  "video/nv": {
    source: "iana"
  },
  "video/ogg": {
    source: "iana",
    compressible: false,
    extensions: ["ogv"]
  },
  "video/parityfec": {
    source: "iana"
  },
  "video/pointer": {
    source: "iana"
  },
  "video/quicktime": {
    source: "iana",
    compressible: false,
    extensions: ["qt", "mov"]
  },
  "video/raptorfec": {
    source: "iana"
  },
  "video/raw": {
    source: "iana"
  },
  "video/rtp-enc-aescm128": {
    source: "iana"
  },
  "video/rtploopback": {
    source: "iana"
  },
  "video/rtx": {
    source: "iana"
  },
  "video/scip": {
    source: "iana"
  },
  "video/smpte291": {
    source: "iana"
  },
  "video/smpte292m": {
    source: "iana"
  },
  "video/ulpfec": {
    source: "iana"
  },
  "video/vc1": {
    source: "iana"
  },
  "video/vc2": {
    source: "iana"
  },
  "video/vnd.cctv": {
    source: "iana"
  },
  "video/vnd.dece.hd": {
    source: "iana",
    extensions: ["uvh", "uvvh"]
  },
  "video/vnd.dece.mobile": {
    source: "iana",
    extensions: ["uvm", "uvvm"]
  },
  "video/vnd.dece.mp4": {
    source: "iana"
  },
  "video/vnd.dece.pd": {
    source: "iana",
    extensions: ["uvp", "uvvp"]
  },
  "video/vnd.dece.sd": {
    source: "iana",
    extensions: ["uvs", "uvvs"]
  },
  "video/vnd.dece.video": {
    source: "iana",
    extensions: ["uvv", "uvvv"]
  },
  "video/vnd.directv.mpeg": {
    source: "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dvb.file": {
    source: "iana",
    extensions: ["dvb"]
  },
  "video/vnd.fvt": {
    source: "iana",
    extensions: ["fvt"]
  },
  "video/vnd.hns.video": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    source: "iana"
  },
  "video/vnd.motorola.video": {
    source: "iana"
  },
  "video/vnd.motorola.videop": {
    source: "iana"
  },
  "video/vnd.mpegurl": {
    source: "iana",
    extensions: ["mxu", "m4u"]
  },
  "video/vnd.ms-playready.media.pyv": {
    source: "iana",
    extensions: ["pyv"]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    source: "iana"
  },
  "video/vnd.nokia.mp4vr": {
    source: "iana"
  },
  "video/vnd.nokia.videovoip": {
    source: "iana"
  },
  "video/vnd.objectvideo": {
    source: "iana"
  },
  "video/vnd.radgamettools.bink": {
    source: "iana"
  },
  "video/vnd.radgamettools.smacker": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg1": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg4": {
    source: "iana"
  },
  "video/vnd.sealed.swf": {
    source: "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    source: "iana"
  },
  "video/vnd.uvvu.mp4": {
    source: "iana",
    extensions: ["uvu", "uvvu"]
  },
  "video/vnd.vivo": {
    source: "iana",
    extensions: ["viv"]
  },
  "video/vnd.youtube.yt": {
    source: "iana"
  },
  "video/vp8": {
    source: "iana"
  },
  "video/webm": {
    source: "apache",
    compressible: false,
    extensions: ["webm"]
  },
  "video/x-f4v": {
    source: "apache",
    extensions: ["f4v"]
  },
  "video/x-fli": {
    source: "apache",
    extensions: ["fli"]
  },
  "video/x-flv": {
    source: "apache",
    compressible: false,
    extensions: ["flv"]
  },
  "video/x-m4v": {
    source: "apache",
    extensions: ["m4v"]
  },
  "video/x-matroska": {
    source: "apache",
    compressible: false,
    extensions: ["mkv", "mk3d", "mks"]
  },
  "video/x-mng": {
    source: "apache",
    extensions: ["mng"]
  },
  "video/x-ms-asf": {
    source: "apache",
    extensions: ["asf", "asx"]
  },
  "video/x-ms-vob": {
    source: "apache",
    extensions: ["vob"]
  },
  "video/x-ms-wm": {
    source: "apache",
    extensions: ["wm"]
  },
  "video/x-ms-wmv": {
    source: "apache",
    compressible: false,
    extensions: ["wmv"]
  },
  "video/x-ms-wmx": {
    source: "apache",
    extensions: ["wmx"]
  },
  "video/x-ms-wvx": {
    source: "apache",
    extensions: ["wvx"]
  },
  "video/x-msvideo": {
    source: "apache",
    extensions: ["avi"]
  },
  "video/x-sgi-movie": {
    source: "apache",
    extensions: ["movie"]
  },
  "video/x-smv": {
    source: "apache",
    extensions: ["smv"]
  },
  "x-conference/x-cooltalk": {
    source: "apache",
    extensions: ["ice"]
  },
  "x-shader/x-fragment": {
    compressible: true
  },
  "x-shader/x-vertex": {
    compressible: true
  }
};

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
/**
 * Module exports.
 */

var mimeDb = require$$0;

// -----------------------------------------------------------------------------

function attributeValidateAccept(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "accept") {
        // validate the parent
        if (!["form", "input"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-accept",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // check in two parts, first, a quick try, match the most common values only


        var errorArr = validateString(node.attribValueRaw, // value
        node.attribValueStartsAt, // offset
        {
          quickPermittedValues: ["audio/*", "video/*", "image/*", "text/html", "image/png", "image/gif", "video/mpeg", "text/css", "audio/basic", wholeExtensionRegex],
          permittedValues: Object.keys(mimeDb),
          canBeCommaSeparated: true,
          noSpaceAfterComma: true
        }); // HTML attribute accept MIME types as values. Here we reference the given
        // value against all official MIME types, taken from IANA and other sources,
        // https://www.npmjs.com/package/mime-db

        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-accept"
          }));
        });
      }
    }
  };
}

function attributeValidateAccesskey(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "accesskey") {
        // validate the parent
        if (!["a", "area", "button", "input", "label", "legend", "textarea"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-accesskey",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // only check for rogue whitespace - value can be any string


        var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
            charStart = _checkForWhitespace.charStart,
            charEnd = _checkForWhitespace.charEnd,
            errorArr = _checkForWhitespace.errorArr,
            trimmedVal = _checkForWhitespace.trimmedVal;

        if (typeof charStart === "number" && typeof charEnd === "number") {
          // the value must be a character, raw or escaped, from a document's
          // charset
          // https://www.w3.org/TR/html4/interact/forms.html#adef-accesskey
          if (trimmedVal.length > 1 && !(trimmedVal.startsWith("&") && trimmedVal.endsWith(";"))) {
            errorArr.push({
              idxFrom: node.attribValueStartsAt + charStart,
              idxTo: node.attribValueStartsAt + charEnd,
              message: "Should be a single character (escaped or not).",
              fix: null
            });
          }
        }

        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-accesskey"
          }));
        });
      }
    }
  };
}

var BACKSLASH = "\\";
var knownSchemes = ["aaa", "aaas", "about", "acap", "acct", "acd", "acr", "adiumxtra", "adt", "afp", "afs", "aim", "amss", "android", "appdata", "apt", "ark", "attachment", "aw", "barion", "beshare", "bitcoin", "bitcoincash", "blob", "bolo", "browserext", "calculator", "callto", "cap", "cast", "casts", "chrome", "chrome-extension", "cid", "coap", "coap+tcp", "coap+ws", "coaps", "coaps+tcp", "coaps+ws", "com-eventbrite-attendee", "content", "conti", "crid", "cvs", "dab", "dav", "diaspora", "dict", "did", "dis", "dlna-playcontainer", "dlna-playsingle", "dns", "dntp", "dpp", "drm", "drop", "dtn", "dvb", "ed2k", "elsi", "example", "facetime", "fax", "feed", "feedready", "filesystem", "finger", "first-run-pen-experience", "fish", "fm", "fuchsia-pkg", "geo", "gg", "git", "gizmoproject", "go", "gopher", "graph", "gtalk", "h323", "ham", "hcap", "hcp", "hxxp", "hxxps", "hydrazone", "iax", "icap", "icon", "im", "imap", "info", "iotdisco", "ipn", "ipp", "ipps", "irc6", "ircs", "iris", "iris.beep", "iris.lwz", "iris.xpc", "iris.xpcs", "isostore", "itms", "jabber", "jar", "jms", "keyparc", "lastfm", "ldap", "ldaps", "leaptofrogans", "lorawan", "lvlt", "magnet", "mailserver", "maps", "market", "message", "microsoft.windows.camera", "microsoft.windows.camera.multipicker", "microsoft.windows.camera.picker", "mid", "mms", "modem", "mongodb", "moz", "ms-access", "ms-browser-extension", "ms-calculator", "ms-drive-to", "ms-enrollment", "ms-excel", "ms-eyecontrolspeech", "ms-gamebarservices", "ms-gamingoverlay", "ms-getoffice", "ms-help", "ms-infopath", "ms-inputapp", "ms-lockscreencomponent-config", "ms-media-stream-id", "ms-mixedrealitycapture", "ms-mobileplans", "ms-officeapp", "ms-people", "ms-project", "ms-powerpoint", "ms-publisher", "ms-restoretabcompanion", "ms-screenclip", "ms-screensketch", "ms-search", "ms-search-repair", "ms-secondary-screen-controller", "ms-secondary-screen-setup", "ms-settings", "ms-settings-airplanemode", "ms-settings-bluetooth", "ms-settings-camera", "ms-settings-cellular", "ms-settings-cloudstorage", "ms-settings-connectabledevices", "ms-settings-displays-topology", "ms-settings-emailandaccounts", "ms-settings-language", "ms-settings-location", "ms-settings-lock", "ms-settings-nfctransactions", "ms-settings-notifications", "ms-settings-power", "ms-settings-privacy", "ms-settings-proximity", "ms-settings-screenrotation", "ms-settings-wifi", "ms-settings-workplace", "ms-spd", "ms-sttoverlay", "ms-transit-to", "ms-useractivityset", "ms-virtualtouchpad", "ms-visio", "ms-walk-to", "ms-whiteboard", "ms-whiteboard-cmd", "ms-word", "msnim", "msrp", "msrps", "mss", "mtqp", "mumble", "mupdate", "mvn", "news", "nfs", "ni", "nih", "nntp", "notes", "ocf", "oid", "onenote", "onenote-cmd", "opaquelocktoken", "openpgp4fpr", "pack", "palm", "paparazzi", "payment", "payto", "pkcs11", "platform", "pop", "pres", "prospero", "proxy", "pwid", "psyc", "pttp", "qb", "query", "quic-transport", "redis", "rediss", "reload", "res", "resource", "rmi", "rsync", "rtmfp", "rtmp", "rtsp", "rtsps", "rtspu", "secondlife", "service", "session", "sftp", "sgn", "shttp", "sieve", "simpleledger", "sip", "sips", "skype", "smb", "sms", "smtp", "snews", "snmp", "soap.beep", "soap.beeps", "soldat", "spiffe", "spotify", "ssh", "steam", "stun", "stuns", "submit", "svn", "tag", "teamspeak", "tel", "teliaeid", "telnet", "tftp", "things", "thismessage", "tip", "tn3270", "tool", "turn", "turns", "tv", "udp", "unreal", "urn", "ut2004", "v-event", "vemmi", "ventrilo", "videotex", "vnc", "view-source", "wais", "webcal", "wpid", "ws", "wss", "wtai", "wyciwyg", "xcon", "xcon-userid", "xfire", "xmlrpc.beep", "xmlrpc.beeps", "xmpp", "xri", "ymsgr", "z39.50", "z39.50r", "z39.50s"];

function isRel(str, originalOpts) {
  if (typeof str !== "string") {
    throw new Error("is-relative-uri: [THROW_ID_01] input string must be string, it was given as \"" + str + "\" (type " + typeof str + ")");
  }

  if (originalOpts && typeof originalOpts !== "object") {
    throw new Error("is-relative-uri: [THROW_ID_02] opts be plain object, it was given as " + originalOpts + " (type " + typeof originalOpts + ")");
  }

  var defaults = {
    flagUpUrisWithSchemes: true,
    offset: 0
  };

  var opts = _objectSpread2(_objectSpread2({}, defaults), originalOpts);

  if (opts.offset && !Number.isInteger(opts.offset)) {
    throw new Error("is-relative-uri: [THROW_ID_02] opts.offset must be an integer, it was given as " + opts.offset + " (type " + typeof opts.offset + ")");
  }

  if (!opts.offset) {
    opts.offset = 0;
  }

  if (str.split("").some(function (char) {
    return !char.trim();
  })) {
    return {
      res: false,
      message: "Remove whitespace."
    };
  }

  if (str.match(/\/\s*\/\s*\//g)) {
    return {
      res: false,
      message: "Three consecutive slashes found."
    };
  }

  if (str.match(/.\/\s*\//g)) {
    return {
      res: false,
      message: "Character followed by two slashes."
    };
  }

  if (str.includes("...")) {
    return {
      res: false,
      message: "Three consecutive dots."
    };
  }

  if (str.includes("%") && !str.match(/%[0-9a-f]/gi)) {
    return {
      res: false,
      message: "Unescaped \"%\" character."
    };
  }

  if (str.includes("<")) {
    return {
      res: false,
      message: "Unescaped \"<\" character."
    };
  }

  if (str.includes(">")) {
    return {
      res: false,
      message: "Unescaped \">\" character."
    };
  }

  if (str.includes("[")) {
    return {
      res: false,
      message: "Unescaped \"[\" character."
    };
  }

  if (str.includes("]")) {
    return {
      res: false,
      message: "Unescaped \"]\" character."
    };
  }

  if (str.includes("{")) {
    return {
      res: false,
      message: "Unescaped \"{\" character."
    };
  }

  if (str.includes("}")) {
    return {
      res: false,
      message: "Unescaped \"}\" character."
    };
  }

  if (str.includes("|")) {
    return {
      res: false,
      message: "Unescaped \"|\" character."
    };
  }

  if (str.includes(BACKSLASH)) {
    return {
      res: false,
      message: "Unescaped backslash (" + BACKSLASH + ") character."
    };
  }

  if (str.includes("^")) {
    return {
      res: false,
      message: "Unescaped caret (^) character."
    };
  }

  if (str.endsWith(".") && !str.startsWith(".")) {
    return {
      res: false,
      message: "Ends with dot, is file extension missing?"
    };
  }

  if (str.includes("??")) {
    return {
      res: false,
      message: "Two consecutive question marks."
    };
  }

  if (str.includes("##")) {
    return {
      res: false,
      message: "Two consecutive hashes."
    };
  }

  if (str.endsWith("#")) {
    return {
      res: false,
      message: "Ends with a hash."
    };
  }

  if (str.includes("#") && str.slice(str.indexOf("#") + 1).includes("/")) {
    return {
      res: false,
      message: "Slash follows hash."
    };
  }

  if (str.match(/\.\.[^/]/g)) {
    return {
      res: false,
      message: "Two dots should be followed by a slash."
    };
  }

  if (opts.flagUpUrisWithSchemes && (str.startsWith("http:") || str.startsWith("https:") || str.startsWith("ftp:") || str.startsWith("mailto:") || str.startsWith("file:") || str.startsWith("data:") || str.startsWith("irc:") || knownSchemes.some(function (scheme) {
    return str.startsWith(scheme + ":");
  }))) {
    return {
      res: false,
      message: null
    };
  }

  return {
    res: true,
    message: null
  };
}

var word = '[a-fA-F\\d:]';

var b = function b(options) {
  return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : '';
};

var v4 = '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}';
var v6seg = '[a-fA-F\\d]{1,4}';
var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, '').replace(/\n/g, '').trim(); // Pre-compile only the exact regexes because adding a global flag make regexes stateful

var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
var v4exact = new RegExp("^" + v4 + "$");
var v6exact = new RegExp("^" + v6 + "$");

var ip = function ip(options) {
  return options && options.exact ? v46Exact : new RegExp("(?:" + b(options) + v4 + b(options) + ")|(?:" + b(options) + v6 + b(options) + ")", 'g');
};

ip.v4 = function (options) {
  return options && options.exact ? v4exact : new RegExp("" + b(options) + v4 + b(options), 'g');
};

ip.v6 = function (options) {
  return options && options.exact ? v6exact : new RegExp("" + b(options) + v6 + b(options), 'g');
};

var ipRegex = ip;

var tlds = ["aaa", "aarp", "abarth", "abb", "abbott", "abbvie", "abc", "able", "abogado", "abudhabi", "ac", "academy", "accenture", "accountant", "accountants", "aco", "actor", "ad", "adac", "ads", "adult", "ae", "aeg", "aero", "aetna", "af", "afamilycompany", "afl", "africa", "ag", "agakhan", "agency", "ai", "aig", "airbus", "airforce", "airtel", "akdn", "al", "alfaromeo", "alibaba", "alipay", "allfinanz", "allstate", "ally", "alsace", "alstom", "am", "amazon", "americanexpress", "americanfamily", "amex", "amfam", "amica", "amsterdam", "analytics", "android", "anquan", "anz", "ao", "aol", "apartments", "app", "apple", "aq", "aquarelle", "ar", "arab", "aramco", "archi", "army", "arpa", "art", "arte", "as", "asda", "asia", "associates", "at", "athleta", "attorney", "au", "auction", "audi", "audible", "audio", "auspost", "author", "auto", "autos", "avianca", "aw", "aws", "ax", "axa", "az", "azure", "ba", "baby", "baidu", "banamex", "bananarepublic", "band", "bank", "bar", "barcelona", "barclaycard", "barclays", "barefoot", "bargains", "baseball", "basketball", "bauhaus", "bayern", "bb", "bbc", "bbt", "bbva", "bcg", "bcn", "bd", "be", "beats", "beauty", "beer", "bentley", "berlin", "best", "bestbuy", "bet", "bf", "bg", "bh", "bharti", "bi", "bible", "bid", "bike", "bing", "bingo", "bio", "biz", "bj", "black", "blackfriday", "blockbuster", "blog", "bloomberg", "blue", "bm", "bms", "bmw", "bn", "bnpparibas", "bo", "boats", "boehringer", "bofa", "bom", "bond", "boo", "book", "booking", "bosch", "bostik", "boston", "bot", "boutique", "box", "br", "bradesco", "bridgestone", "broadway", "broker", "brother", "brussels", "bs", "bt", "budapest", "bugatti", "build", "builders", "business", "buy", "buzz", "bv", "bw", "by", "bz", "bzh", "ca", "cab", "cafe", "cal", "call", "calvinklein", "cam", "camera", "camp", "cancerresearch", "canon", "capetown", "capital", "capitalone", "car", "caravan", "cards", "care", "career", "careers", "cars", "casa", "case", "cash", "casino", "cat", "catering", "catholic", "cba", "cbn", "cbre", "cbs", "cc", "cd", "center", "ceo", "cern", "cf", "cfa", "cfd", "cg", "ch", "chanel", "channel", "charity", "chase", "chat", "cheap", "chintai", "christmas", "chrome", "church", "ci", "cipriani", "circle", "cisco", "citadel", "citi", "citic", "city", "cityeats", "ck", "cl", "claims", "cleaning", "click", "clinic", "clinique", "clothing", "cloud", "club", "clubmed", "cm", "cn", "co", "coach", "codes", "coffee", "college", "cologne", "com", "comcast", "commbank", "community", "company", "compare", "computer", "comsec", "condos", "construction", "consulting", "contact", "contractors", "cooking", "cookingchannel", "cool", "coop", "corsica", "country", "coupon", "coupons", "courses", "cpa", "cr", "credit", "creditcard", "creditunion", "cricket", "crown", "crs", "cruise", "cruises", "csc", "cu", "cuisinella", "cv", "cw", "cx", "cy", "cymru", "cyou", "cz", "dabur", "dad", "dance", "data", "date", "dating", "datsun", "day", "dclk", "dds", "de", "deal", "dealer", "deals", "degree", "delivery", "dell", "deloitte", "delta", "democrat", "dental", "dentist", "desi", "design", "dev", "dhl", "diamonds", "diet", "digital", "direct", "directory", "discount", "discover", "dish", "diy", "dj", "dk", "dm", "dnp", "do", "docs", "doctor", "dog", "domains", "dot", "download", "drive", "dtv", "dubai", "duck", "dunlop", "dupont", "durban", "dvag", "dvr", "dz", "earth", "eat", "ec", "eco", "edeka", "edu", "education", "ee", "eg", "email", "emerck", "energy", "engineer", "engineering", "enterprises", "epson", "equipment", "er", "ericsson", "erni", "es", "esq", "estate", "et", "etisalat", "eu", "eurovision", "eus", "events", "exchange", "expert", "exposed", "express", "extraspace", "fage", "fail", "fairwinds", "faith", "family", "fan", "fans", "farm", "farmers", "fashion", "fast", "fedex", "feedback", "ferrari", "ferrero", "fi", "fiat", "fidelity", "fido", "film", "final", "finance", "financial", "fire", "firestone", "firmdale", "fish", "fishing", "fit", "fitness", "fj", "fk", "flickr", "flights", "flir", "florist", "flowers", "fly", "fm", "fo", "foo", "food", "foodnetwork", "football", "ford", "forex", "forsale", "forum", "foundation", "fox", "fr", "free", "fresenius", "frl", "frogans", "frontdoor", "frontier", "ftr", "fujitsu", "fujixerox", "fun", "fund", "furniture", "futbol", "fyi", "ga", "gal", "gallery", "gallo", "gallup", "game", "games", "gap", "garden", "gay", "gb", "gbiz", "gd", "gdn", "ge", "gea", "gent", "genting", "george", "gf", "gg", "ggee", "gh", "gi", "gift", "gifts", "gives", "giving", "gl", "glade", "glass", "gle", "global", "globo", "gm", "gmail", "gmbh", "gmo", "gmx", "gn", "godaddy", "gold", "goldpoint", "golf", "goo", "goodyear", "goog", "google", "gop", "got", "gov", "gp", "gq", "gr", "grainger", "graphics", "gratis", "green", "gripe", "grocery", "group", "gs", "gt", "gu", "guardian", "gucci", "guge", "guide", "guitars", "guru", "gw", "gy", "hair", "hamburg", "hangout", "haus", "hbo", "hdfc", "hdfcbank", "health", "healthcare", "help", "helsinki", "here", "hermes", "hgtv", "hiphop", "hisamitsu", "hitachi", "hiv", "hk", "hkt", "hm", "hn", "hockey", "holdings", "holiday", "homedepot", "homegoods", "homes", "homesense", "honda", "horse", "hospital", "host", "hosting", "hot", "hoteles", "hotels", "hotmail", "house", "how", "hr", "hsbc", "ht", "hu", "hughes", "hyatt", "hyundai", "ibm", "icbc", "ice", "icu", "id", "ie", "ieee", "ifm", "ikano", "il", "im", "imamat", "imdb", "immo", "immobilien", "in", "inc", "industries", "infiniti", "info", "ing", "ink", "institute", "insurance", "insure", "int", "international", "intuit", "investments", "io", "ipiranga", "iq", "ir", "irish", "is", "ismaili", "ist", "istanbul", "it", "itau", "itv", "iveco", "jaguar", "java", "jcb", "je", "jeep", "jetzt", "jewelry", "jio", "jll", "jm", "jmp", "jnj", "jo", "jobs", "joburg", "jot", "joy", "jp", "jpmorgan", "jprs", "juegos", "juniper", "kaufen", "kddi", "ke", "kerryhotels", "kerrylogistics", "kerryproperties", "kfh", "kg", "kh", "ki", "kia", "kim", "kinder", "kindle", "kitchen", "kiwi", "km", "kn", "koeln", "komatsu", "kosher", "kp", "kpmg", "kpn", "kr", "krd", "kred", "kuokgroup", "kw", "ky", "kyoto", "kz", "la", "lacaixa", "lamborghini", "lamer", "lancaster", "lancia", "land", "landrover", "lanxess", "lasalle", "lat", "latino", "latrobe", "law", "lawyer", "lb", "lc", "lds", "lease", "leclerc", "lefrak", "legal", "lego", "lexus", "lgbt", "li", "lidl", "life", "lifeinsurance", "lifestyle", "lighting", "like", "lilly", "limited", "limo", "lincoln", "linde", "link", "lipsy", "live", "living", "lixil", "lk", "llc", "llp", "loan", "loans", "locker", "locus", "loft", "lol", "london", "lotte", "lotto", "love", "lpl", "lplfinancial", "lr", "ls", "lt", "ltd", "ltda", "lu", "lundbeck", "luxe", "luxury", "lv", "ly", "ma", "macys", "madrid", "maif", "maison", "makeup", "man", "management", "mango", "map", "market", "marketing", "markets", "marriott", "marshalls", "maserati", "mattel", "mba", "mc", "mckinsey", "md", "me", "med", "media", "meet", "melbourne", "meme", "memorial", "men", "menu", "merckmsd", "mg", "mh", "miami", "microsoft", "mil", "mini", "mint", "mit", "mitsubishi", "mk", "ml", "mlb", "mls", "mm", "mma", "mn", "mo", "mobi", "mobile", "moda", "moe", "moi", "mom", "monash", "money", "monster", "mormon", "mortgage", "moscow", "moto", "motorcycles", "mov", "movie", "mp", "mq", "mr", "ms", "msd", "mt", "mtn", "mtr", "mu", "museum", "mutual", "mv", "mw", "mx", "my", "mz", "na", "nab", "nagoya", "name", "nationwide", "natura", "navy", "nba", "nc", "ne", "nec", "net", "netbank", "netflix", "network", "neustar", "new", "news", "next", "nextdirect", "nexus", "nf", "nfl", "ng", "ngo", "nhk", "ni", "nico", "nike", "nikon", "ninja", "nissan", "nissay", "nl", "no", "nokia", "northwesternmutual", "norton", "now", "nowruz", "nowtv", "np", "nr", "nra", "nrw", "ntt", "nu", "nyc", "nz", "obi", "observer", "off", "office", "okinawa", "olayan", "olayangroup", "oldnavy", "ollo", "om", "omega", "one", "ong", "onl", "online", "onyourside", "ooo", "open", "oracle", "orange", "org", "organic", "origins", "osaka", "otsuka", "ott", "ovh", "pa", "page", "panasonic", "paris", "pars", "partners", "parts", "party", "passagens", "pay", "pccw", "pe", "pet", "pf", "pfizer", "pg", "ph", "pharmacy", "phd", "philips", "phone", "photo", "photography", "photos", "physio", "pics", "pictet", "pictures", "pid", "pin", "ping", "pink", "pioneer", "pizza", "pk", "pl", "place", "play", "playstation", "plumbing", "plus", "pm", "pn", "pnc", "pohl", "poker", "politie", "porn", "post", "pr", "pramerica", "praxi", "press", "prime", "pro", "prod", "productions", "prof", "progressive", "promo", "properties", "property", "protection", "pru", "prudential", "ps", "pt", "pub", "pw", "pwc", "py", "qa", "qpon", "quebec", "quest", "qvc", "racing", "radio", "raid", "re", "read", "realestate", "realtor", "realty", "recipes", "red", "redstone", "redumbrella", "rehab", "reise", "reisen", "reit", "reliance", "ren", "rent", "rentals", "repair", "report", "republican", "rest", "restaurant", "review", "reviews", "rexroth", "rich", "richardli", "ricoh", "ril", "rio", "rip", "rmit", "ro", "rocher", "rocks", "rodeo", "rogers", "room", "rs", "rsvp", "ru", "rugby", "ruhr", "run", "rw", "rwe", "ryukyu", "sa", "saarland", "safe", "safety", "sakura", "sale", "salon", "samsclub", "samsung", "sandvik", "sandvikcoromant", "sanofi", "sap", "sarl", "sas", "save", "saxo", "sb", "sbi", "sbs", "sc", "sca", "scb", "schaeffler", "schmidt", "scholarships", "school", "schule", "schwarz", "science", "scjohnson", "scot", "sd", "se", "search", "seat", "secure", "security", "seek", "select", "sener", "services", "ses", "seven", "sew", "sex", "sexy", "sfr", "sg", "sh", "shangrila", "sharp", "shaw", "shell", "shia", "shiksha", "shoes", "shop", "shopping", "shouji", "show", "showtime", "si", "silk", "sina", "singles", "site", "sj", "sk", "ski", "skin", "sky", "skype", "sl", "sling", "sm", "smart", "smile", "sn", "sncf", "so", "soccer", "social", "softbank", "software", "sohu", "solar", "solutions", "song", "sony", "soy", "spa", "space", "sport", "spot", "spreadbetting", "sr", "srl", "ss", "st", "stada", "staples", "star", "statebank", "statefarm", "stc", "stcgroup", "stockholm", "storage", "store", "stream", "studio", "study", "style", "su", "sucks", "supplies", "supply", "support", "surf", "surgery", "suzuki", "sv", "swatch", "swiftcover", "swiss", "sx", "sy", "sydney", "systems", "sz", "tab", "taipei", "talk", "taobao", "target", "tatamotors", "tatar", "tattoo", "tax", "taxi", "tc", "tci", "td", "tdk", "team", "tech", "technology", "tel", "temasek", "tennis", "teva", "tf", "tg", "th", "thd", "theater", "theatre", "tiaa", "tickets", "tienda", "tiffany", "tips", "tires", "tirol", "tj", "tjmaxx", "tjx", "tk", "tkmaxx", "tl", "tm", "tmall", "tn", "to", "today", "tokyo", "tools", "top", "toray", "toshiba", "total", "tours", "town", "toyota", "toys", "tr", "trade", "trading", "training", "travel", "travelchannel", "travelers", "travelersinsurance", "trust", "trv", "tt", "tube", "tui", "tunes", "tushu", "tv", "tvs", "tw", "tz", "ua", "ubank", "ubs", "ug", "uk", "unicom", "university", "uno", "uol", "ups", "us", "uy", "uz", "va", "vacations", "vana", "vanguard", "vc", "ve", "vegas", "ventures", "verisign", "versicherung", "vet", "vg", "vi", "viajes", "video", "vig", "viking", "villas", "vin", "vip", "virgin", "visa", "vision", "viva", "vivo", "vlaanderen", "vn", "vodka", "volkswagen", "volvo", "vote", "voting", "voto", "voyage", "vu", "vuelos", "wales", "walmart", "walter", "wang", "wanggou", "watch", "watches", "weather", "weatherchannel", "webcam", "weber", "website", "wed", "wedding", "weibo", "weir", "wf", "whoswho", "wien", "wiki", "williamhill", "win", "windows", "wine", "winners", "wme", "wolterskluwer", "woodside", "work", "works", "world", "wow", "ws", "wtc", "wtf", "xbox", "xerox", "xfinity", "xihuan", "xin", "कॉम", "セール", "佛山", "ಭಾರತ", "慈善", "集团", "在线", "한국", "ଭାରତ", "大众汽车", "点看", "คอม", "ভাৰত", "ভারত", "八卦", "ישראל", "موقع", "বাংলা", "公益", "公司", "香格里拉", "网站", "移动", "我爱你", "москва", "қаз", "католик", "онлайн", "сайт", "联通", "срб", "бг", "бел", "קום", "时尚", "微博", "淡马锡", "ファッション", "орг", "नेट", "ストア", "アマゾン", "삼성", "சிங்கப்பூர்", "商标", "商店", "商城", "дети", "мкд", "ею", "ポイント", "新闻", "家電", "كوم", "中文网", "中信", "中国", "中國", "娱乐", "谷歌", "భారత్", "ලංකා", "電訊盈科", "购物", "クラウド", "ભારત", "通販", "भारतम्", "भारत", "भारोत", "网店", "संगठन", "餐厅", "网络", "ком", "укр", "香港", "亚马逊", "诺基亚", "食品", "飞利浦", "台湾", "台灣", "手机", "мон", "الجزائر", "عمان", "ارامكو", "ایران", "العليان", "اتصالات", "امارات", "بازار", "موريتانيا", "پاکستان", "الاردن", "بارت", "بھارت", "المغرب", "ابوظبي", "البحرين", "السعودية", "ڀارت", "كاثوليك", "سودان", "همراه", "عراق", "مليسيا", "澳門", "닷컴", "政府", "شبكة", "بيتك", "عرب", "გე", "机构", "组织机构", "健康", "ไทย", "سورية", "招聘", "рус", "рф", "تونس", "大拿", "ລາວ", "みんな", "グーグル", "ευ", "ελ", "世界", "書籍", "ഭാരതം", "ਭਾਰਤ", "网址", "닷넷", "コム", "天主教", "游戏", "vermögensberater", "vermögensberatung", "企业", "信息", "嘉里大酒店", "嘉里", "مصر", "قطر", "广东", "இலங்கை", "இந்தியா", "հայ", "新加坡", "فلسطين", "政务", "xxx", "xyz", "yachts", "yahoo", "yamaxun", "yandex", "ye", "yodobashi", "yoga", "yokohama", "you", "youtube", "yt", "yun", "za", "zappos", "zara", "zero", "zip", "zm", "zone", "zuerich", "zw"];

var urlRegex = function urlRegex(options) {
  options = _objectSpread2({
    strict: true
  }, options);
  var protocol = "(?:(?:[a-z]+:)?//)" + (options.strict ? '' : '?');
  var auth = '(?:\\S+(?::\\S*)?@)?';
  var ip = ipRegex.v4().source;
  var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
  var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
  var tld = "(?:\\." + (options.strict ? "(?:[a-z\\u00a1-\\uffff]{2,})" : "(?:" + tlds.sort(function (a, b) {
    return b.length - a.length;
  }).join('|') + ")") + ")\\.?";
  var port = '(?::\\d{2,5})?';
  var path = '(?:[/?#][^\\s"]*)?';
  var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ip + "|" + host + domain + tld + ")" + port + path;
  return options.exact ? new RegExp("(?:^" + regex + "$)", 'i') : new RegExp(regex, 'ig');
};

function isSingleSpace(str, originalOpts, errorArr) {
  var defaults = {
    from: 0,
    to: str.length,
    offset: 0
  };

  var opts = _objectSpread2(_objectSpread2({}, defaults), originalOpts); // whitespace starts at "from" and ends at "to"

  if (str.slice(opts.from, opts.to) !== " ") { // remove the minimal amount of content - if spaces are there
    // already, leave them

    var ranges;

    if (str[opts.from] === " ") {
      ranges = [[opts.offset + opts.from + 1, opts.offset + opts.to]];
    } else if (str[opts.to - 1] === " ") {
      ranges = [[opts.offset + opts.from, opts.offset + opts.to - 1]];
    } else {
      ranges = [[opts.offset + opts.from, opts.offset + opts.to, " "]];
    } // raise an error about this excessive/wrong whitespace
    errorArr.push({
      idxFrom: opts.offset + opts.from,
      idxTo: opts.offset + opts.to,
      message: "Should be a single space.",
      fix: {
        ranges: ranges
      }
    });
  }
}

function validateValue$1(str, originalOpts, errorArr) {
  var defaults = {
    offset: 0,
    multipleOK: false,
    from: 0,
    to: str.length,
    attribStarts: 0,
    attribEnds: str.length
  };

  var opts = _objectSpread2(_objectSpread2({}, defaults), originalOpts);
  var extractedValue = str.slice(opts.from, opts.to);
  var calcultedIsRel = isRel(extractedValue);

  if (Array.from(extractedValue).some(function (val) {
    return !val.trim().length;
  })) {
    // try to find out, is it whitespace within one URL, or is it whitespace
    // separating two URL's:
    var ranges = []; // whitespace ranges

    var foundCharacterRanges = [];
    splitByWhitespace(extractedValue, function (valueRangeArr) {
      foundCharacterRanges.push(valueRangeArr);
    }, function (whitespaceRangeArr) {
      ranges.push(whitespaceRangeArr);
    }, originalOpts);
    var countOfURIs = foundCharacterRanges.reduce(function (acc, curr) {

      if (extractedValue.slice(curr[0] - opts.offset, curr[1] - opts.offset).match(urlRegex({
        exact: true
      }))) {
        return acc + 1;
      }

      return acc;
    }, 0); // assemble the value without whitespace

    foundCharacterRanges.reduce(function (acc, curr) {
      return acc + extractedValue.slice(curr[0] - opts.offset, curr[1] - opts.offset);
    }, "");

    if (countOfURIs > 1) {
      errorArr.push({
        idxFrom: opts.from + opts.offset,
        idxTo: opts.to + opts.offset,
        message: "There should be only one URI.",
        fix: null
      });
    } else {
      errorArr.push({
        idxFrom: opts.from + opts.offset,
        idxTo: opts.to + opts.offset,
        message: "Remove whitespace.",
        fix: {
          ranges: ranges
        }
      });
    }
  } else if (!extractedValue.startsWith("tel:") && !(urlRegex({
    exact: true
  }).test(extractedValue) || calcultedIsRel.res)) { // message:
    // Should be ${opts.separator}-separated list of URI's.
    // applies onto when multiple values are allowed and whole attribute is
    // reported as wrong (not one of chunks):

    var message = "Should be an URI.";
    var idxFrom = opts.offset + opts.from;
    var idxTo = opts.offset + opts.to;
    var whatCouldBeExtractedAtAllFromRegex = extractedValue.match(urlRegex()); // if URL's were extracted

    if (Array.isArray(whatCouldBeExtractedAtAllFromRegex)) {
      // something was indeed extracted
      if (whatCouldBeExtractedAtAllFromRegex.length > 1 && !opts.multipleOK) {
        message = "There should be only one URI.";
      } else {
        message = "URI's should be separated with a single space.";
      }

      idxFrom = opts.offset + opts.attribStarts;
      idxTo = opts.offset + opts.attribEnds;
    }
    errorArr.push({
      idxFrom: idxFrom,
      idxTo: idxTo,
      message: message,
      fix: null
    });
  }
}

function validateUri(str, originalOpts) {
  var defaults = {
    offset: 0,
    multipleOK: false,
    separator: "space",
    oneSpaceAfterCommaOK: false,
    leadingWhitespaceOK: false,
    trailingWhitespaceOK: false
  };

  var opts = _objectSpread2(_objectSpread2({}, defaults), originalOpts); // checkForWhitespace() reports index range between the
  // first last non-whitespace character; nulls otherwise

  var _checkForWhitespace = checkForWhitespace(str, opts.offset),
      charStart = _checkForWhitespace.charStart,
      charEnd = _checkForWhitespace.charEnd,
      errorArr = _checkForWhitespace.errorArr; // now that we know where non-whitespace chars are, we can evaluate them

  if (Number.isInteger(charStart)) {

    if (opts.multipleOK) {
      // depends, is it comma or space-separated format
      if (opts.separator === "space") {
        splitByWhitespace(str, function (_ref) {
          var charFrom = _ref[0],
              charTo = _ref[1];
          var extractedName = str.slice(charFrom, charTo); // maybe it's comma-and-space-separated, like
          // <object archive="https://codsen.com, https://detergent.io">

          if (extractedName.endsWith(",") && extractedName.length > 1) {
            errorArr.push({
              idxFrom: opts.offset + charTo - 1,
              idxTo: opts.offset + charTo,
              message: "No commas.",
              fix: null
            });
          } else {
            // Object assign needed to retain opts.multipleOK
            validateValue$1(str, _objectSpread2(_objectSpread2({}, opts), {}, {
              from: charFrom,
              to: charTo,
              attribStarts: charStart,
              attribEnds: charEnd,
              offset: opts.offset
            }), errorArr);
          }
        }, function (_ref2) {
          var whitespaceFrom = _ref2[0],
              whitespaceTo = _ref2[1];
          return isSingleSpace(str, {
            from: whitespaceFrom,
            to: whitespaceTo,
            offset: opts.offset
          }, errorArr);
        }, {
          from: charStart,
          to: charEnd
        });
      } else {
        processCommaSep(str, {
          offset: opts.offset,
          oneSpaceAfterCommaOK: false,
          leadingWhitespaceOK: true,
          trailingWhitespaceOK: true,
          cb: function cb(idxFrom, idxTo) {
            str.slice(idxFrom - opts.offset, idxTo - opts.offset); // if there are errors, validateValue() mutates the passed "errorArr",
            // pushing to it
            // Object assign needed to retain opts.multipleOK

            validateValue$1(str, _objectSpread2(_objectSpread2({}, opts), {}, {
              from: idxFrom - opts.offset,
              to: idxTo - opts.offset,
              attribStarts: charStart,
              attribEnds: charEnd,
              offset: opts.offset
            }), errorArr);
          },
          errCb: function errCb(ranges, message) {
            var fix = {
              ranges: ranges
            }; // Some bad whitespace errors like spaces in the middle or URL
            // can't be fixed. We need to cater those cases.

            if (!str[ranges[0][0] - opts.offset].trim().length && str[ranges[0][0] - opts.offset - 1] && charStart < ranges[0][0] - 1 && (opts.separator === "space" || str[ranges[0][0] - opts.offset - 1] !== "," && str[ranges[0][1] - opts.offset] !== ",")) {
              // if it's not outer whitespace, skip the fix
              fix = null;
            }

            errorArr.push({
              idxFrom: ranges[0][0],
              idxTo: ranges[ranges.length - 1][1],
              message: message,
              fix: fix
            });
          }
        });
      }
    } else { // we pass whole value to validateValue(), "cropping" the whitespace:

      validateValue$1(str, {
        from: charStart,
        to: charEnd,
        offset: opts.offset
      }, errorArr);
    }
  }

  return errorArr;
}

function attributeValidateAction(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "action") {
        // validate the parent
        if (node.parent.tagName !== "form") {
          context.report({
            ruleId: "attribute-validate-action",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          // Call validation upon whole attribute's value. Validator includes
          // whitespace checks.
          validateUri(node.attribValueRaw, {
            offset: node.attribValueStartsAt,
            multipleOK: false
          }).forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-action"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateAlign(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "align") {
        // validate the parent
        if (!["applet", "caption", "iframe", "img", "input", "object", "legend", "table", "hr", "div", "h1", "h2", "h3", "h4", "h5", "h6", "p", "col", "colgroup", "tbody", "td", "tfoot", "th", "thead", "tr"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-align",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // check in two parts, first, a quick try, match the most common values only


        var errorArr = [];

        if (["legend", "caption"].includes(node.parent.tagName.toLowerCase())) {
          // top|bottom|left|right
          errorArr = validateString(node.attribValueRaw, // value
          node.attribValueStartsAt, // offset
          {
            permittedValues: ["top", "bottom", "left", "right"],
            canBeCommaSeparated: false
          });
        } else if (["applet", "iframe", "img", "input", "object"].includes(node.parent.tagName.toLowerCase())) {
          // top|middle|bottom|left|right
          errorArr = validateString(node.attribValueRaw, // value
          node.attribValueStartsAt, // offset
          {
            permittedValues: ["top", "middle", "bottom", "left", "right"],
            canBeCommaSeparated: false
          });
        } else if (["table", "hr"].includes(node.parent.tagName.toLowerCase())) {
          // left|center|right
          errorArr = validateString(node.attribValueRaw, // value
          node.attribValueStartsAt, // offset
          {
            permittedValues: ["left", "center", "right"],
            canBeCommaSeparated: false
          });
        } else if (["div", "h1", "h2", "h3", "h4", "h5", "h6", "p"].includes(node.parent.tagName.toLowerCase())) {
          // left|center|right|justify
          errorArr = validateString(node.attribValueRaw, // value
          node.attribValueStartsAt, // offset
          {
            permittedValues: ["left", "center", "right", "justify"],
            canBeCommaSeparated: false
          });
        } else if (["col", "colgroup", "tbody", "td", "tfoot", "th", "thead", "tr"].includes(node.parent.tagName.toLowerCase())) {
          // left|center|right|justify|char
          errorArr = validateString(node.attribValueRaw, // value
          node.attribValueStartsAt, // offset
          {
            permittedValues: ["left", "center", "right", "justify", "char"],
            canBeCommaSeparated: false
          });
        }
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-align"
          }));
        });
      }
    }
  };
}

var defaults$1 = {
  namedCssLevel1OK: true,
  namedCssLevel2PlusOK: true,
  hexThreeOK: false,
  hexFourOK: false,
  hexSixOK: true,
  hexEightOK: false
};

function validateColor(str, idxOffset, originalOpts) {
  var opts = _objectSpread2(_objectSpread2({}, defaults$1), originalOpts); // we get trimmed string start and end positions, also an encountered errors array


  var _checkForWhitespace = checkForWhitespace(str, idxOffset),
      charStart = _checkForWhitespace.charStart,
      charEnd = _checkForWhitespace.charEnd,
      errorArr = _checkForWhitespace.errorArr; // now that we know where non-whitespace chars are, evaluate them


  if (typeof charStart === "number" && typeof charEnd === "number") {
    // we need to extract the trimmed attribute's value
    // either it will be "str" (no inner whitespace) or
    // str.slice(charStart, charEnd) (whitespace found previously)
    var attrVal = errorArr.length ? str.slice(charStart, charEnd) : str;

    if (attrVal.length > 1 && isLetter(attrVal[0]) && isLetter(attrVal[1]) && Object.keys(extendedColorNames).includes(attrVal.toLowerCase())) {

      if (!opts.namedCssLevel1OK) {
        errorArr.push({
          idxFrom: idxOffset + charStart,
          idxTo: idxOffset + charEnd,
          message: "Named colors (CSS Level 1) not allowed.",
          fix: {
            ranges: [[idxOffset + charStart, idxOffset + charEnd, extendedColorNames[attrVal.toLowerCase()]]]
          }
        });
      } else if (!opts.namedCssLevel2PlusOK && (!opts.namedCssLevel1OK || !Object.keys(basicColorNames).includes(attrVal.toLowerCase()))) {
        errorArr.push({
          idxFrom: idxOffset + charStart,
          idxTo: idxOffset + charEnd,
          message: "Named colors (CSS Level 2+) not allowed.",
          fix: {
            ranges: [[idxOffset + charStart, idxOffset + charEnd, extendedColorNames[attrVal.toLowerCase()]]]
          }
        });
      }
    } else if (attrVal.startsWith("#")) {
      if (attrVal.length !== 7) {
        errorArr.push({
          idxFrom: idxOffset + charStart,
          idxTo: idxOffset + charEnd,
          message: "Hex color code should be 6 digits-long.",
          fix: null
        });
      } else if (!sixDigitHexColorRegex.test(attrVal)) {
        errorArr.push({
          idxFrom: idxOffset + charStart,
          idxTo: idxOffset + charEnd,
          message: "Unrecognised hex code.",
          fix: null
        });
      } else if (!opts.hexSixOK) {
        errorArr.push({
          idxFrom: idxOffset + charStart,
          idxTo: idxOffset + charEnd,
          message: "Hex colors not allowed.",
          fix: null
        });
      }
    } else if (attrVal.startsWith("rgb(")) {
      errorArr.push({
        idxFrom: idxOffset + charStart,
        idxTo: idxOffset + charEnd,
        message: "rgb() is not allowed.",
        fix: null
      });
    } else {
      errorArr.push({
        idxFrom: idxOffset + charStart,
        idxTo: idxOffset + charEnd,
        message: "Unrecognised color value.",
        fix: null
      });
    }
  }

  return errorArr;
}

function attributeValidateAlink(context) {
  return {
    attribute: function attribute(node) { // console.log(
      //   `015 attributeValidateAlink(): node = ${JSON.stringify(node, null, 4)}`
      // );

      if (node.attribName === "alink") {
        // validate the parent
        if (node.parent.tagName !== "body") {
          context.report({
            ruleId: "attribute-validate-alink",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-alink",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          var errorArr = validateColor(node.attribValueRaw, node.attribValueStartsAt, {
            namedCssLevel1OK: true,
            namedCssLevel2PlusOK: true,
            hexThreeOK: false,
            hexFourOK: false,
            hexSixOK: true,
            hexEightOK: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-alink"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateAlt(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "alt") {
        // validate the parent
        if (!["applet", "area", "img", "input"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-alt",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        }

        if (node.attribValueStartsAt !== null && node.attribValueEndsAt !== null) {
          // only check for rogue whitespace - value can be any CDATA
          var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-alt"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateArchive(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "archive") {
        // validate the parent
        if (!["applet", "object"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-archive",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          // maybe value is missing anyway?
          context.report({
            ruleId: "attribute-validate-" + node.attribName,
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } // it depends, which tag is this attribute on...
        else if (node.parent.tagName === "applet") {
            // comma-separated list of archive URIs
            // Call validation upon the whole attribute's value. Validator includes
            // whitespace checks.
            validateUri(node.attribValueRaw, {
              offset: node.attribValueStartsAt,
              separator: "comma",
              multipleOK: true
            }).forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-archive"
              }));
            });
          } else if (node.parent.tagName === "object") {
            // space-separated list of URIs
            // Call validation upon the whole attribute's value. Validator includes
            // whitespace checks.
            validateUri(node.attribValueRaw, {
              offset: node.attribValueStartsAt,
              separator: "space",
              multipleOK: true
            }).forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-archive"
              }));
            });
          }
      }
    }
  };
}

function attributeValidateAxis(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "axis") {
        // validate the parent
        if (!["td", "th"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-axis",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        }

        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-axis",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          // only check for rogue whitespace - value can be any CDATA
          var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-axis"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateBackground(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "background") {
        // validate the parent
        if (!["body", "td"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-background",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          // Call validation upon the whole attribute's value. Validator includes
          // whitespace checks.
          validateUri(node.attribValueRaw, {
            offset: node.attribValueStartsAt,
            multipleOK: false
          }).forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-background"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateBgcolor(context) {
  return {
    attribute: function attribute(node) { // console.log(
      //   `015 attributeValidateBgcolor(): node = ${JSON.stringify(node, null, 4)}`
      // );

      if (node.attribName === "bgcolor") {
        // validate the parent
        if (!["table", "tr", "td", "th", "body"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-bgcolor",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-bgcolor",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          var errorArr = validateColor(node.attribValueRaw, node.attribValueStartsAt, {
            namedCssLevel1OK: true,
            namedCssLevel2PlusOK: true,
            hexThreeOK: false,
            hexFourOK: false,
            hexSixOK: true,
            hexEightOK: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-bgcolor"
            }));
          });
        }
      }
    }
  };
}

var defaultOpts = {
  type: "integer",
  whitelistValues: [],
  theOnlyGoodUnits: null,
  plusOK: false,
  negativeOK: false,
  zeroOK: true,
  badUnits: [],
  enforceCount: null,
  noUnitsIsFine: true,
  canBeCommaSeparated: false,
  customGenericValueError: null,
  skipWhitespaceChecks: false,
  customPxMessage: null,
  maxValue: null
};

function validateValue(_ref) {
  var str = _ref.str,
      opts = _ref.opts,
      charStart = _ref.charStart,
      charEnd = _ref.charEnd,
      idxOffset = _ref.idxOffset,
      errorArr = _ref.errorArr;
  // the rule is for pattern digit(s) + unit, so start from checking, does it
  // start with a digit // insurance

  if (typeof str !== "string") {
    return;
  } // applies to rational and integer types


  if (str[charStart] === "0") {
    if (charEnd === charStart + 1) {
      // so length === 1
      if (!opts.zeroOK) {
        errorArr.push({
          idxFrom: idxOffset + charStart,
          idxTo: idxOffset + charEnd,
          message: "Zero not allowed.",
          fix: null
        });
      }
    } else if ("0123456789".includes(str[charStart + 1])) {
      // we have padded cases like 08
      errorArr.push({
        idxFrom: idxOffset + charStart,
        idxTo: idxOffset + charEnd,
        message: "Number padded with zero.",
        fix: null
      });
    }
  }

  if (!"0123456789".includes(str[charStart]) && !"0123456789".includes(str[charEnd - 1])) { // calculate the message

    var message = "Digits missing.";

    if (opts.customGenericValueError) {
      message = opts.customGenericValueError;
    } else if (Array.isArray(opts.theOnlyGoodUnits) && !opts.theOnlyGoodUnits.length && opts.type === "integer") {
      message = "Should be integer, no units.";
    }

    errorArr.push({
      idxFrom: idxOffset + charStart,
      idxTo: idxOffset + charEnd,
      message: message,
      fix: null
    });
  } else if ("0123456789".includes(str[charStart]) && "0123456789".includes(str[charEnd - 1]) && (!opts.noUnitsIsFine || opts.type === "integer" && opts.maxValue && str.slice(charStart, charEnd).match(/^\d+$/) && Number.parseInt(str.slice(charStart, charEnd), 10) > opts.maxValue)) {

    if (!opts.noUnitsIsFine) {
      errorArr.push({
        idxFrom: idxOffset + charStart,
        idxTo: idxOffset + charEnd,
        message: opts.customGenericValueError || "Units missing.",
        fix: null
      });
    } else {
      errorArr.push({
        idxFrom: idxOffset + charStart,
        idxTo: idxOffset + charEnd,
        message: "Maximum, " + opts.maxValue + " exceeded.",
        fix: null
      });
    }
  } else {

    for (var i = charStart; i < charEnd; i++) {

      if (!"0123456789".includes(str[i]) && (str[i] !== "." || opts.type !== "rational") && (str[i] !== "-" || !(opts.negativeOK && i === 0)) && (str[i] !== "+" || !(opts.plusOK && i === 0))) {
        // dash can be in the middle! For example, colspan="1-1"
        var endPart = str.slice(i, charEnd);

        if (isObj(opts) && (Array.isArray(opts.theOnlyGoodUnits) && !opts.theOnlyGoodUnits.includes(endPart) || Array.isArray(opts.badUnits) && opts.badUnits.includes(endPart))) { // special case for "px"

          if (endPart === "px") {
            var _message = opts.customPxMessage ? opts.customPxMessage : "Remove px.";

            errorArr.push({
              idxFrom: idxOffset + i,
              idxTo: idxOffset + charEnd,
              message: _message,
              fix: opts.customPxMessage ? null : {
                ranges: [[idxOffset + i, idxOffset + charEnd]]
              }
            });
          } else {
            // validate against the known units and serve a separate
            // message, depending on was it recognised
            // calculate the message
            var _message2 = "Bad unit.";

            if (str.match(/-\s*-/g)) {
              _message2 = "Repeated minus.";
            } else if (str.match(/\+\s*\+/g)) {
              _message2 = "Repeated plus.";
            } else if (Array.isArray(opts.theOnlyGoodUnits) && opts.theOnlyGoodUnits.length && opts.theOnlyGoodUnits.includes(endPart.trim())) {
              // if trimmed end part matches "good" units, it's the whitespace
              _message2 = "Rogue whitespace.";
            } else if (opts.customGenericValueError) {
              _message2 = opts.customGenericValueError;
            } else if (Array.isArray(opts.theOnlyGoodUnits) && !opts.theOnlyGoodUnits.length && opts.type === "integer") {
              _message2 = "Should be integer, no units.";
            }

            errorArr.push({
              idxFrom: idxOffset + i,
              idxTo: idxOffset + charEnd,
              message: _message2,
              fix: null
            });
          }
        } else if (!knownUnits.includes(endPart)) {
          var _message3 = "Unrecognised unit.";

          if (/\d/.test(endPart)) {
            _message3 = "Messy value.";
          } else if (knownUnits.includes(endPart.trim())) {
            _message3 = "Rogue whitespace.";
          }

          errorArr.push({
            idxFrom: idxOffset + i,
            idxTo: idxOffset + charEnd,
            message: _message3,
            fix: null
          });
        } // stop the loop


        break;
      }
    }
  }
} // function below is used to validate attribute values which contain
// digits and a unit, for example, "100%" of an HTML attribute
// width="100%"
// or
// "100%" of CSS head style "width:100%;"
// it returns array of ready error objects, except without ruleId, something like:
//
// {
//   idxFrom: 17,
//   idxTo: 19,
//   message: `Remove px.`,
//   fix: {
//     ranges: [[17, 19]]
//   }
// }
//
// if it can't fix, key "fix" value is null


function validateDigitAndUnit(str, idxOffset, originalOpts) {
  if (typeof str !== "string") {
    return [];
  }

  var opts = _objectSpread2(_objectSpread2({}, defaultOpts), originalOpts); // we get trimmed string start and end positions, also an encountered errors array


  var charStart = 0;
  var charEnd = str.length;
  var errorArr = [];

  if (!opts.skipWhitespaceChecks) {
    var retrievedWhitespaceChecksObj = checkForWhitespace(str, idxOffset);
    charStart = retrievedWhitespaceChecksObj.charStart;
    charEnd = retrievedWhitespaceChecksObj.charEnd;
    errorArr = retrievedWhitespaceChecksObj.errorArr;
  } // now that we know where non-whitespace chars are, evaluate them

  if (Number.isInteger(charStart)) {

    if (opts.canBeCommaSeparated) { // split by comma and process each

      var extractedValues = [];
      processCommaSep(str, {
        offset: idxOffset,
        oneSpaceAfterCommaOK: false,
        leadingWhitespaceOK: true,
        trailingWhitespaceOK: true,
        cb: function cb(idxFrom, idxTo) {
          var extractedValue = str.slice(idxFrom - idxOffset, idxTo - idxOffset); // if the value is not whitelisted, evaluate it

          if (!Array.isArray(opts.whitelistValues) || !opts.whitelistValues.includes(extractedValue)) {
            validateValue({
              str: str,
              opts: opts,
              charStart: idxFrom - idxOffset,
              charEnd: idxTo - idxOffset,
              idxOffset: idxOffset,
              errorArr: errorArr
            });
          }

          extractedValues.push(extractedValue);
        },
        errCb: function errCb(ranges, message) {
          errorArr.push({
            idxFrom: ranges[0][0],
            idxTo: ranges[ranges.length - 1][1],
            message: message,
            fix: {
              ranges: ranges
            }
          });
        }
      }); // enforce the "extractedValues" count

      if (Number.isInteger(opts.enforceCount) && extractedValues.length !== opts.enforceCount) {
        errorArr.push({
          idxFrom: charStart + idxOffset,
          idxTo: charEnd + idxOffset,
          message: "There should be " + opts.enforceCount + " values.",
          fix: null
        });
      } else if (typeof opts.enforceCount === "string" && ["even", "odd"].includes(opts.enforceCount.toLowerCase())) {
        if (opts.enforceCount.toLowerCase() === "even" && extractedValues.length % 2 !== 0) {
          errorArr.push({
            idxFrom: charStart + idxOffset,
            idxTo: charEnd + idxOffset,
            message: "Should be an even number of values but found " + extractedValues.length + ".",
            fix: null
          });
        } else if (opts.enforceCount.toLowerCase() !== "even" && extractedValues.length % 2 === 0) {
          errorArr.push({
            idxFrom: charStart + idxOffset,
            idxTo: charEnd + idxOffset,
            message: "Should be an odd number of values but found " + extractedValues.length + ".",
            fix: null
          });
        }
      }
    } else { // if the value is not whitelisted, evaluate it

      if (!Array.isArray(opts.whitelistValues) || !opts.whitelistValues.includes(str.slice(charStart, charEnd))) {
        validateValue({
          str: str,
          opts: opts,
          charStart: charStart,
          charEnd: charEnd,
          idxOffset: idxOffset,
          errorArr: errorArr
        });
      }
    }
  }

  return errorArr;
}

function attributeValidateBorder(context) {
  return {
    attribute: function attribute(node) { // console.log(
      //   `015 attributeValidateBorder(): node = ${JSON.stringify(node, null, 4)}`
      // );

      if (node.attribName === "border") {
        // validate the parent
        if (!["table", "img", "object"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-border",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        }

        var errorArr = validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
          type: "integer",
          negativeOK: false,
          theOnlyGoodUnits: [] // empty array means no units allowed

        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-border"
          }));
        });
      }
    }
  };
}

function attributeValidateCellpadding(context) {
  return {
    attribute: function attribute(node) { // console.log(
      //   `015 attributeValidateCellpadding(): node = ${JSON.stringify(node, null, 4)}`
      // );

      if (node.attribName === "cellpadding") {
        // validate the parent
        if (node.parent.tagName !== "table") {
          context.report({
            ruleId: "attribute-validate-cellpadding",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        }

        var errorArr = validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
          type: "integer",
          negativeOK: false,
          theOnlyGoodUnits: ["%"],
          badUnits: ["px"],
          customGenericValueError: "Should be integer, either no units or percentage."
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-cellpadding"
          }));
        });
      }
    }
  };
}

function attributeValidateCellspacing(context) {
  return {
    attribute: function attribute(node) { // console.log(
      //   `015 attributeValidateCellspacing(): node = ${JSON.stringify(node, null, 4)}`
      // );

      if (node.attribName === "cellspacing") {
        // validate the parent
        if (node.parent.tagName !== "table") {
          context.report({
            ruleId: "attribute-validate-cellspacing",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        }

        var errorArr = validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
          type: "integer",
          negativeOK: false,
          theOnlyGoodUnits: ["%"],
          badUnits: ["px"],
          customGenericValueError: "Should be integer, either no units or percentage."
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-cellspacing"
          }));
        });
      }
    }
  };
}

function attributeValidateChar(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "char") {
        // validate the parent
        if (!["col", "colgroup", "tbody", "td", "tfoot", "th", "thead", "tr"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-char",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-char",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
              charStart = _checkForWhitespace.charStart,
              charEnd = _checkForWhitespace.charEnd,
              errorArr = _checkForWhitespace.errorArr,
              trimmedVal = _checkForWhitespace.trimmedVal;

          if (typeof charStart === "number" && typeof charEnd === "number") {
            // the value must be a character, raw or escaped, from ISO10646
            // https://www.w3.org/TR/html4/sgml/dtd.html#Character
            if (trimmedVal.length > 1 && !(trimmedVal.startsWith("&") && trimmedVal.endsWith(";"))) {
              errorArr.push({
                idxFrom: node.attribValueStartsAt + charStart,
                idxTo: node.attribValueStartsAt + charEnd,
                message: "Should be a single character.",
                fix: null
              });
            }
          }

          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-char"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateCharoff(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "charoff") {
        // validate the parent
        if (!["col", "colgroup", "tbody", "td", "tfoot", "th", "thead", "tr"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-charoff",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-charoff",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          var errorArr = validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
            type: "integer",
            negativeOK: true,
            theOnlyGoodUnits: [],
            customGenericValueError: "Should be integer, no units."
          }); // tag has to have "char" attribute:

          if (!node.parent.attribs.some(function (attribObj) {
            return attribObj.attribName === "char";
          })) {
            errorArr.push({
              idxFrom: node.parent.start,
              idxTo: node.parent.end,
              message: "Attribute \"char\" missing.",
              fix: null
            });
          }

          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-charoff"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateCharset(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "charset") {
        // validate the parent
        if (!["a", "link", "script"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-charset",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-charset",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          // validate against the charsets list from IANA:
          // https://www.iana.org/assignments/character-sets/character-sets.xhtml
          // https://www.w3.org/TR/html4/interact/forms.html#adef-charset
          var errorArr = validateString(node.attribValueRaw, node.attribValueStartsAt, {
            canBeCommaSeparated: false,
            noSpaceAfterComma: false,
            quickPermittedValues: [],
            permittedValues: knownCharsets
          });
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-charset"
            }));
          });
        }
      }
    }
  };
}

function validateVoid(node, context, errorArr, originalOpts) {
  //
  // prepare the opts
  //
  var defaults = {
    xhtml: false,
    enforceSiblingAttributes: null
  };

  var opts = _objectSpread2(_objectSpread2({}, defaults), originalOpts); //
  // further validation only applicable to input tags:
  //


  if (opts.xhtml) {
    // XHTML mode - enforcing node.attribName="node.attribName"
    var quotesType = "\"";

    if (node.attribOpeningQuoteAt !== null && context.str[node.attribOpeningQuoteAt] === "'") {
      quotesType = "'";
    } else if (node.attribClosingQuoteAt !== null && context.str[node.attribClosingQuoteAt] === "'") {
      quotesType = "'";
    } // equal might be missing or there might be some rogue whitespace,
    // for example - only value check is not enough


    if (node.attribValueRaw !== node.attribName || context.str.slice(node.attribNameEndsAt, node.attribEnds) !== "=" + quotesType + node.attribName + quotesType) {
      errorArr.push({
        idxFrom: node.attribNameStartsAt,
        idxTo: node.attribNameEndsAt,
        message: "It's XHTML, add value, =\"" + node.attribName + "\".",
        fix: {
          ranges: [[node.attribNameEndsAt, node.attribEnds, "=" + quotesType + node.attribName + quotesType]]
        }
      });
    }
  } else if (node.attribValueRaw !== null) {
    errorArr.push({
      idxFrom: node.attribNameEndsAt,
      idxTo: node.attribEnds,
      message: "Should have no value.",
      fix: {
        ranges: [[node.attribNameEndsAt, node.attribEnds]]
      }
    });
  }

  if (isObj(opts.enforceSiblingAttributes) && Object.keys(opts.enforceSiblingAttributes).length) {
    Object.keys(opts.enforceSiblingAttributes).forEach(function (siblingAttr) {

      if (Array.isArray(node.parent.attribs) && !node.parent.attribs.some(function (attribObj) {
        return attribObj.attribName === siblingAttr;
      })) {
        // parent tag is missing the requested attribute
        errorArr.push({
          idxFrom: node.parent.start,
          idxTo: node.parent.end,
          message: "Should have attribute \"" + siblingAttr + "\".",
          fix: null
        });
      } else if (opts.enforceSiblingAttributes[siblingAttr] && Array.isArray(opts.enforceSiblingAttributes[siblingAttr]) && Array.isArray(node.parent.attribs) && !node.parent.attribs.some(function (attribObj) {
        return attribObj.attribName === siblingAttr && opts.enforceSiblingAttributes[siblingAttr].includes(attribObj.attribValueRaw);
      })) {
        // enforce that, for example, "node.attribName"
        // should be present only on input tags of types
        // "checkbox" or "radio"
        // find out where that "type" attribute is located
        var idxFrom;
        var idxTo;

        for (var i = 0, len = node.parent.attribs.length; i < len; i++) {
          if (node.parent.attribs[i].attribName === siblingAttr) {
            idxFrom = node.parent.attribs[i].attribValueStartsAt;
            idxTo = node.parent.attribs[i].attribValueEndsAt;
            break;
          }
        }

        errorArr.push({
          idxFrom: idxFrom,
          idxTo: idxTo,
          message: "Only tags with " + opts.enforceSiblingAttributes[siblingAttr].map(function (val) {
            return "\"" + val + "\"";
          }).join(" or ") + " attributes can be " + node.attribName + ".",
          fix: null
        });
      }
    });
  }

  return errorArr;
}

function attributeValidateChecked(context, mode) {
  return {
    attribute: function attribute(node) {
      var errorArr = [];

      if (node.attribName === "checked") {
        // validate the parent
        if (node.parent.tagName !== "input") {
          errorArr.push({
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          // validate the value (or absence thereof)
          validateVoid(node, context, errorArr, {
            xhtml: !!mode,
            enforceSiblingAttributes: {
              type: ["checkbox", "radio"]
            }
          });
        } // finally, report gathered errors:


        if (errorArr.length) {
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-checked"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateCite(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "cite") {
        // validate the parent
        if (!["blockquote", "q", "del", "ins"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-cite",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          // Call validation upon the whole attribute's value. Validator includes
          // whitespace checks.
          validateUri(node.attribValueRaw, {
            offset: node.attribValueStartsAt,
            multipleOK: false
          }).forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-cite"
            }));
          });
        }
      }
    }
  };
}

function checkClassOrIdValue(str, originalOpts, errorArr) {
  var defaults = {
    typeName: "class",
    from: 0,
    to: str.length,
    offset: 0
  };

  var opts = _objectSpread2(_objectSpread2({}, defaults), originalOpts);
  var listOfUniqueNames = new Set();
  splitByWhitespace( //
  //
  //
  //
  //
  //
  //
  str, //
  //
  //
  //
  //
  //
  //
  function (_ref) {
    var charFrom = _ref[0],
        charTo = _ref[1];
    // value starts at "from" and ends at "to" // evaluate

    var extractedName = str.slice(charFrom, charTo);

    if (!classNameRegex.test(extractedName)) {
      errorArr.push({
        idxFrom: charFrom,
        idxTo: charTo,
        message: "Wrong " + opts.typeName + " name.",
        fix: null
      });
    } // check for unique-ness


    if (!listOfUniqueNames.has(extractedName)) {
      listOfUniqueNames.add(extractedName);
    } else {
      var deleteFrom = charFrom;
      var deleteTo = charTo;
      var nonWhitespaceCharOnTheRight = right(str, deleteTo);

      if (deleteTo >= opts.to || !nonWhitespaceCharOnTheRight || nonWhitespaceCharOnTheRight > opts.to) {
        deleteFrom = left(str, charFrom) + 1; // +1 because left() stops
        // to the left of the character - if it was without, that first non-
        // whitespace character would have been included
      } else {
        deleteTo = nonWhitespaceCharOnTheRight;
      }

      errorArr.push({
        idxFrom: charFrom,
        idxTo: charTo,
        message: "Duplicate " + opts.typeName + " \"" + extractedName + "\".",
        fix: {
          ranges: [[deleteFrom, deleteTo]]
        }
      });
    }
  }, //
  //
  //
  //
  //
  //
  //
  function (_ref2) {
    var whitespaceFrom = _ref2[0],
        whitespaceTo = _ref2[1];
    return isSingleSpace(str, {
      from: whitespaceFrom,
      to: whitespaceTo,
      offset: opts.offset
    }, errorArr);
  }, //
  //
  //
  //
  //
  //
  //
  opts // whole opts object is being passed further
  );
}

function attributeValidateClass(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "class") {
        // validate the parent
        if (["base", "basefont", "head", "html", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-class",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-class",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
              charStart = _checkForWhitespace.charStart,
              charEnd = _checkForWhitespace.charEnd,
              errorArr = _checkForWhitespace.errorArr;

          if (typeof charStart === "number" && typeof charEnd === "number") {
            checkClassOrIdValue(context.str, {
              typeName: node.attribName,
              from: node.attribValueStartsAt + charStart,
              to: node.attribValueStartsAt + charEnd,
              offset: 0
            }, errorArr // might be mutated, more errors pushed into
            );
          }
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-class"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateClassid$1(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "classid") {
        // validate the parent
        if (node.parent.tagName !== "object") {
          context.report({
            ruleId: "attribute-validate-classid",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          // Call validation upon the whole attribute's value. Validator includes
          // whitespace checks.
          validateUri(node.attribValueRaw, {
            offset: node.attribValueStartsAt,
            multipleOK: false
          }).forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-classid"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateClassid(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "clear") {
        // validate the parent
        if (node.parent.tagName !== "br") {
          context.report({
            ruleId: "attribute-validate-clear",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // beware, the charStart and charEnd are not offset, their "zero" is
        // start of an attribute's value, so if you use them, you need to
        // offset to the true index, you must add "(node.attribValueStartsAt as number)" value


        var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
            charStart = _checkForWhitespace.charStart,
            charEnd = _checkForWhitespace.charEnd,
            errorArr = _checkForWhitespace.errorArr;

        if (typeof charStart === "number" && typeof charEnd === "number" && !["left", "all", "right", "none"].includes(context.str.slice(node.attribValueStartsAt + charStart, node.attribValueStartsAt + charEnd))) {
          errorArr.push({
            idxFrom: node.attribValueStartsAt + charStart,
            idxTo: node.attribValueStartsAt + charEnd,
            message: "Should be: left|all|right|none.",
            fix: null
          });
        }

        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-clear"
          }));
        });
      }
    }
  };
}

function attributeValidateCode(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "code") {
        // validate the parent
        if (node.parent.tagName !== "applet") {
          context.report({
            ruleId: "attribute-validate-code",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-code",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          // only validate the whitespace
          var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt);
              _checkForWhitespace.charStart;
              _checkForWhitespace.charEnd;
              var errorArr = _checkForWhitespace.errorArr;
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-code"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateCodebase(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "codebase") {
        // validate the parent
        if (!["applet", "object"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-codebase",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          validateUri(node.attribValueRaw, {
            offset: node.attribValueStartsAt,
            multipleOK: false
          }).forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-codebase"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateCodetype(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "codetype") {
        // validate the parent
        if (node.parent.tagName !== "object") {
          context.report({
            ruleId: "attribute-validate-codetype",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // check in two parts, first, a quick try, match the most common values only


        var errorArr = validateString(node.attribValueRaw, // value
        node.attribValueStartsAt, // offset
        {
          quickPermittedValues: ["application/javascript", "application/json", "application/x-www-form-urlencoded", "application/xml", "application/zip", "application/pdf", "application/sql", "application/graphql", "application/ld+json", "application/msword", "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "application/vnd.ms-excel", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "application/vnd.ms-powerpoint", "application/vnd.openxmlformats-officedocument.presentationml.presentation", "application/vnd.oasis.opendocument.text", "application/zstd", "audio/mpeg", "audio/ogg", "multipart/form-data", "text/css", "text/html", "text/xml", "text/csv", "text/plain", "image/png", "image/jpeg", "image/gif", "application/vnd.api+json"],
          permittedValues: Object.keys(mimeDb),
          canBeCommaSeparated: false,
          noSpaceAfterComma: false
        }); // HTML attribute accept MIME types as values. Here we reference the given
        // value against all official MIME types, taken from IANA and other sources,
        // https://www.npmjs.com/package/mime-db

        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-codetype"
          }));
        });
      }
    }
  };
}

function attributeValidateColor(context) {
  return {
    attribute: function attribute(node) { // console.log(
      //   `015 attributeValidateColor(): node = ${JSON.stringify(node, null, 4)}`
      // );

      if (node.attribName === "color") {
        // validate the parent
        if (!["basefont", "font"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-color",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-color",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          var errorArr = validateColor(node.attribValueRaw, node.attribValueStartsAt, {
            namedCssLevel1OK: true,
            namedCssLevel2PlusOK: true,
            hexThreeOK: false,
            hexFourOK: false,
            hexSixOK: true,
            hexEightOK: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-color"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateCols(context) {
  return {
    attribute: function attribute(node) { // console.log(
      //   `015 attributeValidateCols(): node = ${JSON.stringify(node, null, 4)}`
      // );

      if (node.attribName === "cols") {
        // validate the parent
        if (!["frameset", "textarea"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-cols",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist

        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          var errorArr = [];

          if (node.parent.tagName === "frameset") {
            errorArr = validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
              whitelistValues: ["*"],
              theOnlyGoodUnits: ["%"],
              badUnits: ["px"],
              noUnitsIsFine: true,
              canBeCommaSeparated: true,
              type: "rational",
              customGenericValueError: "Should be: pixels|%|*."
            });
          } else if (node.parent.tagName === "textarea") {
            // each character must be a digit
            errorArr = validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
              type: "integer",
              theOnlyGoodUnits: [],
              customGenericValueError: "Should be integer, no units."
            });
          }

          if (Array.isArray(errorArr) && errorArr.length) {
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-cols"
              }));
            });
          }
        }
      }
    }
  };
}

function attributeValidateColspan(context) {
  return {
    attribute: function attribute(node) { // console.log(
      //   `015 attributeValidateColspan(): node = ${JSON.stringify(node, null, 4)}`
      // );

      if (node.attribName === "colspan") {
        // validate the parent
        if (!["th", "td"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-colspan",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        }

        var errorArr = validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
          type: "integer",
          theOnlyGoodUnits: [],
          customGenericValueError: "Should be integer, no units."
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-colspan"
          }));
        });
      }
    }
  };
}

function attributeValidateCompact(context, mode) {
  return {
    attribute: function attribute(node) {
      var errorArr = [];

      if (node.attribName === "compact") {
        // validate the parent
        if (!["dir", "dl", "menu", "ol", "ul"].includes(node.parent.tagName)) {
          errorArr.push({
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          // validate the value
          validateVoid(node, context, errorArr, {
            xhtml: !!mode,
            enforceSiblingAttributes: null
          });
        } // finally, report gathered errors:


        if (errorArr.length) {
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-compact"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateContent(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "content") {
        // validate the parent
        if (node.parent.tagName !== "meta") {
          context.report({
            ruleId: "attribute-validate-content",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // only validate the whitespace


        var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt);
            _checkForWhitespace.charStart;
            _checkForWhitespace.charEnd;
            var errorArr = _checkForWhitespace.errorArr;
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-content"
          }));
        });
      }
    }
  };
} // TODO - add more checks from https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta

function attributeValidateCoords(context) {
  return {
    attribute: function attribute(node) { // console.log(
      //   `020 attributeValidateCoords(): node = ${JSON.stringify(node, null, 4)}`
      // );

      if (node.attribName === "coords") {
        // validate the parent
        if (!["area", "a"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-coords",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else { // "coords" values depend on "shape" attribute's value

          if (!Array.isArray(node.parent.attribs) || !node.parent.attribs.length || !node.parent.attribs.some(function (attrObj) {
            return attrObj.attribName === "shape";
          })) {
            // enforce "shape" attribute
            context.report({
              ruleId: "attribute-validate-coords",
              idxFrom: node.parent.start,
              idxTo: node.parent.end,
              message: "Missing \"shape\" attribute.",
              fix: null
            });
          } else {
            // extract "shape" attr's value
            var shapeAttr = node.parent.attribs.filter(function (attrObj) {
              return attrObj.attribName === "shape";
            })[0];
            var enforceCount = null;

            if (shapeAttr.attribValueRaw === "rect") {
              // enforce the value count to be 4
              enforceCount = 4;
            } else if (shapeAttr.attribValueRaw === "circle") {
              // enforce the value count to be 3
              enforceCount = 3;
            } else if (shapeAttr.attribValueRaw === "poly") {
              // enforce the value count to be an even number
              enforceCount = "even";
            }

            var errorArr = validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
              whitelistValues: [],
              theOnlyGoodUnits: [],
              badUnits: [],
              noUnitsIsFine: true,
              canBeCommaSeparated: true,
              enforceCount: enforceCount,
              type: "integer",
              customGenericValueError: "Should be integer, no units."
            });

            if (Array.isArray(errorArr) && errorArr.length) {
              errorArr.forEach(function (errorObj) {
                context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                  ruleId: "attribute-validate-coords"
                }));
              });
            }
          }
        }
      }
    }
  };
}

function attributeValidateData(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "data") {
        // validate the parent
        if (node.parent.tagName !== "object") {
          context.report({
            ruleId: "attribute-validate-data",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          validateUri(node.attribValueRaw, {
            offset: node.attribValueStartsAt,
            multipleOK: false
          }).forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-data"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateDatetime(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "datetime") {
        // validate the parent
        if (!["del", "ins"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-datetime",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // check in two parts, first, a quick try, match the most common values only


        var errorArr = validateString(node.attribValueRaw, // value
        node.attribValueStartsAt, // offset
        {
          quickPermittedValues: [isoDateRegex],
          canBeCommaSeparated: false,
          noSpaceAfterComma: false
        }); // HTML attribute accept MIME types as values. Here we reference the given
        // value against all official MIME types, taken from IANA and other sources,
        // https://www.npmjs.com/package/mime-db

        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-datetime"
          }));
        });
      }
    }
  };
}

function attributeValidateDeclare(context, mode) {
  return {
    attribute: function attribute(node) {
      var errorArr = [];

      if (node.attribName === "declare") {
        // validate the parent
        if (node.parent.tagName !== "object") {
          errorArr.push({
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          // validate the value (or absence thereof)
          validateVoid(node, context, errorArr, {
            xhtml: !!mode,
            enforceSiblingAttributes: null
          });
        } // finally, report gathered errors:


        if (errorArr.length) {
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-declare"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateDefer(context, mode) {
  return {
    attribute: function attribute(node) {
      var errorArr = [];

      if (node.attribName === "defer") {
        // validate the parent
        if (node.parent.tagName !== "script") {
          errorArr.push({
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          // validate the value (or absence thereof)
          validateVoid(node, context, errorArr, {
            xhtml: !!mode,
            enforceSiblingAttributes: null
          });
        } // finally, report gathered errors:


        if (errorArr.length) {
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-defer"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateDir(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "dir") {
        // validate the parent
        if (["applet", "base", "basefont", "br", "frame", "frameset", "iframe", "param", "script"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-dir",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // check in two parts, first, a quick try, match the most common values only


        var errorArr = validateString(node.attribValueRaw, // value
        node.attribValueStartsAt, // offset
        {
          permittedValues: ["ltr", "rtl"],
          canBeCommaSeparated: false
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-dir"
          }));
        });
      }
    }
  };
}

function attributeValidateDisabled(context, mode) {
  return {
    attribute: function attribute(node) {
      var errorArr = [];

      if (node.attribName === "disabled") {
        // validate the parent
        if (!["button", "input", "optgroup", "option", "select", "textarea"].includes(node.parent.tagName)) {
          errorArr.push({
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          // validate the value (or absence thereof)
          validateVoid(node, context, errorArr, {
            xhtml: !!mode,
            enforceSiblingAttributes: null
          });
        } // finally, report gathered errors:


        if (errorArr.length) {
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-disabled"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateEnctype(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "enctype") {
        // validate the parent
        if (node.parent.tagName !== "form") {
          context.report({
            ruleId: "attribute-validate-enctype",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // check in two parts, first, a quick try, match the most common values only


        var errorArr = validateString(node.attribValueRaw, // value
        node.attribValueStartsAt, // offset
        {
          quickPermittedValues: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"],
          permittedValues: Object.keys(mimeDb),
          canBeCommaSeparated: false
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-enctype"
          }));
        });
      }
    }
  };
}

function attributeValidateFace(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "face") {
        // validate the parent
        if (node.parent.tagName !== "font") {
          context.report({
            ruleId: "attribute-validate-face",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // only validate the whitespace


        var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt);
            _checkForWhitespace.charStart;
            _checkForWhitespace.charEnd;
            var errorArr = _checkForWhitespace.errorArr;
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-face"
          }));
        });
      }
    }
  };
} // TODO - add more checks from https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta

function attributeValidateFor(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "for") {
        // validate the parent
        if (node.parent.tagName !== "label") {
          context.report({
            ruleId: "attribute-validate-for",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
                charStart = _checkForWhitespace.charStart,
                charEnd = _checkForWhitespace.charEnd,
                errorArr = _checkForWhitespace.errorArr;

            if (typeof charStart === "number" && typeof charEnd === "number") {
              var extractedValue = node.attribValueRaw.slice(charStart, charEnd);
              var message = "Wrong id name.";
              var fix = null;
              var idxFrom = charStart + node.attribValueStartsAt;
              var idxTo = charEnd + node.attribValueStartsAt;

              if (Number.isInteger(charStart) && !classNameRegex.test(extractedValue)) {
                if (Array.from(extractedValue).some(function (val) {
                  return !val.trim().length;
                })) {
                  message = "Should be one value, no spaces.";
                } else if (extractedValue.includes("#")) {
                  message = "Remove hash.";
                  var firstHashAt = node.attribValueRaw.indexOf("#");
                  fix = {
                    ranges: [[node.attribValueStartsAt + firstHashAt, node.attribValueStartsAt + firstHashAt + 1]]
                  };
                  idxFrom = node.attribValueStartsAt + firstHashAt;
                  idxTo = node.attribValueStartsAt + firstHashAt + 1;
                }

                errorArr.push({
                  ruleId: "attribute-validate-for",
                  idxFrom: idxFrom,
                  idxTo: idxTo,
                  message: message,
                  fix: fix
                });
              }
            }
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-for"
              }));
            });
          }
      }
    }
  };
}

function attributeValidateFrame(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "frame") {
        // validate the parent
        if (node.parent.tagName !== "table") {
          context.report({
            ruleId: "attribute-validate-frame",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // https://www.w3.org/TR/html4/struct/tables.html#adef-frame


        var errorArr = validateString(node.attribValueRaw, // value
        node.attribValueStartsAt, // offset
        {
          permittedValues: ["void", "above", "below", "hsides", "lhs", "rhs", "vsides", "box", "border" // All four sides.
          ],
          canBeCommaSeparated: false
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-frame"
          }));
        });
      }
    }
  };
}

function attributeValidateFrameborder(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "frameborder") {
        // validate the parent
        if (!["frame", "iframe"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-frameborder",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // https://www.w3.org/TR/html4/present/frames.html#adef-frameborder


        var errorArr = validateString(node.attribValueRaw, // value
        node.attribValueStartsAt, // offset
        {
          permittedValues: ["0", "1"],
          canBeCommaSeparated: false
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-frameborder"
          }));
        });
      }
    }
  };
}

function attributeValidateHeaders(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "headers") {
        // validate the parent
        if (!["td", "th"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-headers",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
                charStart = _checkForWhitespace.charStart,
                charEnd = _checkForWhitespace.charEnd,
                errorArr = _checkForWhitespace.errorArr;
            checkClassOrIdValue(context.str, {
              typeName: "id",
              from: node.attribValueStartsAt + charStart,
              to: node.attribValueStartsAt + charEnd,
              offset: 0
            }, errorArr // might be mutated, more errors pushed into
            );
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-headers"
              }));
            });
          }
      }
    }
  };
}

function attributeValidateHeight(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "height") {
        // validate the parent
        if (!["iframe", "td", "th", "img", "object", "applet"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-height",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        }

        var errorArr = validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
          badUnits: ["px"],
          theOnlyGoodUnits: ["%"],
          noUnitsIsFine: true,
          customGenericValueError: "Should be \"pixels|%\"."
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-height"
          }));
        });
      }
    }
  };
}

function attributeValidateHref(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "href") {
        // validate the parent
        if (!["a", "area", "link", "base"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-href",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          validateUri(node.attribValueRaw, {
            offset: node.attribValueStartsAt,
            multipleOK: false
          }).forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-href"
            }));
          });
        }
      }
    }
  };
}

/**
 * is-language-code
 * Is given string a language code (as per IANA)
 * Version: 3.0.8
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/is-language-code/
 */
var languageJson = ["aa", "aaa", "aab", "aac", "aad", "aae", "aaf", "aag", "aah", "aai", "aak", "aal", "aam", "aan", "aao", "aap", "aaq", "aas", "aat", "aau", "aav", "aaw", "aax", "aaz", "ab", "aba", "abb", "abc", "abd", "abe", "abf", "abg", "abh", "abi", "abj", "abl", "abm", "abn", "abo", "abp", "abq", "abr", "abs", "abt", "abu", "abv", "abw", "abx", "aby", "abz", "aca", "acb", "acd", "ace", "acf", "ach", "aci", "ack", "acl", "acm", "acn", "acp", "acq", "acr", "acs", "act", "acu", "acv", "acw", "acx", "acy", "acz", "ada", "adb", "add", "ade", "adf", "adg", "adh", "adi", "adj", "adl", "adn", "ado", "adp", "adq", "adr", "ads", "adt", "adu", "adw", "adx", "ady", "adz", "ae", "aea", "aeb", "aec", "aed", "aee", "aek", "ael", "aem", "aen", "aeq", "aer", "aes", "aeu", "aew", "aey", "aez", "af", "afa", "afb", "afd", "afe", "afg", "afh", "afi", "afk", "afn", "afo", "afp", "afs", "aft", "afu", "afz", "aga", "agb", "agc", "agd", "age", "agf", "agg", "agh", "agi", "agj", "agk", "agl", "agm", "agn", "ago", "agp", "agq", "agr", "ags", "agt", "agu", "agv", "agw", "agx", "agy", "agz", "aha", "ahb", "ahg", "ahh", "ahi", "ahk", "ahl", "ahm", "ahn", "aho", "ahp", "ahr", "ahs", "aht", "aia", "aib", "aic", "aid", "aie", "aif", "aig", "aih", "aii", "aij", "aik", "ail", "aim", "ain", "aio", "aip", "aiq", "air", "ais", "ait", "aiw", "aix", "aiy", "aja", "ajg", "aji", "ajn", "ajp", "ajt", "aju", "ajw", "ajz", "ak", "akb", "akc", "akd", "ake", "akf", "akg", "akh", "aki", "akj", "akk", "akl", "akm", "ako", "akp", "akq", "akr", "aks", "akt", "aku", "akv", "akw", "akx", "aky", "akz", "ala", "alc", "ald", "ale", "alf", "alg", "alh", "ali", "alj", "alk", "all", "alm", "aln", "alo", "alp", "alq", "alr", "als", "alt", "alu", "alv", "alw", "alx", "aly", "alz", "am", "ama", "amb", "amc", "ame", "amf", "amg", "ami", "amj", "amk", "aml", "amm", "amn", "amo", "amp", "amq", "amr", "ams", "amt", "amu", "amv", "amw", "amx", "amy", "amz", "an", "ana", "anb", "anc", "and", "ane", "anf", "ang", "anh", "ani", "anj", "ank", "anl", "anm", "ann", "ano", "anp", "anq", "anr", "ans", "ant", "anu", "anv", "anw", "anx", "any", "anz", "aoa", "aob", "aoc", "aod", "aoe", "aof", "aog", "aoh", "aoi", "aoj", "aok", "aol", "aom", "aon", "aor", "aos", "aot", "aou", "aox", "aoz", "apa", "apb", "apc", "apd", "ape", "apf", "apg", "aph", "api", "apj", "apk", "apl", "apm", "apn", "apo", "app", "apq", "apr", "aps", "apt", "apu", "apv", "apw", "apx", "apy", "apz", "aqa", "aqc", "aqd", "aqg", "aql", "aqm", "aqn", "aqp", "aqr", "aqt", "aqz", "ar", "arb", "arc", "ard", "are", "arh", "ari", "arj", "ark", "arl", "arn", "aro", "arp", "arq", "arr", "ars", "art", "aru", "arv", "arw", "arx", "ary", "arz", "as", "asa", "asb", "asc", "asd", "ase", "asf", "asg", "ash", "asi", "asj", "ask", "asl", "asn", "aso", "asp", "asq", "asr", "ass", "ast", "asu", "asv", "asw", "asx", "asy", "asz", "ata", "atb", "atc", "atd", "ate", "atg", "ath", "ati", "atj", "atk", "atl", "atm", "atn", "ato", "atp", "atq", "atr", "ats", "att", "atu", "atv", "atw", "atx", "aty", "atz", "aua", "aub", "auc", "aud", "aue", "auf", "aug", "auh", "aui", "auj", "auk", "aul", "aum", "aun", "auo", "aup", "auq", "aur", "aus", "aut", "auu", "auw", "aux", "auy", "auz", "av", "avb", "avd", "avi", "avk", "avl", "avm", "avn", "avo", "avs", "avt", "avu", "avv", "awa", "awb", "awc", "awd", "awe", "awg", "awh", "awi", "awk", "awm", "awn", "awo", "awr", "aws", "awt", "awu", "awv", "aww", "awx", "awy", "axb", "axe", "axg", "axk", "axl", "axm", "axx", "ay", "aya", "ayb", "ayc", "ayd", "aye", "ayg", "ayh", "ayi", "ayk", "ayl", "ayn", "ayo", "ayp", "ayq", "ayr", "ays", "ayt", "ayu", "ayx", "ayy", "ayz", "az", "aza", "azb", "azc", "azd", "azg", "azj", "azm", "azn", "azo", "azt", "azz", "ba", "baa", "bab", "bac", "bad", "bae", "baf", "bag", "bah", "bai", "baj", "bal", "ban", "bao", "bap", "bar", "bas", "bat", "bau", "bav", "baw", "bax", "bay", "baz", "bba", "bbb", "bbc", "bbd", "bbe", "bbf", "bbg", "bbh", "bbi", "bbj", "bbk", "bbl", "bbm", "bbn", "bbo", "bbp", "bbq", "bbr", "bbs", "bbt", "bbu", "bbv", "bbw", "bbx", "bby", "bbz", "bca", "bcb", "bcc", "bcd", "bce", "bcf", "bcg", "bch", "bci", "bcj", "bck", "bcl", "bcm", "bcn", "bco", "bcp", "bcq", "bcr", "bcs", "bct", "bcu", "bcv", "bcw", "bcy", "bcz", "bda", "bdb", "bdc", "bdd", "bde", "bdf", "bdg", "bdh", "bdi", "bdj", "bdk", "bdl", "bdm", "bdn", "bdo", "bdp", "bdq", "bdr", "bds", "bdt", "bdu", "bdv", "bdw", "bdx", "bdy", "bdz", "be", "bea", "beb", "bec", "bed", "bee", "bef", "beg", "beh", "bei", "bej", "bek", "bem", "beo", "bep", "beq", "ber", "bes", "bet", "beu", "bev", "bew", "bex", "bey", "bez", "bfa", "bfb", "bfc", "bfd", "bfe", "bff", "bfg", "bfh", "bfi", "bfj", "bfk", "bfl", "bfm", "bfn", "bfo", "bfp", "bfq", "bfr", "bfs", "bft", "bfu", "bfw", "bfx", "bfy", "bfz", "bg", "bga", "bgb", "bgc", "bgd", "bge", "bgf", "bgg", "bgi", "bgj", "bgk", "bgl", "bgm", "bgn", "bgo", "bgp", "bgq", "bgr", "bgs", "bgt", "bgu", "bgv", "bgw", "bgx", "bgy", "bgz", "bh", "bha", "bhb", "bhc", "bhd", "bhe", "bhf", "bhg", "bhh", "bhi", "bhj", "bhk", "bhl", "bhm", "bhn", "bho", "bhp", "bhq", "bhr", "bhs", "bht", "bhu", "bhv", "bhw", "bhx", "bhy", "bhz", "bi", "bia", "bib", "bic", "bid", "bie", "bif", "big", "bij", "bik", "bil", "bim", "bin", "bio", "bip", "biq", "bir", "bit", "biu", "biv", "biw", "bix", "biy", "biz", "bja", "bjb", "bjc", "bjd", "bje", "bjf", "bjg", "bjh", "bji", "bjj", "bjk", "bjl", "bjm", "bjn", "bjo", "bjp", "bjq", "bjr", "bjs", "bjt", "bju", "bjv", "bjw", "bjx", "bjy", "bjz", "bka", "bkb", "bkc", "bkd", "bkf", "bkg", "bkh", "bki", "bkj", "bkk", "bkl", "bkm", "bkn", "bko", "bkp", "bkq", "bkr", "bks", "bkt", "bku", "bkv", "bkw", "bkx", "bky", "bkz", "bla", "blb", "blc", "bld", "ble", "blf", "blg", "blh", "bli", "blj", "blk", "bll", "blm", "bln", "blo", "blp", "blq", "blr", "bls", "blt", "blv", "blw", "blx", "bly", "blz", "bm", "bma", "bmb", "bmc", "bmd", "bme", "bmf", "bmg", "bmh", "bmi", "bmj", "bmk", "bml", "bmm", "bmn", "bmo", "bmp", "bmq", "bmr", "bms", "bmt", "bmu", "bmv", "bmw", "bmx", "bmy", "bmz", "bn", "bna", "bnb", "bnc", "bnd", "bne", "bnf", "bng", "bni", "bnj", "bnk", "bnl", "bnm", "bnn", "bno", "bnp", "bnq", "bnr", "bns", "bnt", "bnu", "bnv", "bnw", "bnx", "bny", "bnz", "bo", "boa", "bob", "boe", "bof", "bog", "boh", "boi", "boj", "bok", "bol", "bom", "bon", "boo", "bop", "boq", "bor", "bot", "bou", "bov", "bow", "box", "boy", "boz", "bpa", "bpb", "bpd", "bpg", "bph", "bpi", "bpj", "bpk", "bpl", "bpm", "bpn", "bpo", "bpp", "bpq", "bpr", "bps", "bpt", "bpu", "bpv", "bpw", "bpx", "bpy", "bpz", "bqa", "bqb", "bqc", "bqd", "bqf", "bqg", "bqh", "bqi", "bqj", "bqk", "bql", "bqm", "bqn", "bqo", "bqp", "bqq", "bqr", "bqs", "bqt", "bqu", "bqv", "bqw", "bqx", "bqy", "bqz", "br", "bra", "brb", "brc", "brd", "brf", "brg", "brh", "bri", "brj", "brk", "brl", "brm", "brn", "bro", "brp", "brq", "brr", "brs", "brt", "bru", "brv", "brw", "brx", "bry", "brz", "bs", "bsa", "bsb", "bsc", "bse", "bsf", "bsg", "bsh", "bsi", "bsj", "bsk", "bsl", "bsm", "bsn", "bso", "bsp", "bsq", "bsr", "bss", "bst", "bsu", "bsv", "bsw", "bsx", "bsy", "bta", "btb", "btc", "btd", "bte", "btf", "btg", "bth", "bti", "btj", "btk", "btl", "btm", "btn", "bto", "btp", "btq", "btr", "bts", "btt", "btu", "btv", "btw", "btx", "bty", "btz", "bua", "bub", "buc", "bud", "bue", "buf", "bug", "buh", "bui", "buj", "buk", "bum", "bun", "buo", "bup", "buq", "bus", "but", "buu", "buv", "buw", "bux", "buy", "buz", "bva", "bvb", "bvc", "bvd", "bve", "bvf", "bvg", "bvh", "bvi", "bvj", "bvk", "bvl", "bvm", "bvn", "bvo", "bvp", "bvq", "bvr", "bvt", "bvu", "bvv", "bvw", "bvx", "bvy", "bvz", "bwa", "bwb", "bwc", "bwd", "bwe", "bwf", "bwg", "bwh", "bwi", "bwj", "bwk", "bwl", "bwm", "bwn", "bwo", "bwp", "bwq", "bwr", "bws", "bwt", "bwu", "bww", "bwx", "bwy", "bwz", "bxa", "bxb", "bxc", "bxd", "bxe", "bxf", "bxg", "bxh", "bxi", "bxj", "bxk", "bxl", "bxm", "bxn", "bxo", "bxp", "bxq", "bxr", "bxs", "bxu", "bxv", "bxw", "bxx", "bxz", "bya", "byb", "byc", "byd", "bye", "byf", "byg", "byh", "byi", "byj", "byk", "byl", "bym", "byn", "byo", "byp", "byq", "byr", "bys", "byt", "byv", "byw", "byx", "byy", "byz", "bza", "bzb", "bzc", "bzd", "bze", "bzf", "bzg", "bzh", "bzi", "bzj", "bzk", "bzl", "bzm", "bzn", "bzo", "bzp", "bzq", "bzr", "bzs", "bzt", "bzu", "bzv", "bzw", "bzx", "bzy", "bzz", "ca", "caa", "cab", "cac", "cad", "cae", "caf", "cag", "cah", "cai", "caj", "cak", "cal", "cam", "can", "cao", "cap", "caq", "car", "cas", "cau", "cav", "caw", "cax", "cay", "caz", "cba", "cbb", "cbc", "cbd", "cbe", "cbg", "cbh", "cbi", "cbj", "cbk", "cbl", "cbn", "cbo", "cbq", "cbr", "cbs", "cbt", "cbu", "cbv", "cbw", "cby", "cca", "ccc", "ccd", "cce", "ccg", "cch", "ccj", "ccl", "ccm", "ccn", "cco", "ccp", "ccq", "ccr", "ccs", "cda", "cdc", "cdd", "cde", "cdf", "cdg", "cdh", "cdi", "cdj", "cdm", "cdn", "cdo", "cdr", "cds", "cdy", "cdz", "ce", "cea", "ceb", "ceg", "cek", "cel", "cen", "cet", "cey", "cfa", "cfd", "cfg", "cfm", "cga", "cgc", "cgg", "cgk", "ch", "chb", "chc", "chd", "chf", "chg", "chh", "chj", "chk", "chl", "chm", "chn", "cho", "chp", "chq", "chr", "cht", "chw", "chx", "chy", "chz", "cia", "cib", "cic", "cid", "cie", "cih", "cik", "cim", "cin", "cip", "cir", "ciw", "ciy", "cja", "cje", "cjh", "cji", "cjk", "cjm", "cjn", "cjo", "cjp", "cjr", "cjs", "cjv", "cjy", "cka", "ckb", "ckh", "ckl", "ckn", "cko", "ckq", "ckr", "cks", "ckt", "cku", "ckv", "ckx", "cky", "ckz", "cla", "clc", "cld", "cle", "clh", "cli", "clj", "clk", "cll", "clm", "clo", "clt", "clu", "clw", "cly", "cma", "cmc", "cme", "cmg", "cmi", "cmk", "cml", "cmm", "cmn", "cmo", "cmr", "cms", "cmt", "cna", "cnb", "cnc", "cng", "cnh", "cni", "cnk", "cnl", "cno", "cnr", "cns", "cnt", "cnu", "cnw", "cnx", "co", "coa", "cob", "coc", "cod", "coe", "cof", "cog", "coh", "coj", "cok", "col", "com", "con", "coo", "cop", "coq", "cot", "cou", "cov", "cow", "cox", "coy", "coz", "cpa", "cpb", "cpc", "cpe", "cpf", "cpg", "cpi", "cpn", "cpo", "cpp", "cps", "cpu", "cpx", "cpy", "cqd", "cqu", "cr", "cra", "crb", "crc", "crd", "crf", "crg", "crh", "cri", "crj", "crk", "crl", "crm", "crn", "cro", "crp", "crq", "crr", "crs", "crt", "crv", "crw", "crx", "cry", "crz", "cs", "csa", "csb", "csc", "csd", "cse", "csf", "csg", "csh", "csi", "csj", "csk", "csl", "csm", "csn", "cso", "csq", "csr", "css", "cst", "csu", "csv", "csw", "csy", "csz", "cta", "ctc", "ctd", "cte", "ctg", "cth", "ctl", "ctm", "ctn", "cto", "ctp", "cts", "ctt", "ctu", "ctz", "cu", "cua", "cub", "cuc", "cug", "cuh", "cui", "cuj", "cuk", "cul", "cum", "cuo", "cup", "cuq", "cur", "cus", "cut", "cuu", "cuv", "cuw", "cux", "cuy", "cv", "cvg", "cvn", "cwa", "cwb", "cwd", "cwe", "cwg", "cwt", "cy", "cya", "cyb", "cyo", "czh", "czk", "czn", "czo", "czt", "da", "daa", "dac", "dad", "dae", "daf", "dag", "dah", "dai", "daj", "dak", "dal", "dam", "dao", "dap", "daq", "dar", "das", "dau", "dav", "daw", "dax", "day", "daz", "dba", "dbb", "dbd", "dbe", "dbf", "dbg", "dbi", "dbj", "dbl", "dbm", "dbn", "dbo", "dbp", "dbq", "dbr", "dbt", "dbu", "dbv", "dbw", "dby", "dcc", "dcr", "dda", "ddd", "dde", "ddg", "ddi", "ddj", "ddn", "ddo", "ddr", "dds", "ddw", "de", "dec", "ded", "dee", "def", "deg", "deh", "dei", "dek", "del", "dem", "den", "dep", "deq", "der", "des", "dev", "dez", "dga", "dgb", "dgc", "dgd", "dge", "dgg", "dgh", "dgi", "dgk", "dgl", "dgn", "dgo", "dgr", "dgs", "dgt", "dgu", "dgw", "dgx", "dgz", "dha", "dhd", "dhg", "dhi", "dhl", "dhm", "dhn", "dho", "dhr", "dhs", "dhu", "dhv", "dhw", "dhx", "dia", "dib", "dic", "did", "dif", "dig", "dih", "dii", "dij", "dik", "dil", "dim", "din", "dio", "dip", "diq", "dir", "dis", "dit", "diu", "diw", "dix", "diy", "diz", "dja", "djb", "djc", "djd", "dje", "djf", "dji", "djj", "djk", "djl", "djm", "djn", "djo", "djr", "dju", "djw", "dka", "dkk", "dkl", "dkr", "dks", "dkx", "dlg", "dlk", "dlm", "dln", "dma", "dmb", "dmc", "dmd", "dme", "dmg", "dmk", "dml", "dmm", "dmn", "dmo", "dmr", "dms", "dmu", "dmv", "dmw", "dmx", "dmy", "dna", "dnd", "dne", "dng", "dni", "dnj", "dnk", "dnn", "dno", "dnr", "dnt", "dnu", "dnv", "dnw", "dny", "doa", "dob", "doc", "doe", "dof", "doh", "doi", "dok", "dol", "don", "doo", "dop", "doq", "dor", "dos", "dot", "dov", "dow", "dox", "doy", "doz", "dpp", "dra", "drb", "drc", "drd", "dre", "drg", "drh", "dri", "drl", "drn", "dro", "drq", "drr", "drs", "drt", "dru", "drw", "dry", "dsb", "dse", "dsh", "dsi", "dsl", "dsn", "dso", "dsq", "dta", "dtb", "dtd", "dth", "dti", "dtk", "dtm", "dtn", "dto", "dtp", "dtr", "dts", "dtt", "dtu", "dty", "dua", "dub", "duc", "dud", "due", "duf", "dug", "duh", "dui", "duj", "duk", "dul", "dum", "dun", "duo", "dup", "duq", "dur", "dus", "duu", "duv", "duw", "dux", "duy", "duz", "dv", "dva", "dwa", "dwl", "dwr", "dws", "dwu", "dww", "dwy", "dwz", "dya", "dyb", "dyd", "dyg", "dyi", "dym", "dyn", "dyo", "dyu", "dyy", "dz", "dza", "dzd", "dze", "dzg", "dzl", "dzn", "eaa", "ebg", "ebk", "ebo", "ebr", "ebu", "ecr", "ecs", "ecy", "ee", "eee", "efa", "efe", "efi", "ega", "egl", "ego", "egx", "egy", "ehu", "eip", "eit", "eiv", "eja", "eka", "ekc", "eke", "ekg", "eki", "ekk", "ekl", "ekm", "eko", "ekp", "ekr", "eky", "el", "ele", "elh", "eli", "elk", "elm", "elo", "elp", "elu", "elx", "ema", "emb", "eme", "emg", "emi", "emk", "emm", "emn", "emo", "emp", "ems", "emu", "emw", "emx", "emy", "en", "ena", "enb", "enc", "end", "enf", "enh", "enl", "enm", "enn", "eno", "enq", "enr", "enu", "env", "enw", "enx", "eo", "eot", "epi", "era", "erg", "erh", "eri", "erk", "ero", "err", "ers", "ert", "erw", "es", "ese", "esg", "esh", "esi", "esk", "esl", "esm", "esn", "eso", "esq", "ess", "esu", "esx", "esy", "et", "etb", "etc", "eth", "etn", "eto", "etr", "ets", "ett", "etu", "etx", "etz", "eu", "euq", "eve", "evh", "evn", "ewo", "ext", "eya", "eyo", "eza", "eze", "fa", "faa", "fab", "fad", "faf", "fag", "fah", "fai", "faj", "fak", "fal", "fam", "fan", "fap", "far", "fat", "fau", "fax", "fay", "faz", "fbl", "fcs", "fer", "ff", "ffi", "ffm", "fgr", "fi", "fia", "fie", "fil", "fip", "fir", "fit", "fiu", "fiw", "fj", "fkk", "fkv", "fla", "flh", "fli", "fll", "fln", "flr", "fly", "fmp", "fmu", "fnb", "fng", "fni", "fo", "fod", "foi", "fom", "fon", "for", "fos", "fox", "fpe", "fqs", "fr", "frc", "frd", "frk", "frm", "fro", "frp", "frq", "frr", "frs", "frt", "fse", "fsl", "fss", "fub", "fuc", "fud", "fue", "fuf", "fuh", "fui", "fuj", "fum", "fun", "fuq", "fur", "fut", "fuu", "fuv", "fuy", "fvr", "fwa", "fwe", "fy", "ga", "gaa", "gab", "gac", "gad", "gae", "gaf", "gag", "gah", "gai", "gaj", "gak", "gal", "gam", "gan", "gao", "gap", "gaq", "gar", "gas", "gat", "gau", "gav", "gaw", "gax", "gay", "gaz", "gba", "gbb", "gbc", "gbd", "gbe", "gbf", "gbg", "gbh", "gbi", "gbj", "gbk", "gbl", "gbm", "gbn", "gbo", "gbp", "gbq", "gbr", "gbs", "gbu", "gbv", "gbw", "gbx", "gby", "gbz", "gcc", "gcd", "gce", "gcf", "gcl", "gcn", "gcr", "gct", "gd", "gda", "gdb", "gdc", "gdd", "gde", "gdf", "gdg", "gdh", "gdi", "gdj", "gdk", "gdl", "gdm", "gdn", "gdo", "gdq", "gdr", "gds", "gdt", "gdu", "gdx", "gea", "geb", "gec", "ged", "geg", "geh", "gei", "gej", "gek", "gel", "gem", "geq", "ges", "gev", "gew", "gex", "gey", "gez", "gfk", "gft", "gfx", "gga", "ggb", "ggd", "gge", "ggg", "ggk", "ggl", "ggn", "ggo", "ggr", "ggt", "ggu", "ggw", "gha", "ghc", "ghe", "ghh", "ghk", "ghl", "ghn", "gho", "ghr", "ghs", "ght", "gia", "gib", "gic", "gid", "gie", "gig", "gih", "gil", "gim", "gin", "gio", "gip", "giq", "gir", "gis", "git", "giu", "giw", "gix", "giy", "giz", "gji", "gjk", "gjm", "gjn", "gjr", "gju", "gka", "gkd", "gke", "gkn", "gko", "gkp", "gku", "gl", "glc", "gld", "glh", "gli", "glj", "glk", "gll", "glo", "glr", "glu", "glw", "gly", "gma", "gmb", "gmd", "gme", "gmg", "gmh", "gml", "gmm", "gmn", "gmq", "gmu", "gmv", "gmw", "gmx", "gmy", "gmz", "gn", "gna", "gnb", "gnc", "gnd", "gne", "gng", "gnh", "gni", "gnj", "gnk", "gnl", "gnm", "gnn", "gno", "gnq", "gnr", "gnt", "gnu", "gnw", "gnz", "goa", "gob", "goc", "god", "goe", "gof", "gog", "goh", "goi", "goj", "gok", "gol", "gom", "gon", "goo", "gop", "goq", "gor", "gos", "got", "gou", "gow", "gox", "goy", "goz", "gpa", "gpe", "gpn", "gqa", "gqi", "gqn", "gqr", "gqu", "gra", "grb", "grc", "grd", "grg", "grh", "gri", "grj", "grk", "grm", "gro", "grq", "grr", "grs", "grt", "gru", "grv", "grw", "grx", "gry", "grz", "gse", "gsg", "gsl", "gsm", "gsn", "gso", "gsp", "gss", "gsw", "gta", "gti", "gtu", "gu", "gua", "gub", "guc", "gud", "gue", "guf", "gug", "guh", "gui", "guk", "gul", "gum", "gun", "guo", "gup", "guq", "gur", "gus", "gut", "guu", "guv", "guw", "gux", "guz", "gv", "gva", "gvc", "gve", "gvf", "gvj", "gvl", "gvm", "gvn", "gvo", "gvp", "gvr", "gvs", "gvy", "gwa", "gwb", "gwc", "gwd", "gwe", "gwf", "gwg", "gwi", "gwj", "gwm", "gwn", "gwr", "gwt", "gwu", "gww", "gwx", "gxx", "gya", "gyb", "gyd", "gye", "gyf", "gyg", "gyi", "gyl", "gym", "gyn", "gyo", "gyr", "gyy", "gza", "gzi", "gzn", "ha", "haa", "hab", "hac", "had", "hae", "haf", "hag", "hah", "hai", "haj", "hak", "hal", "ham", "han", "hao", "hap", "haq", "har", "has", "hav", "haw", "hax", "hay", "haz", "hba", "hbb", "hbn", "hbo", "hbu", "hca", "hch", "hdn", "hds", "hdy", "he", "hea", "hed", "heg", "heh", "hei", "hem", "hgm", "hgw", "hhi", "hhr", "hhy", "hi", "hia", "hib", "hid", "hif", "hig", "hih", "hii", "hij", "hik", "hil", "him", "hio", "hir", "hit", "hiw", "hix", "hji", "hka", "hke", "hkk", "hkn", "hks", "hla", "hlb", "hld", "hle", "hlt", "hlu", "hma", "hmb", "hmc", "hmd", "hme", "hmf", "hmg", "hmh", "hmi", "hmj", "hmk", "hml", "hmm", "hmn", "hmp", "hmq", "hmr", "hms", "hmt", "hmu", "hmv", "hmw", "hmx", "hmy", "hmz", "hna", "hnd", "hne", "hnh", "hni", "hnj", "hnn", "hno", "hns", "hnu", "ho", "hoa", "hob", "hoc", "hod", "hoe", "hoh", "hoi", "hoj", "hok", "hol", "hom", "hoo", "hop", "hor", "hos", "hot", "hov", "how", "hoy", "hoz", "hpo", "hps", "hr", "hra", "hrc", "hre", "hrk", "hrm", "hro", "hrp", "hrr", "hrt", "hru", "hrw", "hrx", "hrz", "hsb", "hsh", "hsl", "hsn", "hss", "ht", "hti", "hto", "hts", "htu", "htx", "hu", "hub", "huc", "hud", "hue", "huf", "hug", "huh", "hui", "huj", "huk", "hul", "hum", "huo", "hup", "huq", "hur", "hus", "hut", "huu", "huv", "huw", "hux", "huy", "huz", "hvc", "hve", "hvk", "hvn", "hvv", "hwa", "hwc", "hwo", "hy", "hya", "hyw", "hyx", "hz", "ia", "iai", "ian", "iap", "iar", "iba", "ibb", "ibd", "ibe", "ibg", "ibh", "ibi", "ibl", "ibm", "ibn", "ibr", "ibu", "iby", "ica", "ich", "icl", "icr", "id", "ida", "idb", "idc", "idd", "ide", "idi", "idr", "ids", "idt", "idu", "ie", "ifa", "ifb", "ife", "iff", "ifk", "ifm", "ifu", "ify", "ig", "igb", "ige", "igg", "igl", "igm", "ign", "igo", "igs", "igw", "ihb", "ihi", "ihp", "ihw", "ii", "iin", "iir", "ijc", "ije", "ijj", "ijn", "ijo", "ijs", "ik", "ike", "iki", "ikk", "ikl", "iko", "ikp", "ikr", "iks", "ikt", "ikv", "ikw", "ikx", "ikz", "ila", "ilb", "ilg", "ili", "ilk", "ill", "ilm", "ilo", "ilp", "ils", "ilu", "ilv", "ilw", "ima", "ime", "imi", "iml", "imn", "imo", "imr", "ims", "imy", "in", "inb", "inc", "ine", "ing", "inh", "inj", "inl", "inm", "inn", "ino", "inp", "ins", "int", "inz", "io", "ior", "iou", "iow", "ipi", "ipo", "iqu", "iqw", "ira", "ire", "irh", "iri", "irk", "irn", "iro", "irr", "iru", "irx", "iry", "is", "isa", "isc", "isd", "ise", "isg", "ish", "isi", "isk", "ism", "isn", "iso", "isr", "ist", "isu", "it", "itb", "itc", "itd", "ite", "iti", "itk", "itl", "itm", "ito", "itr", "its", "itt", "itv", "itw", "itx", "ity", "itz", "iu", "ium", "ivb", "ivv", "iw", "iwk", "iwm", "iwo", "iws", "ixc", "ixl", "iya", "iyo", "iyx", "izh", "izi", "izr", "izz", "ja", "jaa", "jab", "jac", "jad", "jae", "jaf", "jah", "jaj", "jak", "jal", "jam", "jan", "jao", "jaq", "jar", "jas", "jat", "jau", "jax", "jay", "jaz", "jbe", "jbi", "jbj", "jbk", "jbn", "jbo", "jbr", "jbt", "jbu", "jbw", "jcs", "jct", "jda", "jdg", "jdt", "jeb", "jee", "jeg", "jeh", "jei", "jek", "jel", "jen", "jer", "jet", "jeu", "jgb", "jge", "jgk", "jgo", "jhi", "jhs", "ji", "jia", "jib", "jic", "jid", "jie", "jig", "jih", "jii", "jil", "jim", "jio", "jiq", "jit", "jiu", "jiv", "jiy", "jje", "jjr", "jka", "jkm", "jko", "jkp", "jkr", "jku", "jle", "jls", "jma", "jmb", "jmc", "jmd", "jmi", "jml", "jmn", "jmr", "jms", "jmw", "jmx", "jna", "jnd", "jng", "jni", "jnj", "jnl", "jns", "job", "jod", "jog", "jor", "jos", "jow", "jpa", "jpr", "jpx", "jqr", "jra", "jrb", "jrr", "jrt", "jru", "jsl", "jua", "jub", "juc", "jud", "juh", "jui", "juk", "jul", "jum", "jun", "juo", "jup", "jur", "jus", "jut", "juu", "juw", "juy", "jv", "jvd", "jvn", "jw", "jwi", "jya", "jye", "jyy", "ka", "kaa", "kab", "kac", "kad", "kae", "kaf", "kag", "kah", "kai", "kaj", "kak", "kam", "kao", "kap", "kaq", "kar", "kav", "kaw", "kax", "kay", "kba", "kbb", "kbc", "kbd", "kbe", "kbf", "kbg", "kbh", "kbi", "kbj", "kbk", "kbl", "kbm", "kbn", "kbo", "kbp", "kbq", "kbr", "kbs", "kbt", "kbu", "kbv", "kbw", "kbx", "kby", "kbz", "kca", "kcb", "kcc", "kcd", "kce", "kcf", "kcg", "kch", "kci", "kcj", "kck", "kcl", "kcm", "kcn", "kco", "kcp", "kcq", "kcr", "kcs", "kct", "kcu", "kcv", "kcw", "kcx", "kcy", "kcz", "kda", "kdc", "kdd", "kde", "kdf", "kdg", "kdh", "kdi", "kdj", "kdk", "kdl", "kdm", "kdn", "kdo", "kdp", "kdq", "kdr", "kdt", "kdu", "kdv", "kdw", "kdx", "kdy", "kdz", "kea", "keb", "kec", "ked", "kee", "kef", "keg", "keh", "kei", "kej", "kek", "kel", "kem", "ken", "keo", "kep", "keq", "ker", "kes", "ket", "keu", "kev", "kew", "kex", "key", "kez", "kfa", "kfb", "kfc", "kfd", "kfe", "kff", "kfg", "kfh", "kfi", "kfj", "kfk", "kfl", "kfm", "kfn", "kfo", "kfp", "kfq", "kfr", "kfs", "kft", "kfu", "kfv", "kfw", "kfx", "kfy", "kfz", "kg", "kga", "kgb", "kgc", "kgd", "kge", "kgf", "kgg", "kgh", "kgi", "kgj", "kgk", "kgl", "kgm", "kgn", "kgo", "kgp", "kgq", "kgr", "kgs", "kgt", "kgu", "kgv", "kgw", "kgx", "kgy", "kha", "khb", "khc", "khd", "khe", "khf", "khg", "khh", "khi", "khj", "khk", "khl", "khn", "kho", "khp", "khq", "khr", "khs", "kht", "khu", "khv", "khw", "khx", "khy", "khz", "ki", "kia", "kib", "kic", "kid", "kie", "kif", "kig", "kih", "kii", "kij", "kil", "kim", "kio", "kip", "kiq", "kis", "kit", "kiu", "kiv", "kiw", "kix", "kiy", "kiz", "kj", "kja", "kjb", "kjc", "kjd", "kje", "kjf", "kjg", "kjh", "kji", "kjj", "kjk", "kjl", "kjm", "kjn", "kjo", "kjp", "kjq", "kjr", "kjs", "kjt", "kju", "kjv", "kjx", "kjy", "kjz", "kk", "kka", "kkb", "kkc", "kkd", "kke", "kkf", "kkg", "kkh", "kki", "kkj", "kkk", "kkl", "kkm", "kkn", "kko", "kkp", "kkq", "kkr", "kks", "kkt", "kku", "kkv", "kkw", "kkx", "kky", "kkz", "kl", "kla", "klb", "klc", "kld", "kle", "klf", "klg", "klh", "kli", "klj", "klk", "kll", "klm", "kln", "klo", "klp", "klq", "klr", "kls", "klt", "klu", "klv", "klw", "klx", "kly", "klz", "km", "kma", "kmb", "kmc", "kmd", "kme", "kmf", "kmg", "kmh", "kmi", "kmj", "kmk", "kml", "kmm", "kmn", "kmo", "kmp", "kmq", "kmr", "kms", "kmt", "kmu", "kmv", "kmw", "kmx", "kmy", "kmz", "kn", "kna", "knb", "knc", "knd", "kne", "knf", "kng", "kni", "knj", "knk", "knl", "knm", "knn", "kno", "knp", "knq", "knr", "kns", "knt", "knu", "knv", "knw", "knx", "kny", "knz", "ko", "koa", "koc", "kod", "koe", "kof", "kog", "koh", "koi", "koj", "kok", "kol", "koo", "kop", "koq", "kos", "kot", "kou", "kov", "kow", "kox", "koy", "koz", "kpa", "kpb", "kpc", "kpd", "kpe", "kpf", "kpg", "kph", "kpi", "kpj", "kpk", "kpl", "kpm", "kpn", "kpo", "kpp", "kpq", "kpr", "kps", "kpt", "kpu", "kpv", "kpw", "kpx", "kpy", "kpz", "kqa", "kqb", "kqc", "kqd", "kqe", "kqf", "kqg", "kqh", "kqi", "kqj", "kqk", "kql", "kqm", "kqn", "kqo", "kqp", "kqq", "kqr", "kqs", "kqt", "kqu", "kqv", "kqw", "kqx", "kqy", "kqz", "kr", "kra", "krb", "krc", "krd", "kre", "krf", "krh", "kri", "krj", "krk", "krl", "krm", "krn", "kro", "krp", "krr", "krs", "krt", "kru", "krv", "krw", "krx", "kry", "krz", "ks", "ksa", "ksb", "ksc", "ksd", "kse", "ksf", "ksg", "ksh", "ksi", "ksj", "ksk", "ksl", "ksm", "ksn", "kso", "ksp", "ksq", "ksr", "kss", "kst", "ksu", "ksv", "ksw", "ksx", "ksy", "ksz", "kta", "ktb", "ktc", "ktd", "kte", "ktf", "ktg", "kth", "kti", "ktj", "ktk", "ktl", "ktm", "ktn", "kto", "ktp", "ktq", "ktr", "kts", "ktt", "ktu", "ktv", "ktw", "ktx", "kty", "ktz", "ku", "kub", "kuc", "kud", "kue", "kuf", "kug", "kuh", "kui", "kuj", "kuk", "kul", "kum", "kun", "kuo", "kup", "kuq", "kus", "kut", "kuu", "kuv", "kuw", "kux", "kuy", "kuz", "kv", "kva", "kvb", "kvc", "kvd", "kve", "kvf", "kvg", "kvh", "kvi", "kvj", "kvk", "kvl", "kvm", "kvn", "kvo", "kvp", "kvq", "kvr", "kvs", "kvt", "kvu", "kvv", "kvw", "kvx", "kvy", "kvz", "kw", "kwa", "kwb", "kwc", "kwd", "kwe", "kwf", "kwg", "kwh", "kwi", "kwj", "kwk", "kwl", "kwm", "kwn", "kwo", "kwp", "kwq", "kwr", "kws", "kwt", "kwu", "kwv", "kww", "kwx", "kwy", "kwz", "kxa", "kxb", "kxc", "kxd", "kxe", "kxf", "kxh", "kxi", "kxj", "kxk", "kxl", "kxm", "kxn", "kxo", "kxp", "kxq", "kxr", "kxs", "kxt", "kxu", "kxv", "kxw", "kxx", "kxy", "kxz", "ky", "kya", "kyb", "kyc", "kyd", "kye", "kyf", "kyg", "kyh", "kyi", "kyj", "kyk", "kyl", "kym", "kyn", "kyo", "kyp", "kyq", "kyr", "kys", "kyt", "kyu", "kyv", "kyw", "kyx", "kyy", "kyz", "kza", "kzb", "kzc", "kzd", "kze", "kzf", "kzg", "kzh", "kzi", "kzj", "kzk", "kzl", "kzm", "kzn", "kzo", "kzp", "kzq", "kzr", "kzs", "kzt", "kzu", "kzv", "kzw", "kzx", "kzy", "kzz", "la", "laa", "lab", "lac", "lad", "lae", "laf", "lag", "lah", "lai", "laj", "lak", "lal", "lam", "lan", "lap", "laq", "lar", "las", "lau", "law", "lax", "lay", "laz", "lb", "lba", "lbb", "lbc", "lbe", "lbf", "lbg", "lbi", "lbj", "lbk", "lbl", "lbm", "lbn", "lbo", "lbq", "lbr", "lbs", "lbt", "lbu", "lbv", "lbw", "lbx", "lby", "lbz", "lcc", "lcd", "lce", "lcf", "lch", "lcl", "lcm", "lcp", "lcq", "lcs", "lda", "ldb", "ldd", "ldg", "ldh", "ldi", "ldj", "ldk", "ldl", "ldm", "ldn", "ldo", "ldp", "ldq", "lea", "leb", "lec", "led", "lee", "lef", "leg", "leh", "lei", "lej", "lek", "lel", "lem", "len", "leo", "lep", "leq", "ler", "les", "let", "leu", "lev", "lew", "lex", "ley", "lez", "lfa", "lfn", "lg", "lga", "lgb", "lgg", "lgh", "lgi", "lgk", "lgl", "lgm", "lgn", "lgq", "lgr", "lgt", "lgu", "lgz", "lha", "lhh", "lhi", "lhl", "lhm", "lhn", "lhp", "lhs", "lht", "lhu", "li", "lia", "lib", "lic", "lid", "lie", "lif", "lig", "lih", "lii", "lij", "lik", "lil", "lio", "lip", "liq", "lir", "lis", "liu", "liv", "liw", "lix", "liy", "liz", "lja", "lje", "lji", "ljl", "ljp", "ljw", "ljx", "lka", "lkb", "lkc", "lkd", "lke", "lkh", "lki", "lkj", "lkl", "lkm", "lkn", "lko", "lkr", "lks", "lkt", "lku", "lky", "lla", "llb", "llc", "lld", "lle", "llf", "llg", "llh", "lli", "llj", "llk", "lll", "llm", "lln", "llo", "llp", "llq", "lls", "llu", "llx", "lma", "lmb", "lmc", "lmd", "lme", "lmf", "lmg", "lmh", "lmi", "lmj", "lmk", "lml", "lmm", "lmn", "lmo", "lmp", "lmq", "lmr", "lmu", "lmv", "lmw", "lmx", "lmy", "lmz", "ln", "lna", "lnb", "lnd", "lng", "lnh", "lni", "lnj", "lnl", "lnm", "lnn", "lno", "lns", "lnu", "lnw", "lnz", "lo", "loa", "lob", "loc", "loe", "lof", "log", "loh", "loi", "loj", "lok", "lol", "lom", "lon", "loo", "lop", "loq", "lor", "los", "lot", "lou", "lov", "low", "lox", "loy", "loz", "lpa", "lpe", "lpn", "lpo", "lpx", "lra", "lrc", "lre", "lrg", "lri", "lrk", "lrl", "lrm", "lrn", "lro", "lrr", "lrt", "lrv", "lrz", "lsa", "lsd", "lse", "lsg", "lsh", "lsi", "lsl", "lsm", "lsn", "lso", "lsp", "lsr", "lss", "lst", "lsv", "lsy", "lt", "ltc", "ltg", "lth", "lti", "ltn", "lto", "lts", "ltu", "lu", "lua", "luc", "lud", "lue", "luf", "lui", "luj", "luk", "lul", "lum", "lun", "luo", "lup", "luq", "lur", "lus", "lut", "luu", "luv", "luw", "luy", "luz", "lv", "lva", "lvi", "lvk", "lvs", "lvu", "lwa", "lwe", "lwg", "lwh", "lwl", "lwm", "lwo", "lws", "lwt", "lwu", "lww", "lya", "lyg", "lyn", "lzh", "lzl", "lzn", "lzz", "maa", "mab", "mad", "mae", "maf", "mag", "mai", "maj", "mak", "mam", "man", "map", "maq", "mas", "mat", "mau", "mav", "maw", "max", "maz", "mba", "mbb", "mbc", "mbd", "mbe", "mbf", "mbh", "mbi", "mbj", "mbk", "mbl", "mbm", "mbn", "mbo", "mbp", "mbq", "mbr", "mbs", "mbt", "mbu", "mbv", "mbw", "mbx", "mby", "mbz", "mca", "mcb", "mcc", "mcd", "mce", "mcf", "mcg", "mch", "mci", "mcj", "mck", "mcl", "mcm", "mcn", "mco", "mcp", "mcq", "mcr", "mcs", "mct", "mcu", "mcv", "mcw", "mcx", "mcy", "mcz", "mda", "mdb", "mdc", "mdd", "mde", "mdf", "mdg", "mdh", "mdi", "mdj", "mdk", "mdl", "mdm", "mdn", "mdp", "mdq", "mdr", "mds", "mdt", "mdu", "mdv", "mdw", "mdx", "mdy", "mdz", "mea", "meb", "mec", "med", "mee", "mef", "meg", "meh", "mei", "mej", "mek", "mel", "mem", "men", "meo", "mep", "meq", "mer", "mes", "met", "meu", "mev", "mew", "mey", "mez", "mfa", "mfb", "mfc", "mfd", "mfe", "mff", "mfg", "mfh", "mfi", "mfj", "mfk", "mfl", "mfm", "mfn", "mfo", "mfp", "mfq", "mfr", "mfs", "mft", "mfu", "mfv", "mfw", "mfx", "mfy", "mfz", "mg", "mga", "mgb", "mgc", "mgd", "mge", "mgf", "mgg", "mgh", "mgi", "mgj", "mgk", "mgl", "mgm", "mgn", "mgo", "mgp", "mgq", "mgr", "mgs", "mgt", "mgu", "mgv", "mgw", "mgx", "mgy", "mgz", "mh", "mha", "mhb", "mhc", "mhd", "mhe", "mhf", "mhg", "mhh", "mhi", "mhj", "mhk", "mhl", "mhm", "mhn", "mho", "mhp", "mhq", "mhr", "mhs", "mht", "mhu", "mhw", "mhx", "mhy", "mhz", "mi", "mia", "mib", "mic", "mid", "mie", "mif", "mig", "mih", "mii", "mij", "mik", "mil", "mim", "min", "mio", "mip", "miq", "mir", "mis", "mit", "miu", "miw", "mix", "miy", "miz", "mja", "mjb", "mjc", "mjd", "mje", "mjg", "mjh", "mji", "mjj", "mjk", "mjl", "mjm", "mjn", "mjo", "mjp", "mjq", "mjr", "mjs", "mjt", "mju", "mjv", "mjw", "mjx", "mjy", "mjz", "mk", "mka", "mkb", "mkc", "mke", "mkf", "mkg", "mkh", "mki", "mkj", "mkk", "mkl", "mkm", "mkn", "mko", "mkp", "mkq", "mkr", "mks", "mkt", "mku", "mkv", "mkw", "mkx", "mky", "mkz", "ml", "mla", "mlb", "mlc", "mld", "mle", "mlf", "mlh", "mli", "mlj", "mlk", "mll", "mlm", "mln", "mlo", "mlp", "mlq", "mlr", "mls", "mlu", "mlv", "mlw", "mlx", "mlz", "mma", "mmb", "mmc", "mmd", "mme", "mmf", "mmg", "mmh", "mmi", "mmj", "mmk", "mml", "mmm", "mmn", "mmo", "mmp", "mmq", "mmr", "mmt", "mmu", "mmv", "mmw", "mmx", "mmy", "mmz", "mn", "mna", "mnb", "mnc", "mnd", "mne", "mnf", "mng", "mnh", "mni", "mnj", "mnk", "mnl", "mnm", "mnn", "mno", "mnp", "mnq", "mnr", "mns", "mnt", "mnu", "mnv", "mnw", "mnx", "mny", "mnz", "mo", "moa", "moc", "mod", "moe", "mof", "mog", "moh", "moi", "moj", "mok", "mom", "moo", "mop", "moq", "mor", "mos", "mot", "mou", "mov", "mow", "mox", "moy", "moz", "mpa", "mpb", "mpc", "mpd", "mpe", "mpg", "mph", "mpi", "mpj", "mpk", "mpl", "mpm", "mpn", "mpo", "mpp", "mpq", "mpr", "mps", "mpt", "mpu", "mpv", "mpw", "mpx", "mpy", "mpz", "mqa", "mqb", "mqc", "mqe", "mqf", "mqg", "mqh", "mqi", "mqj", "mqk", "mql", "mqm", "mqn", "mqo", "mqp", "mqq", "mqr", "mqs", "mqt", "mqu", "mqv", "mqw", "mqx", "mqy", "mqz", "mr", "mra", "mrb", "mrc", "mrd", "mre", "mrf", "mrg", "mrh", "mrj", "mrk", "mrl", "mrm", "mrn", "mro", "mrp", "mrq", "mrr", "mrs", "mrt", "mru", "mrv", "mrw", "mrx", "mry", "mrz", "ms", "msb", "msc", "msd", "mse", "msf", "msg", "msh", "msi", "msj", "msk", "msl", "msm", "msn", "mso", "msp", "msq", "msr", "mss", "mst", "msu", "msv", "msw", "msx", "msy", "msz", "mt", "mta", "mtb", "mtc", "mtd", "mte", "mtf", "mtg", "mth", "mti", "mtj", "mtk", "mtl", "mtm", "mtn", "mto", "mtp", "mtq", "mtr", "mts", "mtt", "mtu", "mtv", "mtw", "mtx", "mty", "mua", "mub", "muc", "mud", "mue", "mug", "muh", "mui", "muj", "muk", "mul", "mum", "mun", "muo", "mup", "muq", "mur", "mus", "mut", "muu", "muv", "mux", "muy", "muz", "mva", "mvb", "mvd", "mve", "mvf", "mvg", "mvh", "mvi", "mvk", "mvl", "mvm", "mvn", "mvo", "mvp", "mvq", "mvr", "mvs", "mvt", "mvu", "mvv", "mvw", "mvx", "mvy", "mvz", "mwa", "mwb", "mwc", "mwd", "mwe", "mwf", "mwg", "mwh", "mwi", "mwj", "mwk", "mwl", "mwm", "mwn", "mwo", "mwp", "mwq", "mwr", "mws", "mwt", "mwu", "mwv", "mww", "mwx", "mwy", "mwz", "mxa", "mxb", "mxc", "mxd", "mxe", "mxf", "mxg", "mxh", "mxi", "mxj", "mxk", "mxl", "mxm", "mxn", "mxo", "mxp", "mxq", "mxr", "mxs", "mxt", "mxu", "mxv", "mxw", "mxx", "mxy", "mxz", "my", "myb", "myc", "myd", "mye", "myf", "myg", "myh", "myi", "myj", "myk", "myl", "mym", "myn", "myo", "myp", "myq", "myr", "mys", "myt", "myu", "myv", "myw", "myx", "myy", "myz", "mza", "mzb", "mzc", "mzd", "mze", "mzg", "mzh", "mzi", "mzj", "mzk", "mzl", "mzm", "mzn", "mzo", "mzp", "mzq", "mzr", "mzs", "mzt", "mzu", "mzv", "mzw", "mzx", "mzy", "mzz", "na", "naa", "nab", "nac", "nad", "nae", "naf", "nag", "nah", "nai", "naj", "nak", "nal", "nam", "nan", "nao", "nap", "naq", "nar", "nas", "nat", "naw", "nax", "nay", "naz", "nb", "nba", "nbb", "nbc", "nbd", "nbe", "nbf", "nbg", "nbh", "nbi", "nbj", "nbk", "nbm", "nbn", "nbo", "nbp", "nbq", "nbr", "nbs", "nbt", "nbu", "nbv", "nbw", "nbx", "nby", "nca", "ncb", "ncc", "ncd", "nce", "ncf", "ncg", "nch", "nci", "ncj", "nck", "ncl", "ncm", "ncn", "nco", "ncp", "ncq", "ncr", "ncs", "nct", "ncu", "ncx", "ncz", "nd", "nda", "ndb", "ndc", "ndd", "ndf", "ndg", "ndh", "ndi", "ndj", "ndk", "ndl", "ndm", "ndn", "ndp", "ndq", "ndr", "nds", "ndt", "ndu", "ndv", "ndw", "ndx", "ndy", "ndz", "ne", "nea", "neb", "nec", "ned", "nee", "nef", "neg", "neh", "nei", "nej", "nek", "nem", "nen", "neo", "neq", "ner", "nes", "net", "neu", "nev", "new", "nex", "ney", "nez", "nfa", "nfd", "nfl", "nfr", "nfu", "ng", "nga", "ngb", "ngc", "ngd", "nge", "ngf", "ngg", "ngh", "ngi", "ngj", "ngk", "ngl", "ngm", "ngn", "ngo", "ngp", "ngq", "ngr", "ngs", "ngt", "ngu", "ngv", "ngw", "ngx", "ngy", "ngz", "nha", "nhb", "nhc", "nhd", "nhe", "nhf", "nhg", "nhh", "nhi", "nhk", "nhm", "nhn", "nho", "nhp", "nhq", "nhr", "nht", "nhu", "nhv", "nhw", "nhx", "nhy", "nhz", "nia", "nib", "nic", "nid", "nie", "nif", "nig", "nih", "nii", "nij", "nik", "nil", "nim", "nin", "nio", "niq", "nir", "nis", "nit", "niu", "niv", "niw", "nix", "niy", "niz", "nja", "njb", "njd", "njh", "nji", "njj", "njl", "njm", "njn", "njo", "njr", "njs", "njt", "nju", "njx", "njy", "njz", "nka", "nkb", "nkc", "nkd", "nke", "nkf", "nkg", "nkh", "nki", "nkj", "nkk", "nkm", "nkn", "nko", "nkp", "nkq", "nkr", "nks", "nkt", "nku", "nkv", "nkw", "nkx", "nkz", "nl", "nla", "nlc", "nle", "nlg", "nli", "nlj", "nlk", "nll", "nlm", "nln", "nlo", "nlq", "nlr", "nlu", "nlv", "nlw", "nlx", "nly", "nlz", "nma", "nmb", "nmc", "nmd", "nme", "nmf", "nmg", "nmh", "nmi", "nmj", "nmk", "nml", "nmm", "nmn", "nmo", "nmp", "nmq", "nmr", "nms", "nmt", "nmu", "nmv", "nmw", "nmx", "nmy", "nmz", "nn", "nna", "nnb", "nnc", "nnd", "nne", "nnf", "nng", "nnh", "nni", "nnj", "nnk", "nnl", "nnm", "nnn", "nnp", "nnq", "nnr", "nns", "nnt", "nnu", "nnv", "nnw", "nnx", "nny", "nnz", "no", "noa", "noc", "nod", "noe", "nof", "nog", "noh", "noi", "noj", "nok", "nol", "nom", "non", "noo", "nop", "noq", "nos", "not", "nou", "nov", "now", "noy", "noz", "npa", "npb", "npg", "nph", "npi", "npl", "npn", "npo", "nps", "npu", "npx", "npy", "nqg", "nqk", "nql", "nqm", "nqn", "nqo", "nqq", "nqy", "nr", "nra", "nrb", "nrc", "nre", "nrf", "nrg", "nri", "nrk", "nrl", "nrm", "nrn", "nrp", "nrr", "nrt", "nru", "nrx", "nrz", "nsa", "nsc", "nsd", "nse", "nsf", "nsg", "nsh", "nsi", "nsk", "nsl", "nsm", "nsn", "nso", "nsp", "nsq", "nsr", "nss", "nst", "nsu", "nsv", "nsw", "nsx", "nsy", "nsz", "ntd", "nte", "ntg", "nti", "ntj", "ntk", "ntm", "nto", "ntp", "ntr", "nts", "ntu", "ntw", "ntx", "nty", "ntz", "nua", "nub", "nuc", "nud", "nue", "nuf", "nug", "nuh", "nui", "nuj", "nuk", "nul", "num", "nun", "nuo", "nup", "nuq", "nur", "nus", "nut", "nuu", "nuv", "nuw", "nux", "nuy", "nuz", "nv", "nvh", "nvm", "nvo", "nwa", "nwb", "nwc", "nwe", "nwg", "nwi", "nwm", "nwo", "nwr", "nwx", "nwy", "nxa", "nxd", "nxe", "nxg", "nxi", "nxk", "nxl", "nxm", "nxn", "nxo", "nxq", "nxr", "nxu", "nxx", "ny", "nyb", "nyc", "nyd", "nye", "nyf", "nyg", "nyh", "nyi", "nyj", "nyk", "nyl", "nym", "nyn", "nyo", "nyp", "nyq", "nyr", "nys", "nyt", "nyu", "nyv", "nyw", "nyx", "nyy", "nza", "nzb", "nzd", "nzi", "nzk", "nzm", "nzs", "nzu", "nzy", "nzz", "oaa", "oac", "oar", "oav", "obi", "obk", "obl", "obm", "obo", "obr", "obt", "obu", "oc", "oca", "och", "oco", "ocu", "oda", "odk", "odt", "odu", "ofo", "ofs", "ofu", "ogb", "ogc", "oge", "ogg", "ogo", "ogu", "oht", "ohu", "oia", "oin", "oj", "ojb", "ojc", "ojg", "ojp", "ojs", "ojv", "ojw", "oka", "okb", "okd", "oke", "okg", "okh", "oki", "okj", "okk", "okl", "okm", "okn", "oko", "okr", "oks", "oku", "okv", "okx", "ola", "old", "ole", "olk", "olm", "olo", "olr", "olt", "olu", "om", "oma", "omb", "omc", "ome", "omg", "omi", "omk", "oml", "omn", "omo", "omp", "omq", "omr", "omt", "omu", "omv", "omw", "omx", "ona", "onb", "one", "ong", "oni", "onj", "onk", "onn", "ono", "onp", "onr", "ons", "ont", "onu", "onw", "onx", "ood", "oog", "oon", "oor", "oos", "opa", "opk", "opm", "opo", "opt", "opy", "or", "ora", "orc", "ore", "org", "orh", "orn", "oro", "orr", "ors", "ort", "oru", "orv", "orw", "orx", "ory", "orz", "os", "osa", "osc", "osi", "oso", "osp", "ost", "osu", "osx", "ota", "otb", "otd", "ote", "oti", "otk", "otl", "otm", "otn", "oto", "otq", "otr", "ots", "ott", "otu", "otw", "otx", "oty", "otz", "oua", "oub", "oue", "oui", "oum", "oun", "ovd", "owi", "owl", "oyb", "oyd", "oym", "oyy", "ozm", "pa", "paa", "pab", "pac", "pad", "pae", "paf", "pag", "pah", "pai", "pak", "pal", "pam", "pao", "pap", "paq", "par", "pas", "pat", "pau", "pav", "paw", "pax", "pay", "paz", "pbb", "pbc", "pbe", "pbf", "pbg", "pbh", "pbi", "pbl", "pbm", "pbn", "pbo", "pbp", "pbr", "pbs", "pbt", "pbu", "pbv", "pby", "pbz", "pca", "pcb", "pcc", "pcd", "pce", "pcf", "pcg", "pch", "pci", "pcj", "pck", "pcl", "pcm", "pcn", "pcp", "pcr", "pcw", "pda", "pdc", "pdi", "pdn", "pdo", "pdt", "pdu", "pea", "peb", "ped", "pee", "pef", "peg", "peh", "pei", "pej", "pek", "pel", "pem", "peo", "pep", "peq", "pes", "pev", "pex", "pey", "pez", "pfa", "pfe", "pfl", "pga", "pgd", "pgg", "pgi", "pgk", "pgl", "pgn", "pgs", "pgu", "pgy", "pgz", "pha", "phd", "phg", "phh", "phi", "phk", "phl", "phm", "phn", "pho", "phq", "phr", "pht", "phu", "phv", "phw", "pi", "pia", "pib", "pic", "pid", "pie", "pif", "pig", "pih", "pii", "pij", "pil", "pim", "pin", "pio", "pip", "pir", "pis", "pit", "piu", "piv", "piw", "pix", "piy", "piz", "pjt", "pka", "pkb", "pkc", "pkg", "pkh", "pkn", "pko", "pkp", "pkr", "pks", "pkt", "pku", "pl", "pla", "plb", "plc", "pld", "ple", "plf", "plg", "plh", "plj", "plk", "pll", "pln", "plo", "plp", "plq", "plr", "pls", "plt", "plu", "plv", "plw", "ply", "plz", "pma", "pmb", "pmc", "pmd", "pme", "pmf", "pmh", "pmi", "pmj", "pmk", "pml", "pmm", "pmn", "pmo", "pmq", "pmr", "pms", "pmt", "pmu", "pmw", "pmx", "pmy", "pmz", "pna", "pnb", "pnc", "pnd", "pne", "png", "pnh", "pni", "pnj", "pnk", "pnl", "pnm", "pnn", "pno", "pnp", "pnq", "pnr", "pns", "pnt", "pnu", "pnv", "pnw", "pnx", "pny", "pnz", "poc", "pod", "poe", "pof", "pog", "poh", "poi", "pok", "pom", "pon", "poo", "pop", "poq", "pos", "pot", "pov", "pow", "pox", "poy", "poz", "ppa", "ppe", "ppi", "ppk", "ppl", "ppm", "ppn", "ppo", "ppp", "ppq", "ppr", "pps", "ppt", "ppu", "pqa", "pqe", "pqm", "pqw", "pra", "prb", "prc", "prd", "pre", "prf", "prg", "prh", "pri", "prk", "prl", "prm", "prn", "pro", "prp", "prq", "prr", "prs", "prt", "pru", "prw", "prx", "pry", "prz", "ps", "psa", "psc", "psd", "pse", "psg", "psh", "psi", "psl", "psm", "psn", "pso", "psp", "psq", "psr", "pss", "pst", "psu", "psw", "psy", "pt", "pta", "pth", "pti", "ptn", "pto", "ptp", "ptq", "ptr", "ptt", "ptu", "ptv", "ptw", "pty", "pua", "pub", "puc", "pud", "pue", "puf", "pug", "pui", "puj", "puk", "pum", "puo", "pup", "puq", "pur", "put", "puu", "puw", "pux", "puy", "puz", "pwa", "pwb", "pwg", "pwi", "pwm", "pwn", "pwo", "pwr", "pww", "pxm", "pye", "pym", "pyn", "pys", "pyu", "pyx", "pyy", "pzn", "qu", "qua", "qub", "quc", "qud", "quf", "qug", "quh", "qui", "quk", "qul", "qum", "qun", "qup", "quq", "qur", "qus", "quv", "quw", "qux", "quy", "quz", "qva", "qvc", "qve", "qvh", "qvi", "qvj", "qvl", "qvm", "qvn", "qvo", "qvp", "qvs", "qvw", "qvy", "qvz", "qwa", "qwc", "qwe", "qwh", "qwm", "qws", "qwt", "qxa", "qxc", "qxh", "qxl", "qxn", "qxo", "qxp", "qxq", "qxr", "qxs", "qxt", "qxu", "qxw", "qya", "qyp", "raa", "rab", "rac", "rad", "raf", "rag", "rah", "rai", "raj", "rak", "ral", "ram", "ran", "rao", "rap", "raq", "rar", "ras", "rat", "rau", "rav", "raw", "rax", "ray", "raz", "rbb", "rbk", "rbl", "rbp", "rcf", "rdb", "rea", "reb", "ree", "reg", "rei", "rej", "rel", "rem", "ren", "rer", "res", "ret", "rey", "rga", "rge", "rgk", "rgn", "rgr", "rgs", "rgu", "rhg", "rhp", "ria", "rie", "rif", "ril", "rim", "rin", "rir", "rit", "riu", "rjg", "rji", "rjs", "rka", "rkb", "rkh", "rki", "rkm", "rkt", "rkw", "rm", "rma", "rmb", "rmc", "rmd", "rme", "rmf", "rmg", "rmh", "rmi", "rmk", "rml", "rmm", "rmn", "rmo", "rmp", "rmq", "rmr", "rms", "rmt", "rmu", "rmv", "rmw", "rmx", "rmy", "rmz", "rn", "rna", "rnd", "rng", "rnl", "rnn", "rnp", "rnr", "rnw", "ro", "roa", "rob", "roc", "rod", "roe", "rof", "rog", "rol", "rom", "roo", "rop", "ror", "rou", "row", "rpn", "rpt", "rri", "rro", "rrt", "rsb", "rsi", "rsl", "rsm", "rtc", "rth", "rtm", "rts", "rtw", "ru", "rub", "ruc", "rue", "ruf", "rug", "ruh", "rui", "ruk", "ruo", "rup", "ruq", "rut", "ruu", "ruy", "ruz", "rw", "rwa", "rwk", "rwm", "rwo", "rwr", "rxd", "rxw", "ryn", "rys", "ryu", "rzh", "sa", "saa", "sab", "sac", "sad", "sae", "saf", "sah", "sai", "saj", "sak", "sal", "sam", "sao", "sap", "saq", "sar", "sas", "sat", "sau", "sav", "saw", "sax", "say", "saz", "sba", "sbb", "sbc", "sbd", "sbe", "sbf", "sbg", "sbh", "sbi", "sbj", "sbk", "sbl", "sbm", "sbn", "sbo", "sbp", "sbq", "sbr", "sbs", "sbt", "sbu", "sbv", "sbw", "sbx", "sby", "sbz", "sc", "sca", "scb", "sce", "scf", "scg", "sch", "sci", "sck", "scl", "scn", "sco", "scp", "scq", "scs", "sct", "scu", "scv", "scw", "scx", "sd", "sda", "sdb", "sdc", "sde", "sdf", "sdg", "sdh", "sdj", "sdk", "sdl", "sdm", "sdn", "sdo", "sdp", "sdr", "sds", "sdt", "sdu", "sdv", "sdx", "sdz", "se", "sea", "seb", "sec", "sed", "see", "sef", "seg", "seh", "sei", "sej", "sek", "sel", "sem", "sen", "seo", "sep", "seq", "ser", "ses", "set", "seu", "sev", "sew", "sey", "sez", "sfb", "sfe", "sfm", "sfs", "sfw", "sg", "sga", "sgb", "sgc", "sgd", "sge", "sgg", "sgh", "sgi", "sgj", "sgk", "sgl", "sgm", "sgn", "sgo", "sgp", "sgr", "sgs", "sgt", "sgu", "sgw", "sgx", "sgy", "sgz", "sh", "sha", "shb", "shc", "shd", "she", "shg", "shh", "shi", "shj", "shk", "shl", "shm", "shn", "sho", "shp", "shq", "shr", "shs", "sht", "shu", "shv", "shw", "shx", "shy", "shz", "si", "sia", "sib", "sid", "sie", "sif", "sig", "sih", "sii", "sij", "sik", "sil", "sim", "sio", "sip", "siq", "sir", "sis", "sit", "siu", "siv", "siw", "six", "siy", "siz", "sja", "sjb", "sjd", "sje", "sjg", "sjk", "sjl", "sjm", "sjn", "sjo", "sjp", "sjr", "sjs", "sjt", "sju", "sjw", "sk", "ska", "skb", "skc", "skd", "ske", "skf", "skg", "skh", "ski", "skj", "skk", "skm", "skn", "sko", "skp", "skq", "skr", "sks", "skt", "sku", "skv", "skw", "skx", "sky", "skz", "sl", "sla", "slc", "sld", "sle", "slf", "slg", "slh", "sli", "slj", "sll", "slm", "sln", "slp", "slq", "slr", "sls", "slt", "slu", "slw", "slx", "sly", "slz", "sm", "sma", "smb", "smc", "smd", "smf", "smg", "smh", "smi", "smj", "smk", "sml", "smm", "smn", "smp", "smq", "smr", "sms", "smt", "smu", "smv", "smw", "smx", "smy", "smz", "sn", "snb", "snc", "sne", "snf", "sng", "snh", "sni", "snj", "snk", "snl", "snm", "snn", "sno", "snp", "snq", "snr", "sns", "snu", "snv", "snw", "snx", "sny", "snz", "so", "soa", "sob", "soc", "sod", "soe", "sog", "soh", "soi", "soj", "sok", "sol", "son", "soo", "sop", "soq", "sor", "sos", "sou", "sov", "sow", "sox", "soy", "soz", "spb", "spc", "spd", "spe", "spg", "spi", "spk", "spl", "spm", "spn", "spo", "spp", "spq", "spr", "sps", "spt", "spu", "spv", "spx", "spy", "sq", "sqa", "sqh", "sqj", "sqk", "sqm", "sqn", "sqo", "sqq", "sqr", "sqs", "sqt", "squ", "sr", "sra", "srb", "src", "sre", "srf", "srg", "srh", "sri", "srk", "srl", "srm", "srn", "sro", "srq", "srr", "srs", "srt", "sru", "srv", "srw", "srx", "sry", "srz", "ss", "ssa", "ssb", "ssc", "ssd", "sse", "ssf", "ssg", "ssh", "ssi", "ssj", "ssk", "ssl", "ssm", "ssn", "sso", "ssp", "ssq", "ssr", "sss", "sst", "ssu", "ssv", "ssx", "ssy", "ssz", "st", "sta", "stb", "std", "ste", "stf", "stg", "sth", "sti", "stj", "stk", "stl", "stm", "stn", "sto", "stp", "stq", "str", "sts", "stt", "stu", "stv", "stw", "sty", "su", "sua", "sub", "suc", "sue", "sug", "sui", "suj", "suk", "sul", "sum", "suq", "sur", "sus", "sut", "suv", "suw", "sux", "suy", "suz", "sv", "sva", "svb", "svc", "sve", "svk", "svm", "svr", "svs", "svx", "sw", "swb", "swc", "swf", "swg", "swh", "swi", "swj", "swk", "swl", "swm", "swn", "swo", "swp", "swq", "swr", "sws", "swt", "swu", "swv", "sww", "swx", "swy", "sxb", "sxc", "sxe", "sxg", "sxk", "sxl", "sxm", "sxn", "sxo", "sxr", "sxs", "sxu", "sxw", "sya", "syb", "syc", "syd", "syi", "syk", "syl", "sym", "syn", "syo", "syr", "sys", "syw", "syx", "syy", "sza", "szb", "szc", "szd", "sze", "szg", "szl", "szn", "szp", "szs", "szv", "szw", "szy", "ta", "taa", "tab", "tac", "tad", "tae", "taf", "tag", "tai", "taj", "tak", "tal", "tan", "tao", "tap", "taq", "tar", "tas", "tau", "tav", "taw", "tax", "tay", "taz", "tba", "tbb", "tbc", "tbd", "tbe", "tbf", "tbg", "tbh", "tbi", "tbj", "tbk", "tbl", "tbm", "tbn", "tbo", "tbp", "tbq", "tbr", "tbs", "tbt", "tbu", "tbv", "tbw", "tbx", "tby", "tbz", "tca", "tcb", "tcc", "tcd", "tce", "tcf", "tcg", "tch", "tci", "tck", "tcl", "tcm", "tcn", "tco", "tcp", "tcq", "tcs", "tct", "tcu", "tcw", "tcx", "tcy", "tcz", "tda", "tdb", "tdc", "tdd", "tde", "tdf", "tdg", "tdh", "tdi", "tdj", "tdk", "tdl", "tdm", "tdn", "tdo", "tdq", "tdr", "tds", "tdt", "tdu", "tdv", "tdx", "tdy", "te", "tea", "teb", "tec", "ted", "tee", "tef", "teg", "teh", "tei", "tek", "tem", "ten", "teo", "tep", "teq", "ter", "tes", "tet", "teu", "tev", "tew", "tex", "tey", "tez", "tfi", "tfn", "tfo", "tfr", "tft", "tg", "tga", "tgb", "tgc", "tgd", "tge", "tgf", "tgg", "tgh", "tgi", "tgj", "tgn", "tgo", "tgp", "tgq", "tgr", "tgs", "tgt", "tgu", "tgv", "tgw", "tgx", "tgy", "tgz", "th", "thc", "thd", "the", "thf", "thh", "thi", "thk", "thl", "thm", "thn", "thp", "thq", "thr", "ths", "tht", "thu", "thv", "thw", "thx", "thy", "thz", "ti", "tia", "tic", "tid", "tie", "tif", "tig", "tih", "tii", "tij", "tik", "til", "tim", "tin", "tio", "tip", "tiq", "tis", "tit", "tiu", "tiv", "tiw", "tix", "tiy", "tiz", "tja", "tjg", "tji", "tjj", "tjl", "tjm", "tjn", "tjo", "tjp", "tjs", "tju", "tjw", "tk", "tka", "tkb", "tkd", "tke", "tkf", "tkg", "tkk", "tkl", "tkm", "tkn", "tkp", "tkq", "tkr", "tks", "tkt", "tku", "tkv", "tkw", "tkx", "tkz", "tl", "tla", "tlb", "tlc", "tld", "tlf", "tlg", "tlh", "tli", "tlj", "tlk", "tll", "tlm", "tln", "tlo", "tlp", "tlq", "tlr", "tls", "tlt", "tlu", "tlv", "tlw", "tlx", "tly", "tma", "tmb", "tmc", "tmd", "tme", "tmf", "tmg", "tmh", "tmi", "tmj", "tmk", "tml", "tmm", "tmn", "tmo", "tmp", "tmq", "tmr", "tms", "tmt", "tmu", "tmv", "tmw", "tmy", "tmz", "tn", "tna", "tnb", "tnc", "tnd", "tne", "tnf", "tng", "tnh", "tni", "tnk", "tnl", "tnm", "tnn", "tno", "tnp", "tnq", "tnr", "tns", "tnt", "tnu", "tnv", "tnw", "tnx", "tny", "tnz", "to", "tob", "toc", "tod", "toe", "tof", "tog", "toh", "toi", "toj", "tol", "tom", "too", "top", "toq", "tor", "tos", "tou", "tov", "tow", "tox", "toy", "toz", "tpa", "tpc", "tpe", "tpf", "tpg", "tpi", "tpj", "tpk", "tpl", "tpm", "tpn", "tpo", "tpp", "tpq", "tpr", "tpt", "tpu", "tpv", "tpw", "tpx", "tpy", "tpz", "tqb", "tql", "tqm", "tqn", "tqo", "tqp", "tqq", "tqr", "tqt", "tqu", "tqw", "tr", "tra", "trb", "trc", "trd", "tre", "trf", "trg", "trh", "tri", "trj", "trk", "trl", "trm", "trn", "tro", "trp", "trq", "trr", "trs", "trt", "tru", "trv", "trw", "trx", "try", "trz", "ts", "tsa", "tsb", "tsc", "tsd", "tse", "tsf", "tsg", "tsh", "tsi", "tsj", "tsk", "tsl", "tsm", "tsp", "tsq", "tsr", "tss", "tst", "tsu", "tsv", "tsw", "tsx", "tsy", "tsz", "tt", "tta", "ttb", "ttc", "ttd", "tte", "ttf", "ttg", "tth", "tti", "ttj", "ttk", "ttl", "ttm", "ttn", "tto", "ttp", "ttq", "ttr", "tts", "ttt", "ttu", "ttv", "ttw", "tty", "ttz", "tua", "tub", "tuc", "tud", "tue", "tuf", "tug", "tuh", "tui", "tuj", "tul", "tum", "tun", "tuo", "tup", "tuq", "tus", "tut", "tuu", "tuv", "tuw", "tux", "tuy", "tuz", "tva", "tvd", "tve", "tvk", "tvl", "tvm", "tvn", "tvo", "tvs", "tvt", "tvu", "tvw", "tvx", "tvy", "tw", "twa", "twb", "twc", "twd", "twe", "twf", "twg", "twh", "twl", "twm", "twn", "two", "twp", "twq", "twr", "twt", "twu", "tww", "twx", "twy", "txa", "txb", "txc", "txe", "txg", "txh", "txi", "txj", "txm", "txn", "txo", "txq", "txr", "txs", "txt", "txu", "txx", "txy", "ty", "tya", "tye", "tyh", "tyi", "tyj", "tyl", "tyn", "typ", "tyr", "tys", "tyt", "tyu", "tyv", "tyx", "tyz", "tza", "tzh", "tzj", "tzl", "tzm", "tzn", "tzo", "tzx", "uam", "uan", "uar", "uba", "ubi", "ubl", "ubr", "ubu", "uby", "uda", "ude", "udg", "udi", "udj", "udl", "udm", "udu", "ues", "ufi", "ug", "uga", "ugb", "uge", "ugn", "ugo", "ugy", "uha", "uhn", "uis", "uiv", "uji", "uk", "uka", "ukg", "ukh", "ukk", "ukl", "ukp", "ukq", "uks", "uku", "ukw", "uky", "ula", "ulb", "ulc", "ule", "ulf", "uli", "ulk", "ull", "ulm", "uln", "ulu", "ulw", "uma", "umb", "umc", "umd", "umg", "umi", "umm", "umn", "umo", "ump", "umr", "ums", "umu", "una", "und", "une", "ung", "unk", "unm", "unn", "unp", "unr", "unu", "unx", "unz", "uok", "upi", "upv", "ur", "ura", "urb", "urc", "ure", "urf", "urg", "urh", "uri", "urj", "urk", "url", "urm", "urn", "uro", "urp", "urr", "urt", "uru", "urv", "urw", "urx", "ury", "urz", "usa", "ush", "usi", "usk", "usp", "uss", "usu", "uta", "ute", "uth", "utp", "utr", "utu", "uum", "uun", "uur", "uuu", "uve", "uvh", "uvl", "uwa", "uya", "uz", "uzn", "uzs", "vaa", "vae", "vaf", "vag", "vah", "vai", "vaj", "val", "vam", "van", "vao", "vap", "var", "vas", "vau", "vav", "vay", "vbb", "vbk", "ve", "vec", "ved", "vel", "vem", "veo", "vep", "ver", "vgr", "vgt", "vi", "vic", "vid", "vif", "vig", "vil", "vin", "vis", "vit", "viv", "vka", "vki", "vkj", "vkk", "vkl", "vkm", "vko", "vkp", "vkt", "vku", "vlp", "vls", "vma", "vmb", "vmc", "vmd", "vme", "vmf", "vmg", "vmh", "vmi", "vmj", "vmk", "vml", "vmm", "vmp", "vmq", "vmr", "vms", "vmu", "vmv", "vmw", "vmx", "vmy", "vmz", "vnk", "vnm", "vnp", "vo", "vor", "vot", "vra", "vro", "vrs", "vrt", "vsi", "vsl", "vsv", "vto", "vum", "vun", "vut", "vwa", "wa", "waa", "wab", "wac", "wad", "wae", "waf", "wag", "wah", "wai", "waj", "wak", "wal", "wam", "wan", "wao", "wap", "waq", "war", "was", "wat", "wau", "wav", "waw", "wax", "way", "waz", "wba", "wbb", "wbe", "wbf", "wbh", "wbi", "wbj", "wbk", "wbl", "wbm", "wbp", "wbq", "wbr", "wbs", "wbt", "wbv", "wbw", "wca", "wci", "wdd", "wdg", "wdj", "wdk", "wdu", "wdy", "wea", "wec", "wed", "weg", "weh", "wei", "wem", "wen", "weo", "wep", "wer", "wes", "wet", "weu", "wew", "wfg", "wga", "wgb", "wgg", "wgi", "wgo", "wgu", "wgw", "wgy", "wha", "whg", "whk", "whu", "wib", "wic", "wie", "wif", "wig", "wih", "wii", "wij", "wik", "wil", "wim", "win", "wir", "wit", "wiu", "wiv", "wiw", "wiy", "wja", "wji", "wka", "wkb", "wkd", "wkl", "wkr", "wku", "wkw", "wky", "wla", "wlc", "wle", "wlg", "wli", "wlk", "wll", "wlm", "wlo", "wlr", "wls", "wlu", "wlv", "wlw", "wlx", "wly", "wma", "wmb", "wmc", "wmd", "wme", "wmh", "wmi", "wmm", "wmn", "wmo", "wms", "wmt", "wmw", "wmx", "wnb", "wnc", "wnd", "wne", "wng", "wni", "wnk", "wnm", "wnn", "wno", "wnp", "wnu", "wnw", "wny", "wo", "woa", "wob", "woc", "wod", "woe", "wof", "wog", "woi", "wok", "wom", "won", "woo", "wor", "wos", "wow", "woy", "wpc", "wra", "wrb", "wrd", "wrg", "wrh", "wri", "wrk", "wrl", "wrm", "wrn", "wro", "wrp", "wrr", "wrs", "wru", "wrv", "wrw", "wrx", "wry", "wrz", "wsa", "wsg", "wsi", "wsk", "wsr", "wss", "wsu", "wsv", "wtf", "wth", "wti", "wtk", "wtm", "wtw", "wua", "wub", "wud", "wuh", "wul", "wum", "wun", "wur", "wut", "wuu", "wuv", "wux", "wuy", "wwa", "wwb", "wwo", "wwr", "www", "wxa", "wxw", "wya", "wyb", "wyi", "wym", "wyr", "wyy", "xaa", "xab", "xac", "xad", "xae", "xag", "xai", "xaj", "xak", "xal", "xam", "xan", "xao", "xap", "xaq", "xar", "xas", "xat", "xau", "xav", "xaw", "xay", "xba", "xbb", "xbc", "xbd", "xbe", "xbg", "xbi", "xbj", "xbm", "xbn", "xbo", "xbp", "xbr", "xbw", "xbx", "xby", "xcb", "xcc", "xce", "xcg", "xch", "xcl", "xcm", "xcn", "xco", "xcr", "xct", "xcu", "xcv", "xcw", "xcy", "xda", "xdc", "xdk", "xdm", "xdo", "xdy", "xeb", "xed", "xeg", "xel", "xem", "xep", "xer", "xes", "xet", "xeu", "xfa", "xga", "xgb", "xgd", "xgf", "xgg", "xgi", "xgl", "xgm", "xgn", "xgr", "xgu", "xgw", "xh", "xha", "xhc", "xhd", "xhe", "xhr", "xht", "xhu", "xhv", "xia", "xib", "xii", "xil", "xin", "xip", "xir", "xis", "xiv", "xiy", "xjb", "xjt", "xka", "xkb", "xkc", "xkd", "xke", "xkf", "xkg", "xkh", "xki", "xkj", "xkk", "xkl", "xkn", "xko", "xkp", "xkq", "xkr", "xks", "xkt", "xku", "xkv", "xkw", "xkx", "xky", "xkz", "xla", "xlb", "xlc", "xld", "xle", "xlg", "xli", "xln", "xlo", "xlp", "xls", "xlu", "xly", "xma", "xmb", "xmc", "xmd", "xme", "xmf", "xmg", "xmh", "xmj", "xmk", "xml", "xmm", "xmn", "xmo", "xmp", "xmq", "xmr", "xms", "xmt", "xmu", "xmv", "xmw", "xmx", "xmy", "xmz", "xna", "xnb", "xnd", "xng", "xnh", "xni", "xnk", "xnn", "xno", "xnr", "xns", "xnt", "xnu", "xny", "xnz", "xoc", "xod", "xog", "xoi", "xok", "xom", "xon", "xoo", "xop", "xor", "xow", "xpa", "xpc", "xpe", "xpg", "xpi", "xpj", "xpk", "xpm", "xpn", "xpo", "xpp", "xpq", "xpr", "xps", "xpt", "xpu", "xpy", "xqa", "xqt", "xra", "xrb", "xrd", "xre", "xrg", "xri", "xrm", "xrn", "xrq", "xrr", "xrt", "xru", "xrw", "xsa", "xsb", "xsc", "xsd", "xse", "xsh", "xsi", "xsj", "xsl", "xsm", "xsn", "xso", "xsp", "xsq", "xsr", "xss", "xsu", "xsv", "xsy", "xta", "xtb", "xtc", "xtd", "xte", "xtg", "xth", "xti", "xtj", "xtl", "xtm", "xtn", "xto", "xtp", "xtq", "xtr", "xts", "xtt", "xtu", "xtv", "xtw", "xty", "xtz", "xua", "xub", "xud", "xug", "xuj", "xul", "xum", "xun", "xuo", "xup", "xur", "xut", "xuu", "xve", "xvi", "xvn", "xvo", "xvs", "xwa", "xwc", "xwd", "xwe", "xwg", "xwj", "xwk", "xwl", "xwo", "xwr", "xwt", "xww", "xxb", "xxk", "xxm", "xxr", "xxt", "xya", "xyb", "xyj", "xyk", "xyl", "xyt", "xyy", "xzh", "xzm", "xzp", "yaa", "yab", "yac", "yad", "yae", "yaf", "yag", "yah", "yai", "yaj", "yak", "yal", "yam", "yan", "yao", "yap", "yaq", "yar", "yas", "yat", "yau", "yav", "yaw", "yax", "yay", "yaz", "yba", "ybb", "ybd", "ybe", "ybh", "ybi", "ybj", "ybk", "ybl", "ybm", "ybn", "ybo", "ybx", "yby", "ych", "ycl", "ycn", "ycp", "yda", "ydd", "yde", "ydg", "ydk", "yds", "yea", "yec", "yee", "yei", "yej", "yel", "yen", "yer", "yes", "yet", "yeu", "yev", "yey", "yga", "ygi", "ygl", "ygm", "ygp", "ygr", "ygs", "ygu", "ygw", "yha", "yhd", "yhl", "yhs", "yi", "yia", "yif", "yig", "yih", "yii", "yij", "yik", "yil", "yim", "yin", "yip", "yiq", "yir", "yis", "yit", "yiu", "yiv", "yix", "yiy", "yiz", "yka", "ykg", "yki", "ykk", "ykl", "ykm", "ykn", "yko", "ykr", "ykt", "yku", "yky", "yla", "ylb", "yle", "ylg", "yli", "yll", "ylm", "yln", "ylo", "ylr", "ylu", "yly", "yma", "ymb", "ymc", "ymd", "yme", "ymg", "ymh", "ymi", "ymk", "yml", "ymm", "ymn", "ymo", "ymp", "ymq", "ymr", "yms", "ymt", "ymx", "ymz", "yna", "ynd", "yne", "yng", "ynh", "ynk", "ynl", "ynn", "yno", "ynq", "yns", "ynu", "yo", "yob", "yog", "yoi", "yok", "yol", "yom", "yon", "yos", "yot", "yox", "yoy", "ypa", "ypb", "ypg", "yph", "ypk", "ypm", "ypn", "ypo", "ypp", "ypz", "yra", "yrb", "yre", "yri", "yrk", "yrl", "yrm", "yrn", "yro", "yrs", "yrw", "yry", "ysc", "ysd", "ysg", "ysl", "ysn", "yso", "ysp", "ysr", "yss", "ysy", "yta", "ytl", "ytp", "ytw", "yty", "yua", "yub", "yuc", "yud", "yue", "yuf", "yug", "yui", "yuj", "yuk", "yul", "yum", "yun", "yup", "yuq", "yur", "yut", "yuu", "yuw", "yux", "yuy", "yuz", "yva", "yvt", "ywa", "ywg", "ywl", "ywn", "ywq", "ywr", "ywt", "ywu", "yww", "yxa", "yxg", "yxl", "yxm", "yxu", "yxy", "yyr", "yyu", "yyz", "yzg", "yzk", "za", "zaa", "zab", "zac", "zad", "zae", "zaf", "zag", "zah", "zai", "zaj", "zak", "zal", "zam", "zao", "zap", "zaq", "zar", "zas", "zat", "zau", "zav", "zaw", "zax", "zay", "zaz", "zbc", "zbe", "zbl", "zbt", "zbw", "zca", "zch", "zdj", "zea", "zeg", "zeh", "zen", "zga", "zgb", "zgh", "zgm", "zgn", "zgr", "zh", "zhb", "zhd", "zhi", "zhn", "zhw", "zhx", "zia", "zib", "zik", "zil", "zim", "zin", "zir", "ziw", "ziz", "zka", "zkb", "zkd", "zkg", "zkh", "zkk", "zkn", "zko", "zkp", "zkr", "zkt", "zku", "zkv", "zkz", "zle", "zlj", "zlm", "zln", "zlq", "zls", "zlw", "zma", "zmb", "zmc", "zmd", "zme", "zmf", "zmg", "zmh", "zmi", "zmj", "zmk", "zml", "zmm", "zmn", "zmo", "zmp", "zmq", "zmr", "zms", "zmt", "zmu", "zmv", "zmw", "zmx", "zmy", "zmz", "zna", "znd", "zne", "zng", "znk", "zns", "zoc", "zoh", "zom", "zoo", "zoq", "zor", "zos", "zpa", "zpb", "zpc", "zpd", "zpe", "zpf", "zpg", "zph", "zpi", "zpj", "zpk", "zpl", "zpm", "zpn", "zpo", "zpp", "zpq", "zpr", "zps", "zpt", "zpu", "zpv", "zpw", "zpx", "zpy", "zpz", "zqe", "zra", "zrg", "zrn", "zro", "zrp", "zrs", "zsa", "zsk", "zsl", "zsm", "zsr", "zsu", "zte", "ztg", "ztl", "ztm", "ztn", "ztp", "ztq", "zts", "ztt", "ztu", "ztx", "zty", "zu", "zua", "zuh", "zum", "zun", "zuy", "zwa", "zxx", "zyb", "zyg", "zyj", "zyn", "zyp", "zza", "zzj"];
var extlangJson = ["aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "aed", "aen", "afb", "afg", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "ase", "asf", "asp", "asq", "asw", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "bfi", "bfk", "bjn", "bog", "bqn", "bqy", "btj", "bve", "bvl", "bvu", "bzs", "cdo", "cds", "cjy", "cmn", "coa", "cpx", "csc", "csd", "cse", "csf", "csg", "csl", "csn", "csq", "csr", "czh", "czo", "doq", "dse", "dsl", "dup", "ecs", "esl", "esn", "eso", "eth", "fcs", "fse", "fsl", "fss", "gan", "gds", "gom", "gse", "gsg", "gsm", "gss", "gus", "hab", "haf", "hak", "hds", "hji", "hks", "hos", "hps", "hsh", "hsl", "hsn", "icl", "iks", "ils", "inl", "ins", "ise", "isg", "isr", "jak", "jax", "jcs", "jhs", "jls", "jos", "jsl", "jus", "kgi", "knn", "kvb", "kvk", "kvr", "kxd", "lbs", "lce", "lcf", "liw", "lls", "lsg", "lsl", "lsn", "lso", "lsp", "lst", "lsv", "lsy", "ltg", "lvs", "lws", "lzh", "max", "mdl", "meo", "mfa", "mfb", "mfs", "min", "mnp", "mqg", "mre", "msd", "msi", "msr", "mui", "mzc", "mzg", "mzy", "nan", "nbs", "ncs", "nsi", "nsl", "nsp", "nsr", "nzs", "okl", "orn", "ors", "pel", "pga", "pgz", "pks", "prl", "prz", "psc", "psd", "pse", "psg", "psl", "pso", "psp", "psr", "pys", "rms", "rsi", "rsl", "rsm", "sdl", "sfb", "sfs", "sgg", "sgx", "shu", "slf", "sls", "sqk", "sqs", "ssh", "ssp", "ssr", "svk", "swc", "swh", "swl", "syy", "szs", "tmw", "tse", "tsm", "tsq", "tss", "tsy", "tza", "ugn", "ugy", "ukl", "uks", "urk", "uzn", "uzs", "vgt", "vkk", "vkt", "vsi", "vsl", "vsv", "wbs", "wuu", "xki", "xml", "xmm", "xms", "yds", "ygs", "yhs", "ysl", "yue", "zib", "zlm", "zmi", "zsl", "zsm"];
var grandfatheredJson = ["art-lojban", "cel-gaulish", "en-gb-oed", "i-ami", "i-bnn", "i-default", "i-enochian", "i-hak", "i-klingon", "i-lux", "i-mingo", "i-navajo", "i-pwn", "i-tao", "i-tay", "i-tsu", "no-bok", "no-nyn", "sgn-be-fr", "sgn-be-nl", "sgn-ch-de", "zh-guoyu", "zh-hakka", "zh-min", "zh-min-nan", "zh-xiang"];
var regionJson = ["001", "002", "003", "005", "009", "011", "013", "014", "015", "017", "018", "019", "021", "029", "030", "034", "035", "039", "053", "054", "057", "061", "142", "143", "145", "150", "151", "154", "155", "202", "419", "aa", "ac", "ad", "ae", "af", "ag", "ai", "al", "am", "an", "ao", "aq", "ar", "as", "at", "au", "aw", "ax", "az", "ba", "bb", "bd", "be", "bf", "bg", "bh", "bi", "bj", "bl", "bm", "bn", "bo", "bq", "br", "bs", "bt", "bu", "bv", "bw", "by", "bz", "ca", "cc", "cd", "cf", "cg", "ch", "ci", "ck", "cl", "cm", "cn", "co", "cp", "cr", "cs", "cu", "cv", "cw", "cx", "cy", "cz", "dd", "de", "dg", "dj", "dk", "dm", "do", "dz", "ea", "ec", "ee", "eg", "eh", "er", "es", "et", "eu", "ez", "fi", "fj", "fk", "fm", "fo", "fr", "fx", "ga", "gb", "gd", "ge", "gf", "gg", "gh", "gi", "gl", "gm", "gn", "gp", "gq", "gr", "gs", "gt", "gu", "gw", "gy", "hk", "hm", "hn", "hr", "ht", "hu", "ic", "id", "ie", "il", "im", "in", "io", "iq", "ir", "is", "it", "je", "jm", "jo", "jp", "ke", "kg", "kh", "ki", "km", "kn", "kp", "kr", "kw", "ky", "kz", "la", "lb", "lc", "li", "lk", "lr", "ls", "lt", "lu", "lv", "ly", "ma", "mc", "md", "me", "mf", "mg", "mh", "mk", "ml", "mm", "mn", "mo", "mp", "mq", "mr", "ms", "mt", "mu", "mv", "mw", "mx", "my", "mz", "na", "nc", "ne", "nf", "ng", "ni", "nl", "no", "np", "nr", "nt", "nu", "nz", "om", "pa", "pe", "pf", "pg", "ph", "pk", "pl", "pm", "pn", "pr", "ps", "pt", "pw", "py", "qa", "re", "ro", "rs", "ru", "rw", "sa", "sb", "sc", "sd", "se", "sg", "sh", "si", "sj", "sk", "sl", "sm", "sn", "so", "sr", "ss", "st", "su", "sv", "sx", "sy", "sz", "ta", "tc", "td", "tf", "tg", "th", "tj", "tk", "tl", "tm", "tn", "to", "tp", "tr", "tt", "tv", "tw", "tz", "ua", "ug", "um", "un", "us", "uy", "uz", "va", "vc", "ve", "vg", "vi", "vn", "vu", "wf", "ws", "yd", "ye", "yt", "yu", "za", "zm", "zr", "zw", "zz"];
var scriptJson = ["adlm", "afak", "aghb", "ahom", "arab", "aran", "armi", "armn", "avst", "bali", "bamu", "bass", "batk", "beng", "bhks", "blis", "bopo", "brah", "brai", "bugi", "buhd", "cakm", "cans", "cari", "cham", "cher", "chrs", "cirt", "copt", "cpmn", "cprt", "cyrl", "cyrs", "deva", "diak", "dogr", "dsrt", "dupl", "egyd", "egyh", "egyp", "elba", "elym", "ethi", "geok", "geor", "glag", "gong", "gonm", "goth", "gran", "grek", "gujr", "guru", "hanb", "hang", "hani", "hano", "hans", "hant", "hatr", "hebr", "hira", "hluw", "hmng", "hmnp", "hrkt", "hung", "inds", "ital", "jamo", "java", "jpan", "jurc", "kali", "kana", "khar", "khmr", "khoj", "kitl", "kits", "knda", "kore", "kpel", "kthi", "lana", "laoo", "latf", "latg", "latn", "leke", "lepc", "limb", "lina", "linb", "lisu", "loma", "lyci", "lydi", "mahj", "maka", "mand", "mani", "marc", "maya", "medf", "mend", "merc", "mero", "mlym", "modi", "mong", "moon", "mroo", "mtei", "mult", "mymr", "nand", "narb", "nbat", "newa", "nkdb", "nkgb", "nkoo", "nshu", "ogam", "olck", "orkh", "orya", "osge", "osma", "palm", "pauc", "perm", "phag", "phli", "phlp", "phlv", "phnx", "piqd", "plrd", "prti", "rjng", "rohg", "roro", "runr", "samr", "sara", "sarb", "saur", "sgnw", "shaw", "shrd", "shui", "sidd", "sind", "sinh", "sogd", "sogo", "sora", "soyo", "sund", "sylo", "syrc", "syre", "syrj", "syrn", "tagb", "takr", "tale", "talu", "taml", "tang", "tavt", "telu", "teng", "tfng", "tglg", "thaa", "thai", "tibt", "tirh", "ugar", "vaii", "visp", "wara", "wcho", "wole", "xpeo", "xsux", "yezi", "yiii", "zanb", "zinh", "zmth", "zsye", "zsym", "zxxx", "zyyy", "zzzz"];
var variantJson = ["1606nict", "1694acad", "1901", "1959acad", "1994", "1996", "abl1943", "akuapem", "alalc97", "aluku", "ao1990", "aranes", "arevela", "arevmda", "asante", "auvern", "baku1926", "balanka", "barla", "basiceng", "bauddha", "biscayan", "biske", "bohoric", "boont", "bornholm", "cisaup", "colb1945", "cornu", "creiss", "dajnko", "ekavsk", "emodeng", "fonipa", "fonkirsh", "fonnapa", "fonupa", "fonxsamp", "gascon", "grclass", "grital", "grmistr", "hepburn", "heploc", "hognorsk", "hsistemo", "ijekavsk", "itihasa", "ivanchov", "jauer", "jyutping", "kkcor", "kociewie", "kscor", "laukika", "lemosin", "lengadoc", "lipaw", "luna1918", "metelko", "monoton", "ndyuka", "nedis", "newfound", "nicard", "njiva", "nulik", "osojs", "oxendict", "pahawh2", "pahawh3", "pahawh4", "pamaka", "petr1708", "pinyin", "polyton", "provenc", "puter", "rigik", "rozaj", "rumgr", "scotland", "scouse", "simple", "solba", "sotav", "spanglis", "surmiran", "sursilv", "sutsilv", "tarask", "uccor", "ucrcor", "ulster", "unifon", "vaidika", "valencia", "vallader", "vivaraup", "wadegile", "xsistemo"];
var language = languageJson;
var extlang = extlangJson;
var grandfathered = grandfatheredJson;
var region = regionJson;
var script = scriptJson;
var variant = variantJson;

function isRegExp(something) {
  return something instanceof RegExp;
}

function includes(arr, whatToMatch) {
  if (!Array.isArray(arr) || !arr.length) {
    return false;
  }

  return arr.some(function (val) {
    return isRegExp(val) && whatToMatch.match(val) || typeof val === "string" && whatToMatch === val;
  });
}

function isLangCode(str) {
  if (typeof str !== "string") {
    return {
      res: false,
      message: "Not a string given."
    };
  }

  if (!str.trim()) {
    return {
      res: false,
      message: "Empty language tag string given."
    };
  }

  var r1 = /^[a-z0-9]{1,8}(-[a-z0-9]{1,8})*$/gi;
  var r2 = /^q[a-t][a-z]$/gi;
  language.push(r2);
  var r3 = /^qa[a-b][a-x]$/gi;
  script.push(r3);
  var r4 = /^q[m-z]$/gi;
  region.push(r4);
  var r5 = /^x[a-z]$/gi;
  region.push(r5);
  var singletonRegex = /^[0-9a-wy-z]$/gi;

  if (!str.match(r1)) {
    return {
      res: false,
      message: "Does not resemble a language tag."
    };
  }

  if (includes(grandfathered, str)) {
    return {
      res: true,
      message: null
    };
  }

  var split = str.toLowerCase().split("-");
  var type;
  var languageMatched;
  var scriptMatched;
  var regionMatched;
  var variantMatched;
  var extlangMatched;
  var allOK;
  var variantGathered = [];
  var singletonGathered = [];

  for (var i = 0, len = split.length; i < len; i++) {
    allOK = false;

    if (i === 0) {
      type = split[0] === "x" ? "private" : "normal";
    }

    if (split[i] === "x") {
      if (!split[i + 1]) {
        return {
          res: false,
          message: "Ends with private use subtag, \"x\"."
        };
      }

      return {
        res: true,
        message: null
      };
    }

    if (regionMatched && region.includes(split[i])) {
      return {
        res: false,
        message: "Two region subtags, \"" + regionMatched + "\" and \"" + split[i] + "\"."
      };
    }

    if (i === 0) {
      if (type === "normal") {
        if (includes(language, split[i])) {
          languageMatched = split[i];
          allOK = true;
        }
      }
    } else if (i === 1) {
      if (type === "normal") {
        if (includes(script, split[i])) {
          scriptMatched = split[i];
          allOK = true;
        } else if (includes(extlang, split[i])) {
          extlangMatched = split[i];
          allOK = true;
        } else if (includes(region, split[i])) {
          regionMatched = split[i];
          allOK = true;
        } else if (includes(variant, split[i])) {
          variantMatched = split[i];
          allOK = true;

          if (!variantGathered.includes(split[i])) {
            variantGathered.push(split[i]);
          } else {
            return {
              res: false,
              message: "Repeated variant subtag, \"" + split[i] + "\"."
            };
          }
        } else ;
      }
    } else if (i === 2) {
      if (type === "normal") {
        if (languageMatched && extlangMatched) {
          if (includes(script, split[i])) {
            scriptMatched = split[i];
            allOK = true;
          } else if (includes(region, split[i])) {
            regionMatched = split[i];
            allOK = true;
          }
        } else if (languageMatched && scriptMatched) {
          if (includes(region, split[i])) {
            regionMatched = split[i];
            allOK = true;
          }
        } else if (languageMatched && regionMatched) {
          if (includes(variant, split[i])) {
            variantMatched = split[i];
            allOK = true;

            if (!variantGathered.includes(split[i])) {
              variantGathered.push(split[i]);
            } else {
              return {
                res: false,
                message: "Repeated variant subtag, \"" + split[i] + "\"."
              };
            }
          }
        }
      }
    } else if (i === 3) {
      if (type === "normal") {
        if (languageMatched && extlangMatched && scriptMatched) {
          if (includes(region, split[i])) {
            regionMatched = split[i];
            allOK = true;
          }
        } else if (languageMatched && scriptMatched && regionMatched) {
          if (includes(variant, split[i])) {
            variantMatched = split[i];
            allOK = true;
          }
        }
      }
    }

    if (split[i].match(singletonRegex)) {
      if (i === 0) {
        return {
          res: false,
          message: "Starts with singleton, \"" + split[i] + "\"."
        };
      }

      if (!languageMatched) {
        return {
          res: false,
          message: "Extension must follow at least a primary language subtag."
        };
      }

      if (!singletonGathered.includes(split[i])) {
        singletonGathered.push(split[i]);
      } else {
        return {
          res: false,
          message: "Two extensions with same single-letter prefix \"" + split[i] + "\"."
        };
      }

      if (split[i + 1]) {
        if (!split[i + 1].match(singletonRegex)) {
          allOK = true;
          extlangMatched = split[i];
          i += 1;
          continue;
        } else {
          return {
            res: false,
            message: "Multiple singleton sequence \"" + split[i] + "\", \"" + split[i + 1] + "\"."
          };
        }
      } else {
        return {
          res: false,
          message: "Ends with singleton, \"" + split[i] + "\"."
        };
      }
    }

    if (!allOK && variantMatched && includes(variant, split[i])) {
      if (i && includes(variant, split[i - 1])) {
        if (!variantGathered.includes(split[i])) {
          variantGathered.push(split[i]);
        } else {
          return {
            res: false,
            message: "Repeated variant subtag, \"" + split[i] + "\"."
          };
        }

        allOK = true;
      } else {
        variantGathered.push(split[i]);
        return {
          res: false,
          message: "Variant subtags " + variantGathered.map(function (val) {
            return "\"" + val + "\"";
          }).join(", ") + "  not in a sequence."
        };
      }
    }

    if (!allOK && languageMatched && extlangMatched) {
      if (split[i].length > 1) {
        allOK = true;
      }
    }

    if (!allOK) {
      return {
        res: false,
        message: "Unrecognised language subtag, \"" + split[i] + "\"."
      };
    }
  }

  return {
    res: true,
    message: null
  };
}

// -----------------------------------------------------------------------------

function attributeValidateHreflang(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "hreflang") {
        // validate the parent
        if (!["a", "link"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-hreflang",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // beware, the charStart and charEnd are not offset, their "zero" is
        // start of an attribute's value, so if you use them, you need to
        // offset to the true index, you must add "(node.attribValueStartsAt as number)" value


        var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
            charStart = _checkForWhitespace.charStart,
            charEnd = _checkForWhitespace.charEnd,
            errorArr = _checkForWhitespace.errorArr; // validate using "ietf-language-tag-regex" from npm:

        var _isLangCode = isLangCode(node.attribValueRaw.slice(charStart, charEnd)),
            message = _isLangCode.message;

        if (message) {
          errorArr.push({
            idxFrom: node.attribValueStartsAt + charStart,
            idxTo: node.attribValueStartsAt + charEnd,
            message: message,
            fix: null
          });
        }

        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-hreflang"
          }));
        });
      }
    }
  };
}

function attributeValidateHspace(context) {
  return {
    attribute: function attribute(node) { // console.log(
      //   `015 attributeValidateHspace(): node = ${JSON.stringify(node, null, 4)}`
      // );

      if (node.attribName === "hspace") {
        // validate the parent
        if (!["applet", "img", "object"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-hspace",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        }

        var errorArr = validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
          theOnlyGoodUnits: [],
          noUnitsIsFine: true
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-hspace"
          }));
        });
      }
    }
  };
}

function attributeValidateHttpequiv(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "http-equiv") {
        // validate the parent
        if (node.parent.tagName !== "meta") {
          context.report({
            ruleId: "attribute-validate-http-equiv",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // check in two parts, first, a quick try, match the most common values only


        var errorArr = validateString(node.attribValueRaw, // value
        node.attribValueStartsAt, // offset
        {
          permittedValues: ["content-type", "default-style", "refresh", "X-UA-Compatible"],
          canBeCommaSeparated: false,
          caseInsensitive: true
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-http-equiv"
          }));
        });
      }
    }
  };
}

function attributeValidateId(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "id") {
        // validate the parent
        if (["base", "head", "html", "meta", "script", "style", "title"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-id",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
                charStart = _checkForWhitespace.charStart,
                charEnd = _checkForWhitespace.charEnd,
                errorArr = _checkForWhitespace.errorArr;
            checkClassOrIdValue(context.str, {
              typeName: node.attribName,
              from: node.attribValueStartsAt + charStart,
              to: node.attribValueStartsAt + charEnd,
              offset: 0
            }, errorArr // might be mutated, more errors pushed into
            );
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-id"
              }));
            });
          }
      }
    }
  };
}

function attributeValidateIsmap(context, mode) {
  return {
    attribute: function attribute(node) {
      var errorArr = [];

      if (node.attribName === "ismap") {
        // validate the parent
        if (!["img", "input"].includes(node.parent.tagName)) {
          errorArr.push({
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          // validate the value (or absence thereof)
          validateVoid(node, context, errorArr, {
            xhtml: !!mode,
            enforceSiblingAttributes: null
          });
        } // finally, report gathered errors:


        if (errorArr.length) {
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-ismap"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateLabel(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "label") {
        // validate the parent
        if (!["option", "optgroup"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-label",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          // only check for rogue whitespace - value can be any CDATA
          var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-label"
            }));
          });
        }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateLang(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "lang") {
        // validate the parent
        if (["applet", "base", "basefont", "br", "frame", "frameset", "iframe", "param", "script"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-lang",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // beware, the charStart and charEnd are not offset, their "zero" is
        // start of an attribute's value, so if you use them, you need to
        // offset to the true index, you must add "node.attribValueStartsAt" value


        var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
            charStart = _checkForWhitespace.charStart,
            charEnd = _checkForWhitespace.charEnd,
            errorArr = _checkForWhitespace.errorArr; // validate using "is-language-code" from npm:

        var _isLangCode = isLangCode(node.attribValueRaw.slice(charStart, charEnd)),
            message = _isLangCode.message;

        if (message) {
          errorArr.push({
            idxFrom: node.attribValueStartsAt + charStart,
            idxTo: node.attribValueStartsAt + charEnd,
            message: message,
            fix: null
          });
        }

        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-lang"
          }));
        });
      }
    }
  };
}

function attributeValidateLanguage(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "language") {
        // validate the parent
        if (node.parent.tagName !== "script") {
          context.report({
            ruleId: "attribute-validate-language",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          // only check for rogue whitespace - value can be any CDATA
          var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-language"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateLink(context) {
  return {
    attribute: function attribute(node) { // console.log(
      //   `015 attributeValidateLink(): node = ${JSON.stringify(node, null, 4)}`
      // );

      if (node.attribName === "link") {
        // validate the parent
        if (node.parent.tagName !== "body") {
          context.report({
            ruleId: "attribute-validate-link",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          var errorArr = validateColor(node.attribValueRaw, node.attribValueStartsAt, {
            namedCssLevel1OK: true,
            namedCssLevel2PlusOK: true,
            hexThreeOK: false,
            hexFourOK: false,
            hexSixOK: true,
            hexEightOK: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-link"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateLongdesc(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "longdesc") {
        // validate the parent
        if (!["img", "frame", "iframe"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-longdesc",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          // only check for rogue whitespace -
          // TODO - add more rules, https://www.w3schools.com/TagS/att_img_longdesc.asp
          var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-longdesc"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateMarginheight(context) {
  return {
    attribute: function attribute(node) { // console.log(
      //   `015 attributeValidateMarginheight(): node = ${JSON.stringify(node, null, 4)}`
      // );

      if (node.attribName === "marginheight") {
        // validate the parent
        if (!["frame", "iframe"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-marginheight",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        }

        var errorArr = validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
          theOnlyGoodUnits: [],
          noUnitsIsFine: true
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-marginheight"
          }));
        });
      }
    }
  };
}

function attributeValidateMarginwidth(context) {
  return {
    attribute: function attribute(node) { // console.log(
      //   `015 attributeValidateMarginwidth(): node = ${JSON.stringify(node, null, 4)}`
      // );

      if (node.attribName === "marginwidth") {
        // validate the parent
        if (!["frame", "iframe"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-marginwidth",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        }

        var errorArr = validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
          theOnlyGoodUnits: [],
          noUnitsIsFine: true
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-marginwidth"
          }));
        });
      }
    }
  };
}

function attributeValidateMaxlength(context) {
  return {
    attribute: function attribute(node) { // console.log(
      //   `015 attributeValidateMaxlength(): node = ${JSON.stringify(node, null, 4)}`
      // );

      if (node.attribName === "maxlength") {
        // validate the parent
        if (node.parent.tagName !== "input") {
          context.report({
            ruleId: "attribute-validate-maxlength",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        }

        var errorArr = validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
          type: "integer",
          theOnlyGoodUnits: [],
          customGenericValueError: "Should be integer, no units."
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-maxlength"
          }));
        });
      }
    }
  };
}

var recognisedMediaTypes = ["all", "aural", "braille", "embossed", "handheld", "print", "projection", "screen", "speech", "tty", "tv"];
var recognisedMediaFeatures = ["width", "min-width", "max-width", "height", "min-height", "max-height", "aspect-ratio", "min-aspect-ratio", "max-aspect-ratio", "orientation", "resolution", "min-resolution", "max-resolution", "scan", "grid", "update", "overflow-block", "overflow-inline", "color", "min-color", "max-color", "color-index", "min-color-index", "max-color-index", "monochrome", "color-gamut", "pointer", "hover", "any-pointer", "any-hover"];
var lettersOnlyRegex = /^\w+$/g;

function loop(str, opts, res) {
  var chunkStartsAt = null;
  var gatheredChunksArr = [];
  var whitespaceStartsAt = null;
  var nextCanBeMediaType = true;
  var nextCanBeMediaCondition = true;
  var nextCanBeNotOrOnly = true;
  var nextCanBeAnd = false;
  var bracketOpeningIndexes = [];

  for (var i = opts.idxFrom; i <= opts.idxTo; i++) {
    if (str[i] === ")") {
      var lastOpening = bracketOpeningIndexes.pop();
      var extractedValueWithinBrackets = str.slice(lastOpening + 1, i);

      if (!extractedValueWithinBrackets.includes("(") && !extractedValueWithinBrackets.includes(")")) {
        if (extractedValueWithinBrackets.match(lettersOnlyRegex)) {
          if (!recognisedMediaFeatures.includes(extractedValueWithinBrackets.toLowerCase().trim())) {
            res.push({
              idxFrom: lastOpening + 1 + opts.offset,
              idxTo: i + opts.offset,
              message: "Unrecognised \"" + extractedValueWithinBrackets.trim() + "\".",
              fix: null
            });
          }
        }
      }

      var regexFromAllKnownMediaTypes = new RegExp(recognisedMediaTypes.join("|"), "gi");
      var findings = extractedValueWithinBrackets.match(regexFromAllKnownMediaTypes) || [];
      findings.forEach(function (mediaTypeFound) {
        var startingIdx = str.indexOf(mediaTypeFound);
        res.push({
          idxFrom: startingIdx + opts.offset,
          idxTo: startingIdx + mediaTypeFound.length + opts.offset,
          message: "Media type \"" + mediaTypeFound + "\" inside brackets.",
          fix: null
        });
      });
    }

    if (str[i] === "(") {
      bracketOpeningIndexes.push(i);
    }

    if (str[i] && str[i].trim().length && whitespaceStartsAt !== null) {
      if (str[whitespaceStartsAt - 1] === "(" || str[i] === ")") {
        res.push({
          idxFrom: whitespaceStartsAt + opts.offset,
          idxTo: i + opts.offset,
          message: "Bad whitespace.",
          fix: {
            ranges: [[whitespaceStartsAt + opts.offset, i + opts.offset]]
          }
        });
      } else if (whitespaceStartsAt < i - 1 || str[i - 1] !== " ") {
        var rangesFrom = whitespaceStartsAt + opts.offset;
        var rangesTo = i + opts.offset;
        var rangesInsert = " ";

        if (whitespaceStartsAt !== i - 1) {
          if (str[whitespaceStartsAt] === " ") {
            rangesFrom += 1;
            rangesInsert = null;
          } else if (str[i - 1] === " ") {
            rangesTo -= 1;
            rangesInsert = null;
          }
        }

        res.push({
          idxFrom: whitespaceStartsAt + opts.offset,
          idxTo: i + opts.offset,
          message: "Bad whitespace.",
          fix: {
            ranges: [rangesInsert ? [rangesFrom, rangesTo, " "] : [rangesFrom, rangesTo]]
          }
        });
      }

      whitespaceStartsAt = null;
    }

    if (str[i] && !str[i].trim().length && whitespaceStartsAt === null) {
      whitespaceStartsAt = i;
    }

    if (chunkStartsAt !== null && (!str[i] || !str[i].trim().length) && !bracketOpeningIndexes.length) {
      var chunk = str.slice(chunkStartsAt, i);
      gatheredChunksArr.push(chunk.toLowerCase());

      if (nextCanBeAnd && (!(nextCanBeMediaType || nextCanBeMediaCondition) || chunk === "and")) {
        if (chunk.toLowerCase() !== "and") {
          res.push({
            idxFrom: chunkStartsAt + opts.offset,
            idxTo: i + opts.offset,
            message: "Expected \"and\", found \"" + chunk + "\".",
            fix: null
          });
        } else if (!str[i]) {
          res.push({
            idxFrom: chunkStartsAt + opts.offset,
            idxTo: i + opts.offset,
            message: "Dangling \"" + chunk + "\".",
            fix: {
              ranges: [[str.slice(0, chunkStartsAt).trim().length + opts.offset, i + opts.offset]]
            }
          });
        }

        nextCanBeAnd = false;
        nextCanBeMediaCondition = true;
      } else if (nextCanBeNotOrOnly && ["not", "only"].includes(chunk)) {
        nextCanBeNotOrOnly = false;
        nextCanBeMediaCondition = false;
      } else if (nextCanBeMediaType || nextCanBeMediaCondition) {
        if (chunk.startsWith("(")) {
          if (nextCanBeMediaCondition) ;else {
            var message = "Media condition \"" + str.slice(chunkStartsAt, i) + "\" can't be here.";

            if (gatheredChunksArr[gatheredChunksArr.length - 2] === "not") {
              message = "\"not\" can be only in front of media type.";
            }

            res.push({
              idxFrom: chunkStartsAt + opts.offset,
              idxTo: i + opts.offset,
              message: message,
              fix: null
            });
          }
        } else {
          if (nextCanBeMediaType) {
            if (recognisedMediaTypes.includes(chunk.toLowerCase())) {
              nextCanBeMediaType = false;
              nextCanBeMediaCondition = false;
            } else {
              var _message = "Unrecognised \"" + chunk + "\".";

              if (!chunk.match(/\w/g)) {
                _message = "Strange symbol" + (chunk.trim().length === 1 ? "" : "s") + " \"" + chunk + "\".";
              } else if (["and", "only", "or", "not"].includes(chunk.toLowerCase())) {
                _message = "\"" + chunk + "\" instead of a media type.";
              }

              res.push({
                idxFrom: chunkStartsAt + opts.offset,
                idxTo: i + opts.offset,
                message: _message,
                fix: null
              });
            }
          } else {
            var _message2 = "Expected brackets on \"" + chunk + "\".";

            var fix = null;
            var idxTo = i + opts.offset;

            if (["not", "else", "or"].includes(chunk.toLowerCase())) {
              _message2 = "\"" + chunk + "\" can't be here.";
            } else if (recognisedMediaTypes.includes(chunk.toLowerCase())) {
              _message2 = "Unexpected media type, try using a comma.";
            } else if (recognisedMediaFeatures.includes(chunk.toLowerCase())) {
              _message2 = "Missing brackets.";
              fix = {
                ranges: [[chunkStartsAt + opts.offset, chunkStartsAt + opts.offset, "("], [i + opts.offset, i + opts.offset, ")"]]
              };
            } else if (str.slice(i).trim().startsWith(":")) {
              var valueWithoutColon = chunk.slice(0, i).trim();
              _message2 = "Expected brackets on \"" + valueWithoutColon + "\" and its value.";
              idxTo = chunkStartsAt + valueWithoutColon.length + opts.offset;
            }

            res.push({
              idxFrom: chunkStartsAt + opts.offset,
              idxTo: idxTo,
              message: _message2,
              fix: fix
            });
            break;
          }
        }

        nextCanBeAnd = true;
      } else {
        res.push({
          idxFrom: chunkStartsAt + opts.offset,
          idxTo: i + opts.offset,
          message: "Unrecognised media type \"" + str.slice(chunkStartsAt, i) + "\".",
          fix: null
        });
      }

      chunkStartsAt = null;

      if (nextCanBeNotOrOnly) {
        nextCanBeNotOrOnly = false;
      }
    }

    if (chunkStartsAt === null && str[i] && str[i].trim().length && str[i] !== ")") {
      if (str[i] === "(") ;
      chunkStartsAt = i;
    }
  }
}
var defaults = {
  offset: 0
};

function isMediaD(originalStr, originalOpts) {
  var opts = _objectSpread2(_objectSpread2({}, defaults), originalOpts);

  if (opts.offset && !Number.isInteger(opts.offset)) {
    throw new Error("is-media-descriptor: [THROW_ID_01] opts.offset must be an integer, it was given as " + opts.offset + " (type " + typeof opts.offset + ")");
  }

  if (!opts.offset) {
    opts.offset = 0;
  }

  if (typeof originalStr !== "string") {
    return [];
  }

  if (!originalStr.trim()) {
    return [];
  }

  var res = [];
  var nonWhitespaceStart = 0;
  var nonWhitespaceEnd = originalStr.length;
  var str = originalStr.trim();

  if (originalStr !== originalStr.trim()) {
    var ranges = [];

    if (!originalStr[0].trim()) {
      for (var i = 0, len = originalStr.length; i < len; i++) {
        if (originalStr[i].trim()) {
          ranges.push([0 + opts.offset, i + opts.offset]);
          nonWhitespaceStart = i;
          break;
        }
      }
    }

    if (!originalStr[originalStr.length - 1].trim()) {
      for (var _i = originalStr.length; _i--;) {
        if (originalStr[_i].trim()) {
          ranges.push([_i + 1 + opts.offset, originalStr.length + opts.offset]);
          nonWhitespaceEnd = _i + 1;
          break;
        }
      }
    }

    res.push({
      idxFrom: ranges[0][0],
      idxTo: ranges[ranges.length - 1][1],
      message: "Remove whitespace.",
      fix: {
        ranges: ranges
      }
    });
  }

  if (recognisedMediaTypes.includes(str)) {
    return res;
  }

  if (["only", "not"].includes(str)) {
    res.push({
      idxFrom: nonWhitespaceStart + opts.offset,
      idxTo: nonWhitespaceEnd + opts.offset,
      message: "Missing media type or condition.",
      fix: null
    });
  } else if (str.match(lettersOnlyRegex) && !str.includes("(") && !str.includes(")")) {
    for (var _i2 = 0, _len = recognisedMediaTypes.length; _i2 < _len; _i2++) {
      if (leven_1(recognisedMediaTypes[_i2], str) === 1) {
        res.push({
          idxFrom: nonWhitespaceStart + opts.offset,
          idxTo: nonWhitespaceEnd + opts.offset,
          message: "Did you mean \"" + recognisedMediaTypes[_i2] + "\"?",
          fix: {
            ranges: [[nonWhitespaceStart + opts.offset, nonWhitespaceEnd + opts.offset, recognisedMediaTypes[_i2]]]
          }
        });
        break;
      }

      if (_i2 === _len - 1) {
        res.push({
          idxFrom: nonWhitespaceStart + opts.offset,
          idxTo: nonWhitespaceEnd + opts.offset,
          message: "Unrecognised media type \"" + str + "\".",
          fix: null
        });
      }
    }
  } else {
    var wrongOrder = false;

    var _Array$from$reduce = Array.from(str).reduce(function (acc, curr, idx) {
      if (curr === ")") {
        if (!wrongOrder && acc[1] + 1 > acc[0]) {
          wrongOrder = true;
        }

        return [acc[0], acc[1] + 1];
      }

      if (curr === "(") {
        return [acc[0] + 1, acc[1]];
      }

      if (curr === ";") {
        res.push({
          idxFrom: idx + opts.offset,
          idxTo: idx + 1 + opts.offset,
          message: "Semicolon found!",
          fix: null
        });
      }

      return acc;
    }, [0, 0]),
        openingBracketCount = _Array$from$reduce[0],
        closingBracketCount = _Array$from$reduce[1];

    if (wrongOrder && openingBracketCount === closingBracketCount) {
      res.push({
        idxFrom: nonWhitespaceStart + opts.offset,
        idxTo: nonWhitespaceEnd + opts.offset,
        message: "Some closing brackets are before their opening counterparts.",
        fix: null
      });
    }

    if (openingBracketCount > closingBracketCount) {
      res.push({
        idxFrom: nonWhitespaceStart + opts.offset,
        idxTo: nonWhitespaceEnd + opts.offset,
        message: "More opening brackets than closing.",
        fix: null
      });
    } else if (closingBracketCount > openingBracketCount) {
      res.push({
        idxFrom: nonWhitespaceStart + opts.offset,
        idxTo: nonWhitespaceEnd + opts.offset,
        message: "More closing brackets than opening.",
        fix: null
      });
    }

    if (!res.length && str.match(/\(\s*\)/g)) {
      var lastOpening = null;
      var nonWhitespaceFound;

      for (var _i3 = 0, _len2 = str.length; _i3 < _len2; _i3++) {
        if (str[_i3] === "(") {
          lastOpening = _i3;
          nonWhitespaceFound = false;
        } else if (str[_i3] === ")" && lastOpening) {
          if (!nonWhitespaceFound) {
            res.push({
              idxFrom: lastOpening + opts.offset,
              idxTo: _i3 + 1 + opts.offset,
              message: "Empty bracket pair.",
              fix: null
            });
          } else {
            nonWhitespaceFound = true;
          }
        } else if (str[_i3].trim()) {
          nonWhitespaceFound = true;
        }
      }
    }

    if (res.length) {
      return res;
    }

    processCommaSep(str, {
      offset: opts.offset,
      leadingWhitespaceOK: false,
      trailingWhitespaceOK: false,
      oneSpaceAfterCommaOK: true,
      innerWhitespaceAllowed: true,
      separator: ",",
      cb: function cb(idxFrom, idxTo) {
        loop(str, _objectSpread2(_objectSpread2({}, opts), {}, {
          idxFrom: idxFrom - opts.offset,
          idxTo: idxTo - opts.offset
        }), res);
      },
      errCb: function errCb(ranges, message) {}
    });
  }

  return res;
}

// -----------------------------------------------------------------------------

function attributeValidateMedia(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "media") {
        // validate the parent
        if (!["style", "link"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-media",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // beware, the charStart and charEnd are not offset, their "zero" is
        // start of an attribute's value, so if you use them, you need to
        // offset to the true index, you must add "(node.attribValueStartsAt as number)" value


        var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
            charStart = _checkForWhitespace.charStart,
            charEnd = _checkForWhitespace.charEnd,
            errorArr = _checkForWhitespace.errorArr; // concat errors from "is-media-descriptor" and report all:

        errorArr.concat(isMediaD(node.attribValueRaw.slice(charStart, charEnd), {
          offset: node.attribValueStartsAt
        })).forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-media"
          }));
        });
      }
    }
  };
}

function attributeValidateMethod(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "method") {
        // validate the parent
        if (node.parent.tagName !== "form") {
          context.report({
            ruleId: "attribute-validate-method",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // check in two parts, first, a quick try, match the most common values only


        var errorArr = validateString(node.attribValueRaw, // value
        node.attribValueStartsAt, // offset
        {
          permittedValues: ["get", "post"],
          canBeCommaSeparated: false
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-method"
          }));
        });
      }
    }
  };
}

function attributeValidateMultiple(context, mode) {
  return {
    attribute: function attribute(node) {
      var errorArr = [];

      if (node.attribName === "multiple") {
        // validate the parent
        if (node.parent.tagName !== "select") {
          errorArr.push({
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          // validate the value (or absence thereof)
          validateVoid(node, context, errorArr, {
            xhtml: !!mode,
            enforceSiblingAttributes: null
          });
        } // finally, report gathered errors:


        if (errorArr.length) {
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-multiple"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateName(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "name") {
        // validate the parent
        if (!["button", "textarea", "applet", "select", "form", "frame", "iframe", "img", "a", "input", "object", "map", "param", "meta"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-name",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          // only check for rogue whitespace because value can be any CDATA
          var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-name"
            }));
          });
        }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateNohref(context, mode) {
  return {
    attribute: function attribute(node) {
      var errorArr = [];

      if (node.attribName === "nohref") {
        // validate the parent
        if (node.parent.tagName !== "area") {
          errorArr.push({
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          // validate the value (or absence thereof)
          validateVoid(node, context, errorArr, {
            xhtml: !!mode,
            enforceSiblingAttributes: null
          });
        } // finally, report gathered errors:


        if (errorArr.length) {
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-nohref"
            }));
          });
        }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateNoresize(context, mode) {
  return {
    attribute: function attribute(node) {
      var errorArr = [];

      if (node.attribName === "noresize") {
        // validate the parent
        if (node.parent.tagName !== "frame") {
          errorArr.push({
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          // validate the value (or absence thereof)
          validateVoid(node, context, errorArr, {
            xhtml: !!mode,
            enforceSiblingAttributes: null
          });
        } // finally, report gathered errors:


        if (errorArr.length) {
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-noresize"
            }));
          });
        }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateNoshade(context, mode) {
  return {
    attribute: function attribute(node) {
      var errorArr = [];

      if (node.attribName === "noshade") {
        // validate the parent
        if (node.parent.tagName !== "hr") {
          errorArr.push({
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          // validate the value (or absence thereof)
          validateVoid(node, context, errorArr, {
            xhtml: !!mode,
            enforceSiblingAttributes: null
          });
        } // finally, report gathered errors:


        if (errorArr.length) {
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-noshade"
            }));
          });
        }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateNowrap(context, mode) {
  return {
    attribute: function attribute(node) {
      var errorArr = [];

      if (node.attribName === "nowrap") {
        // validate the parent
        if (!["td", "th"].includes(node.parent.tagName)) {
          errorArr.push({
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          // validate the value (or absence thereof)
          validateVoid(node, context, errorArr, {
            xhtml: !!mode,
            enforceSiblingAttributes: null
          });
        } // finally, report gathered errors:


        if (errorArr.length) {
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-nowrap"
            }));
          });
        }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateObject(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "object") {
        // validate the parent
        if (node.parent.tagName !== "applet") {
          context.report({
            ruleId: "attribute-validate-object",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          // only check for rogue whitespace - value can be any CDATA
          var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-object"
            }));
          });
        }
      }
    }
  };
}

function validateScript(str, idxOffset // opts
) {
  // console.log(
  //   `005 validateScript(): ${`\u001b[${33}m${`opts`}\u001b[${39}m`} = ${JSON.stringify(
  //     opts,
  //     null,
  //     4
  //   )}`
  // );
  // we get trimmed string start and end positions, also an encountered errors array
  // const { charStart, charEnd, errorArr } = checkForWhitespace(str, idxOffset);
  var _checkForWhitespace = checkForWhitespace(str, idxOffset),
      errorArr = _checkForWhitespace.errorArr; // now that we know where non-whitespace chars are, we can evaluate them
  // if (Number.isInteger(charStart)) {
  //   TODO: SOMETHING MORE
  // }


  return errorArr;
}

// -----------------------------------------------------------------------------

function attributeValidateOnblur(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "onblur") {
        // validate the parent
        if (!["a", "area", "button", "input", "label", "select", "textarea"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-onblur",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValueRaw, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-onblur"
              }));
            });
          }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateOnchange(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "onchange") {
        // validate the parent
        if (!["input", "select", "textarea"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-onchange",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValueRaw, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-onchange"
              }));
            });
          }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateOnclick(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "onclick") {
        // validate the parent
        if (["applet", "base", "basefont", "bdo", "br", "font", "frame", "frameset", "head", "html", "iframe", "isindex", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-onclick",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValueRaw, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-onclick"
              }));
            });
          }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateOndblclick(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "ondblclick") {
        // validate the parent
        if (["applet", "base", "basefont", "bdo", "br", "font", "frame", "frameset", "head", "html", "iframe", "isindex", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-ondblclick",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValueRaw, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-ondblclick"
              }));
            });
          }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateOnfocus(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "onfocus") {
        // validate the parent
        if (!["a", "area", "button", "input", "label", "select", "textarea"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-onfocus",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValueRaw, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-onfocus"
              }));
            });
          }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateOnkeydown(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "onkeydown") {
        // validate the parent
        if (["applet", "base", "basefont", "bdo", "br", "font", "frame", "frameset", "head", "html", "iframe", "isindex", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-onkeydown",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValueRaw, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-onkeydown"
              }));
            });
          }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateOnkeypress(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "onkeypress") {
        // validate the parent
        if (["applet", "base", "basefont", "bdo", "br", "font", "frame", "frameset", "head", "html", "iframe", "isindex", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-onkeypress",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValueRaw, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-onkeypress"
              }));
            });
          }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateOnkeyup(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "onkeyup") {
        // validate the parent
        if (["applet", "base", "basefont", "bdo", "br", "font", "frame", "frameset", "head", "html", "iframe", "isindex", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-onkeyup",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValueRaw, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-onkeyup"
              }));
            });
          }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateOnload(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "onload") {
        // validate the parent
        if (!["frameset", "body"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-onload",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValueRaw, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-onload"
              }));
            });
          }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateOnmousedown(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "onmousedown") {
        // validate the parent
        if (["applet", "base", "basefont", "bdo", "br", "font", "frame", "frameset", "head", "html", "iframe", "isindex", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-onmousedown",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValueRaw, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-onmousedown"
              }));
            });
          }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateOnmousemove(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "onmousemove") {
        // validate the parent
        if (["applet", "base", "basefont", "bdo", "br", "font", "frame", "frameset", "head", "html", "iframe", "isindex", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-onmousemove",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValueRaw, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-onmousemove"
              }));
            });
          }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateOnmouseout(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "onmouseout") {
        // validate the parent
        if (["applet", "base", "basefont", "bdo", "br", "font", "frame", "frameset", "head", "html", "iframe", "isindex", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-onmouseout",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValueRaw, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-onmouseout"
              }));
            });
          }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateOnmouseover(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "onmouseover") {
        // validate the parent
        if (["applet", "base", "basefont", "bdo", "br", "font", "frame", "frameset", "head", "html", "iframe", "isindex", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-onmouseover",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValueRaw, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-onmouseover"
              }));
            });
          }
      }
    }
  };
}

function attributeValidateOnmouseup(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "onmouseup") {
        // validate the parent
        if (["applet", "base", "basefont", "bdo", "br", "font", "frame", "frameset", "head", "html", "iframe", "isindex", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-onmouseup",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValueRaw, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-onmouseup"
              }));
            });
          }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateOnreset(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "onreset") {
        // validate the parent
        if (node.parent.tagName !== "form") {
          context.report({
            ruleId: "attribute-validate-onreset",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValueRaw, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-onreset"
              }));
            });
          }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateOnsubmit(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "onsubmit") {
        // validate the parent
        if (node.parent.tagName !== "form") {
          context.report({
            ruleId: "attribute-validate-onsubmit",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValueRaw, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-onsubmit"
              }));
            });
          }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateOnselect(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "onselect") {
        // validate the parent
        if (!["input", "textarea"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-onselect",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValueRaw, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-onselect"
              }));
            });
          }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateOnunload(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "onunload") {
        // validate the parent
        if (!["frameset", "body"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-onunload",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist
        else if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
            context.report({
              ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
              idxFrom: node.attribStarts,
              idxTo: node.attribEnds,
              message: "Missing value.",
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValueRaw, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-onunload"
              }));
            });
          }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateProfile(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "profile") {
        // validate the parent
        if (node.parent.tagName !== "head") {
          context.report({
            ruleId: "attribute-validate-profile",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          // Call validation upon whole attribute's value. Validator includes
          // whitespace checks.
          validateUri(node.attribValueRaw, {
            offset: node.attribValueStartsAt,
            multipleOK: true
          }).forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-profile"
            }));
          });
        }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidatePrompt(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "prompt") {
        // validate the parent
        if (node.parent.tagName !== "isindex") {
          context.report({
            ruleId: "attribute-validate-prompt",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          // only check for rogue whitespace - value can be any CDATA
          var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-prompt"
            }));
          });
        }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateReadonly(context, mode) {
  return {
    attribute: function attribute(node) {
      var errorArr = [];

      if (node.attribName === "readonly") {
        // validate the parent
        if (!["textarea", "input"].includes(node.parent.tagName)) {
          errorArr.push({
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          // validate the value (or absence thereof)
          validateVoid(node, context, errorArr, {
            xhtml: !!mode,
            enforceSiblingAttributes: null
          });
        } // finally, report gathered errors:


        if (errorArr.length) {
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-readonly"
            }));
          });
        }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateRel(context, enforceLowercase) {
  if (enforceLowercase === void 0) {
    enforceLowercase = false;
  }

  return {
    attribute: function attribute(node) {

      if (node.attribName === "rel") {
        // validate the parent
        if (!["a", "link"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-rel",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // check in two parts, first, a quick try, match the most common values only


        var errorArr = validateString(node.attribValueRaw, // value
        node.attribValueStartsAt, // offset
        {
          permittedValues: linkTypes,
          canBeCommaSeparated: false,
          caseInsensitive: !enforceLowercase
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-rel"
          }));
        });
      }
    }
  };
}

function attributeValidateRev(context, enforceLowercase) {
  if (enforceLowercase === void 0) {
    enforceLowercase = false;
  }

  return {
    attribute: function attribute(node) {

      if (node.attribName === "rev") {
        // validate the parent
        if (!["a", "link"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-rev",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // check in two parts, first, a quick try, match the most common values only


        var errorArr = validateString(node.attribValueRaw, // value
        node.attribValueStartsAt, // offset
        {
          permittedValues: linkTypes,
          canBeCommaSeparated: false,
          caseInsensitive: !enforceLowercase
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-rev"
          }));
        });
      }
    }
  };
}

function attributeValidateRows(context) {
  return {
    attribute: function attribute(node) { // console.log(
      //   `015 attributeValidateRows(): node = ${JSON.stringify(node, null, 4)}`
      // );

      if (node.attribName === "rows") {
        // validate the parent
        if (!["frameset", "textarea"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-rows",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        }
        var errorArr = []; // if value is empty or otherwise does not exist

        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else if (node.parent.tagName === "frameset") {
          errorArr = validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
            whitelistValues: ["*"],
            theOnlyGoodUnits: ["%"],
            badUnits: ["px"],
            noUnitsIsFine: true,
            canBeCommaSeparated: true,
            type: "rational",
            customGenericValueError: "Should be: pixels|%|*."
          });
        } else if (node.parent.tagName === "textarea") {
          // each character must be a digit
          errorArr = validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
            type: "integer",
            theOnlyGoodUnits: [],
            customGenericValueError: "Should be integer, no units."
          });
        }

        if (Array.isArray(errorArr) && errorArr.length) {
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-rows"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateRowspan(context) {
  return {
    attribute: function attribute(node) { // console.log(
      //   `015 attributeValidateRowspan(): node = ${JSON.stringify(node, null, 4)}`
      // );

      if (node.attribName === "rowspan") {
        // validate the parent
        if (!["th", "td"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-rowspan",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        }

        var errorArr = validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
          type: "integer",
          theOnlyGoodUnits: [],
          customGenericValueError: "Should be integer, no units."
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-rowspan"
          }));
        });
      }
    }
  };
}

function attributeValidateRules(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "rules") {
        // validate the parent
        if (node.parent.tagName !== "table") {
          context.report({
            ruleId: "attribute-validate-rules",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // https://www.w3.org/TR/html4/struct/tables.html#adef-frame


        var errorArr = validateString(node.attribValueRaw, // value
        node.attribValueStartsAt, // offset
        {
          permittedValues: ["none", "groups", "rows", "cols", "all"],
          canBeCommaSeparated: false
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-rules"
          }));
        });
      }
    }
  };
}

function attributeValidateScheme(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "scheme") {
        // validate the parent
        if (node.parent.tagName !== "meta") {
          context.report({
            ruleId: "attribute-validate-scheme",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          // only check for rogue whitespace - value can be any CDATA
          var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-scheme"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateScope(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "scope") {
        // validate the parent
        if (!["td", "th"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-scope",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        }

        var errorArr = validateString(node.attribValueRaw, // value
        node.attribValueStartsAt, // offset
        {
          permittedValues: ["row", "col", "rowgroup", "colgroup"],
          canBeCommaSeparated: false
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-scope"
          }));
        });
      }
    }
  };
}

function attributeValidateScrolling(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "scrolling") {
        // validate the parent
        if (!["frame", "iframe"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-scrolling",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        }

        var errorArr = validateString(node.attribValueRaw, // value
        node.attribValueStartsAt, // offset
        {
          permittedValues: ["auto", "yes", "no"],
          canBeCommaSeparated: false
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-scrolling"
          }));
        });
      }
    }
  };
}

function attributeValidateSelected(context, mode) {
  return {
    attribute: function attribute(node) {
      var errorArr = [];

      if (node.attribName === "selected") {
        // validate the parent
        if (node.parent.tagName !== "option") {
          errorArr.push({
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          // validate the value (or absence thereof)
          validateVoid(node, context, errorArr, {
            xhtml: !!mode,
            enforceSiblingAttributes: null
          });
        } // finally, report gathered errors:


        if (errorArr.length) {
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-selected"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateShape(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "shape") {
        // validate the parent
        if (!["area", "a"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-shape",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        }

        var errorArr = validateString(node.attribValueRaw, // value
        node.attribValueStartsAt, // offset
        {
          permittedValues: ["default", "rect", "circle", "poly"],
          canBeCommaSeparated: false
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-shape"
          }));
        });
      }
    }
  };
}

function attributeValidateSize(context) {
  return {
    attribute: function attribute(node) { // console.log(
      //   `015 attributeValidateSize(): node = ${JSON.stringify(node, null, 4)}`
      // );

      if (node.attribName === "size") {
        // validate the parent
        if (!["hr", "font", "input", "basefont", "select"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-size",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
              charStart = _checkForWhitespace.charStart,
              charEnd = _checkForWhitespace.charEnd,
              errorArr = _checkForWhitespace.errorArr; // sort errorArr right here because some of the values will be
          // checked with regex quickly and it would be burden to stick
          // this whitespace reporting on every size attribute tag's case

          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-size"
            }));
          }); //
          //
          // now process each case of "size", depending by tag name
          //
          //

          if (typeof charStart === "number" && typeof charEnd === "number") {
            // the attribute's value is not empty
            var extractedVal = node.attribValueRaw.slice(charStart, charEnd);

            if (["hr", "input", "select"].includes(node.parent.tagName)) { // no need to check whitespace, opts.skipWhitespaceChecks: true

              validateDigitAndUnit(extractedVal, node.attribValueStartsAt + charStart, {
                type: "integer",
                negativeOK: false,
                theOnlyGoodUnits: [],
                skipWhitespaceChecks: true
              }).forEach(function (errorObj) {
                context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                  ruleId: "attribute-validate-size"
                }));
              });
            } else if (["font", "basefont"].includes(node.parent.tagName)) {

              if (!extractedVal.match(fontSizeRegex)) {
                var errorArr2 = validateDigitAndUnit(extractedVal, node.attribValueStartsAt + charStart, {
                  type: "integer",
                  negativeOK: false,
                  theOnlyGoodUnits: [],
                  skipWhitespaceChecks: true,
                  customGenericValueError: "Should be integer 1-7, plus/minus are optional."
                });

                if (!errorArr2.length) {
                  // if validateDigitAndUnit() didn't pick up any errors that
                  // possibly because they are too specific, like <font size="8">
                  // in which case, we raise a generic error against whole
                  // attribute's value
                  errorArr2.push({
                    idxFrom: node.attribValueStartsAt + charStart,
                    idxTo: node.attribValueStartsAt + charEnd,
                    message: "Should be integer 1-7, plus/minus are optional.",
                    fix: null
                  });
                }

                errorArr2.forEach(function (errorObj) {
                  context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                    ruleId: "attribute-validate-size"
                  }));
                });
              }
            }
          }
        }
      }
    }
  };
}

function attributeValidateSpan(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "span") {
        // validate the parent
        if (!["col", "colgroup"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-span",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        }

        var errorArr = validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
          type: "integer",
          theOnlyGoodUnits: [],
          customGenericValueError: "Should be integer, no units.",
          zeroOK: false,
          customPxMessage: "Columns number is not in pixels."
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-span"
          }));
        });
      }
    }
  };
}

function attributeValidateSrc(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "src") {
        // validate the parent
        if (!["script", "input", "frame", "iframe", "img"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-src",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          validateUri(node.attribValueRaw, {
            offset: node.attribValueStartsAt,
            multipleOK: false
          }).forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-src"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateStandby(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "standby") {
        // validate the parent
        if (node.parent.tagName !== "object") {
          context.report({
            ruleId: "attribute-validate-standby",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          // only check for rogue whitespace - value can be any CDATA
          var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-standby"
            }));
          });
        }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateStart(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "start") {
        // validate the parent
        if (node.parent.tagName !== "ol") {
          context.report({
            ruleId: "attribute-validate-start",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        }

        var errorArr = validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
          type: "integer",
          theOnlyGoodUnits: [],
          customGenericValueError: "Should be integer, no units.",
          zeroOK: false,
          customPxMessage: "Starting sequence number is not in pixels."
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-start"
          }));
        });
      }
    }
  };
}

/**
 * Used for both inline HTML tag styles and head CSS style tag rules
 */
function validateStyle(token, context) {
  // first let's set the properties array container, it might come
  // from different places, depending is it head CSS styles or inline HTML styles
  var nodeArr;
  var ruleId = "";

  if (token.properties !== undefined) {
    // head CSS rule
    nodeArr = token.properties;
    ruleId = "css-rule-malformed";
  } else if (token.attribValue !== undefined) {
    // inline HTML style attribute
    nodeArr = token.attribValue;
    ruleId = "attribute-validate-style";
  }

  if (!nodeArr || !ruleId) {
    return;
  } // extract all properties - arr array records
  // all whitespace as text tokens and we want to exclude them

  var properties = []; // there can be text nodes within properties array!
  // a whitespace is still a text node!!!!

  if (nodeArr.some(function (property) {
    return property.property !== undefined;
  })) {
    properties = nodeArr.filter(function (property) {
      return property.property !== undefined;
    });
  }

  if (properties && properties.length) { // 1. catch missing semi on all rules except last
    // <style>.a{color:red\n\ntext-align:left
    //                   ^
    //
    // Iterate starting from the second-to last.
    // The last property is ambiguous, tackled by a separate rule.

    for (var i = properties.length - 1; i--;) {
      if (properties[i].semi === null && properties[i].value) {
        //
        context.report({
          ruleId: ruleId,
          idxFrom: properties[i].start,
          idxTo: properties[i].end,
          message: "Add a semicolon.",
          fix: {
            ranges: [[properties[i].end, properties[i].end, ";"]]
          }
        });
      }
    }

    properties.forEach(function (property) {
      // 2. catch rules with malformed !important
      // <style>.a{color:red !impotant;}</style>
      //                         ^^
      if (property.important && property.important !== "!important") {
        context.report({
          ruleId: ruleId,
          idxFrom: property.importantStarts,
          idxTo: property.importantEnds,
          message: "Malformed !important.",
          fix: {
            ranges: [[property.importantStarts, property.importantEnds, "!important"]]
          }
        });
      } // 3 catch gaps in front of colon
      // <style>.a{ color : red; }</style>
      //                 ^


      if (property.colon && property.propertyEnds && property.propertyEnds < property.colon) {
        context.report({
          ruleId: ruleId,
          idxFrom: property.start,
          idxTo: property.end,
          message: "Gap in front of semicolon.",
          fix: {
            ranges: [[property.propertyEnds, property.colon]]
          }
        });
      } // 4 catch gaps in front of semi
      // <style>.a{ color: red ; }</style>
      //                      ^


      if (property.semi && (property.importantEnds || property.valueEnds) && (property.importantEnds || property.valueEnds) < property.semi) {
        context.report({
          ruleId: ruleId,
          idxFrom: property.start,
          idxTo: property.end,
          message: "Gap in front of semi.",
          fix: {
            ranges: [[property.importantEnds || property.valueEnds, property.semi]]
          }
        });
      } // 5 colon is not colon
      // <style>.a{color/red;}</style>
      //                ^


      if (property.colon && context.str[property.colon] !== ":") {
        context.report({
          ruleId: ruleId,
          idxFrom: property.start,
          idxTo: property.end,
          message: "Mis-typed colon.",
          fix: {
            ranges: [[property.colon, property.colon + 1, ":"]]
          }
        });
      } // 6 repeated semicolon after a property
      // <style>.a{color: red;;}</style>
      //                      ^


      if (property.semi && !property.propertyStarts && !property.valueStarts && !property.importantStarts) {
        context.report({
          ruleId: ruleId,
          idxFrom: property.start,
          idxTo: property.end,
          message: "Rogue semicolon.",
          fix: {
            ranges: [[property.semi, property.semi + 1]]
          }
        });
      } // 7. catch extra whitespace after colon


      if (property.colon && property.valueStarts) {
        if (property.valueStarts > property.colon + 2) {
          context.report({
            ruleId: ruleId,
            idxFrom: property.start,
            idxTo: property.end,
            message: "Remove whitespace.",
            fix: {
              ranges: [[property.colon + 2, property.valueStarts]]
            }
          });
        }

        if (property.valueStarts > property.colon + 1 && !context.str[property.colon + 1].trim() && context.str[property.colon + 1] !== " ") {
          context.report({
            ruleId: ruleId,
            idxFrom: property.colon + 1,
            idxTo: property.valueStarts,
            message: "Replace whitespace.",
            fix: {
              ranges: [[property.colon + 1, property.valueStarts, " "]]
            }
          });
        }
      }
    });
  }

  if (nodeArr && Array.isArray(nodeArr) && nodeArr.length) {
    for (var _i = 0, len = nodeArr.length; _i < len; _i++) { // this loop iterates through everything, CSS properties and whitespace
      // tokens, so let's check the leading/trailing whitespace. Any non-whitespace
      // characters would be put into properties, so we could say text token
      // inside CSS style attribute or CSS rule is used exclusively for whitespace.

      if ( // leading whitespace
      (!_i || // trailing whitespace
      _i === len - 1) && nodeArr[_i].type === "text" && ruleId === "attribute-validate-style") { // maybe whole value is whitespace?
        // <td style="  \t">
        //            ^^^^

        if (len === 1) {
          context.report({
            ruleId: ruleId,
            idxFrom: nodeArr[_i].start,
            idxTo: nodeArr[_i].end,
            message: "Missing value.",
            fix: null
          });
        } else {
          context.report({
            ruleId: ruleId,
            idxFrom: nodeArr[_i].start,
            idxTo: nodeArr[_i].end,
            message: "Remove whitespace.",
            fix: {
              ranges: [[nodeArr[_i].start, nodeArr[_i].end]]
            }
          });
        }
      }

      if (nodeArr[_i].value === null) {
        // tend a rare case, a rogue semicolon:
        // <style>.a{color:red; !important;}</style>
        //                    ^
        if (nodeArr[_i].important !== null && nodeArr[_i].property === null) {
          var errorRaised = false;

          if (_i) {
            for (var y = nodeArr.length; y--;) {
              if (y === _i) {
                continue;
              }

              if ( // the property we're talking about is missing both
              // value and property, yet it contains !important
              nodeArr[_i].important && !nodeArr[_i].propertyStarts && !nodeArr[_i].valueStarts && // we're traversing upon a CSS property, not a whitespace text token
              nodeArr[y].property !== undefined) {

                if ( // its semi is present
                nodeArr[y].semi && // and its important is missing
                !nodeArr[y].importantStarts) { // the frontal space might be missing

                  var fromIdx = nodeArr[y].semi;
                  var toIdx = nodeArr[y].semi + 1;
                  var whatToInsert = void 0;

                  if (context.str[nodeArr[y].semi + 1] !== " ") {
                    whatToInsert = " ";
                  }
                  context.report({
                    ruleId: ruleId,
                    idxFrom: fromIdx,
                    idxTo: toIdx,
                    message: "Delete the semicolon.",
                    fix: {
                      ranges: [[fromIdx, toIdx, whatToInsert]]
                    }
                  });
                  errorRaised = true;
                } else {
                  // stop looping further
                  break;
                }
              }
            }
          } // catch css properties without values
          // <style>.a{color:}</style>
          //                ^


          if ( // it's a property token, not text whitespace token:
          nodeArr[_i].property !== undefined && // and error hasn't been raised so far:
          !errorRaised) {
            context.report({
              ruleId: ruleId,
              idxFrom: nodeArr[_i].start,
              idxTo: nodeArr[_i].end,
              message: "Missing value.",
              fix: null
            });
          }
        } else if ( // avoid cases of semi-only tokens
        nodeArr[_i].property || nodeArr[_i].value || nodeArr[_i].important) {
          context.report({
            ruleId: ruleId,
            idxFrom: nodeArr[_i].start,
            idxTo: nodeArr[_i].end,
            message: "Missing value.",
            fix: null
          });
        }
      }
    }
  }
}

// -----------------------------------------------------------------------------

function attributeValidateStyle(context) {
  for (var _len = arguments.length, opts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    opts[_key - 1] = arguments[_key];
  }

  return {
    attribute: function attribute(node) {

      if (node.attribName === "style") {
        // validate the parent
        if (["base", "basefont", "head", "html", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-style",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // validate the contents


        if (node.attribValueRaw && node.attribValueRaw.trim()) {
          validateStyle(node, context);
        } else {
          context.report({
            ruleId: "attribute-validate-style",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        }
      }
    }
  };
}

function attributeValidateSummary(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "summary") {
        // validate the parent
        if (node.parent.tagName !== "table") {
          context.report({
            ruleId: "attribute-validate-summary",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          // only check for rogue whitespace - value can be any CDATA
          var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-summary"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateTabindex(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "tabindex") {
        // validate the parent
        if (!["a", "area", "button", "input", "object", "select", "textarea"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-tabindex",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        }

        var errorArr = validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
          type: "integer",
          theOnlyGoodUnits: [],
          customGenericValueError: "Should be integer, no units.",
          zeroOK: true,
          customPxMessage: "Tabbing order number should not be in pixels.",
          maxValue: 32767
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-tabindex"
          }));
        });
      }
    }
  };
}

function attributeValidateTarget(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "target") {
        // validate the parent
        if (!["a", "area", "base", "form", "link"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-target",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          // only check for rogue whitespace because value can be any CDATA
          var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-target"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateText(context) {
  return {
    attribute: function attribute(node) { // console.log(
      //   `015 attributeValidateText(): node = ${JSON.stringify(node, null, 4)}`
      // );

      if (node.attribName === "text") {
        // validate the parent
        if (node.parent.tagName !== "body") {
          context.report({
            ruleId: "attribute-validate-text",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          var errorArr = validateColor(node.attribValueRaw, node.attribValueStartsAt, {
            namedCssLevel1OK: true,
            namedCssLevel2PlusOK: true,
            hexThreeOK: false,
            hexFourOK: false,
            hexSixOK: true,
            hexEightOK: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-text"
            }));
          });
        }
      }
    }
  };
}

// -----------------------------------------------------------------------------

function attributeValidateTitle(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "title") {
        // validate the parent
        if (["base", "basefont", "head", "html", "meta", "param", "script", "title"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-title",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          // only check for rogue whitespace because value can be any CDATA
          var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-title"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateType(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "type") {
        // validate the parent
        if (!["a", "link", "object", "param", "script", "style", "input", "li", "ol", "ul", "button"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-type",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // validate depending on type
        else if (["a", "link", "object", "param", "script", "style"].includes(node.parent.tagName)) {
            validateString(node.attribValueRaw, // value
            node.attribValueStartsAt, // offset
            {
              quickPermittedValues: ["application/javascript", "application/json", "application/x-www-form-urlencoded", "application/xml", "application/zip", "application/pdf", "application/sql", "application/graphql", "application/ld+json", "application/msword", "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "application/vnd.ms-excel", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "application/vnd.ms-powerpoint", "application/vnd.openxmlformats-officedocument.presentationml.presentation", "application/vnd.oasis.opendocument.text", "application/zstd", "audio/mpeg", "audio/ogg", "multipart/form-data", "text/css", "text/html", "text/xml", "text/csv", "text/plain", "image/png", "image/jpeg", "image/gif", "application/vnd.api+json"],
              permittedValues: Object.keys(mimeDb),
              canBeCommaSeparated: false,
              noSpaceAfterComma: false
            }).forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-type"
              }));
            });
          } else if (node.parent.tagName === "input") {
            validateString(node.attribValueRaw, // value
            node.attribValueStartsAt, // offset
            {
              quickPermittedValues: ["text", "password", "checkbox", "radio", "submit", "reset", "file", "hidden", "image", "button"],
              canBeCommaSeparated: false,
              noSpaceAfterComma: false
            }).forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-type"
              }));
            });
          } else if (node.parent.tagName === "li") {
            validateString(node.attribValueRaw, // value
            node.attribValueStartsAt, // offset
            {
              quickPermittedValues: ["disc", "square", "circle", "1", "a", "A", "i", "I"],
              canBeCommaSeparated: false,
              noSpaceAfterComma: false
            }).forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-type"
              }));
            });
          } else if (node.parent.tagName === "ol") {
            validateString(node.attribValueRaw, // value
            node.attribValueStartsAt, // offset
            {
              quickPermittedValues: ["1", "a", "A", "i", "I"],
              canBeCommaSeparated: false,
              noSpaceAfterComma: false
            }).forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-type"
              }));
            });
          } else if (node.parent.tagName === "ul") {
            validateString(node.attribValueRaw, // value
            node.attribValueStartsAt, // offset
            {
              quickPermittedValues: ["disc", "square", "circle"],
              canBeCommaSeparated: false,
              noSpaceAfterComma: false
            }).forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-type"
              }));
            });
          } else if (node.parent.tagName === "button") {
            validateString(node.attribValueRaw, // value
            node.attribValueStartsAt, // offset
            {
              quickPermittedValues: ["button", "submit", "reset"],
              canBeCommaSeparated: false,
              noSpaceAfterComma: false
            }).forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-type"
              }));
            });
          }
      }
    }
  };
}

function attributeValidateUsemap(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "usemap") {
        // validate the parent
        if (!["img", "input", "object"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-usemap",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          validateUri(node.attribValueRaw, {
            offset: node.attribValueStartsAt,
            multipleOK: false
          }).forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-usemap"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateValign(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "valign") {
        // validate the parent
        if (!["col", "colgroup", "tbody", "td", "tfoot", "th", "thead", "tr"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-valign",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          validateString(node.attribValueRaw, // value
          node.attribValueStartsAt, // offset
          {
            permittedValues: ["top", "middle", "bottom", "baseline"],
            canBeCommaSeparated: false
          }).forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-valign"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateValue(context) {
  return {
    attribute: function attribute(node) { // console.log(
      //   `015 attributeValidateValue(): node = ${JSON.stringify(node, null, 4)}`
      // );

      if (node.attribName === "value") {
        // validate the parent
        if (!["input", "option", "param", "button", "li"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-value",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if parent is OK
        else if (node.parent.tagName === "li") {
            // value is number
            validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
              type: "integer",
              theOnlyGoodUnits: [],
              customGenericValueError: "Should be integer, no units.",
              zeroOK: false,
              customPxMessage: "Sequence number should not be in pixels."
            }).forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-value"
              }));
            });
          } else {
            // all others - value is CDATA
            var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
                errorArr = _checkForWhitespace.errorArr;

            errorArr.forEach(function (errorObj) {
              context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
                ruleId: "attribute-validate-value"
              }));
            });
          }
      }
    }
  };
}

function attributeValidateValuetype(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "valuetype") {
        // validate the parent
        if (node.parent.tagName !== "param") {
          context.report({
            ruleId: "attribute-validate-valuetype",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else {
          validateString(node.attribValueRaw, // value
          node.attribValueStartsAt, // offset
          {
            permittedValues: ["data", "ref", "object"],
            canBeCommaSeparated: false
          }).forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-valuetype"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateVersion(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "version") {
        // validate the parent
        if (node.parent.tagName !== "html") {
          context.report({
            ruleId: "attribute-validate-version",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          // only check for rogue whitespace - value can be any CDATA
          var _checkForWhitespace = checkForWhitespace(node.attribValueRaw, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-version"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateVlink(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "vlink") {
        // validate the parent
        if (node.parent.tagName !== "body") {
          context.report({
            ruleId: "attribute-validate-vlink",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } // if value is empty or otherwise does not exist


        if (!node.attribValueStartsAt || !node.attribValueEndsAt) {
          context.report({
            ruleId: "attribute-validate-" + node.attribName.toLowerCase(),
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Missing value.",
            fix: null
          });
        } else {
          var errorArr = validateColor(node.attribValueRaw, node.attribValueStartsAt, {
            namedCssLevel1OK: true,
            namedCssLevel2PlusOK: true,
            hexThreeOK: false,
            hexFourOK: false,
            hexSixOK: true,
            hexEightOK: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-vlink"
            }));
          });
        }
      }
    }
  };
}

function attributeValidateVspace(context) {
  return {
    attribute: function attribute(node) { // console.log(
      //   `015 attributeValidateVspace(): node = ${JSON.stringify(node, null, 4)}`
      // );

      if (node.attribName === "vspace") {
        // validate the parent
        if (!["applet", "img", "object"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-vspace",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        }

        var errorArr = validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
          theOnlyGoodUnits: [],
          noUnitsIsFine: true
        });
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "attribute-validate-vspace"
          }));
        });
      }
    }
  };
}

function attributeValidateWidth(context) {
  return {
    attribute: function attribute(node) {

      if (node.attribName === "width") {
        // validate the parent
        if (!["hr", "iframe", "img", "object", "table", "td", "th", "applet", "col", "colgroup", "pre"].includes(node.parent.tagName)) {
          context.report({
            ruleId: "attribute-validate-width",
            idxFrom: node.attribStarts,
            idxTo: node.attribEnds,
            message: "Tag \"" + node.parent.tagName + "\" can't have attribute \"" + node.attribName + "\".",
            fix: null
          });
        } else if (node.parent.tagName === "pre") {
          // number only
          validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
            theOnlyGoodUnits: [],
            noUnitsIsFine: true
          }).forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-width"
            }));
          });
        } else if (["colgroup", "col"].includes(node.parent.tagName)) {
          // multilength type
          validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
            badUnits: ["px"],
            theOnlyGoodUnits: ["*", "%"],
            noUnitsIsFine: true
          }).forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-width"
            }));
          });
        } else {
          // normal length
          validateDigitAndUnit(node.attribValueRaw, node.attribValueStartsAt, {
            badUnits: ["px"],
            noUnitsIsFine: true
          }).forEach(function (errorObj) {
            context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
              ruleId: "attribute-validate-width"
            }));
          });
        }
      }
    }
  };
}

/**
 * html-entities-not-email-friendly
 * All HTML entities which are not email template friendly
 * Version: 0.4.8
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/html-entities-not-email-friendly/
 */
var notEmailFriendly = {
  AMP: "amp",
  Abreve: "#x102",
  Acy: "#x410",
  Afr: "#x1D504",
  Amacr: "#x100",
  And: "#x2A53",
  Aogon: "#x104",
  Aopf: "#x1D538",
  ApplyFunction: "#x2061",
  Ascr: "#x1D49C",
  Assign: "#x2254",
  Backslash: "#x2216",
  Barv: "#x2AE7",
  Barwed: "#x2306",
  Bcy: "#x411",
  Because: "#x2235",
  Bernoullis: "#x212C",
  Bfr: "#x1D505",
  Bopf: "#x1D539",
  Breve: "#x2D8",
  Bscr: "#x212C",
  Bumpeq: "#x224E",
  CHcy: "#x427",
  COPY: "copy",
  Cacute: "#x106",
  Cap: "#x22D2",
  CapitalDifferentialD: "#x2145",
  Cayleys: "#x212D",
  Ccaron: "#x10C",
  Ccirc: "#x108",
  Cconint: "#x2230",
  Cdot: "#x10A",
  Cedilla: "cedil",
  CenterDot: "middot",
  Cfr: "#x212D",
  CircleDot: "#x2299",
  CircleMinus: "#x2296",
  CirclePlus: "oplus",
  CircleTimes: "otimes",
  ClockwiseContourIntegral: "#x2232",
  CloseCurlyDoubleQuote: "rdquo",
  CloseCurlyQuote: "rsquo",
  Colon: "#x2237",
  Colone: "#x2A74",
  Congruent: "equiv",
  Conint: "#x222F",
  ContourIntegral: "#x222E",
  Copf: "#x2102",
  Coproduct: "#x2210",
  CounterClockwiseContourIntegral: "#x2233",
  Cross: "#x2A2F",
  Cscr: "#x1D49E",
  Cup: "#x22D3",
  CupCap: "#x224D",
  DD: "#x2145",
  DDotrahd: "#x2911",
  DJcy: "#x402",
  DScy: "#x405",
  DZcy: "#x40F",
  Darr: "#x21A1",
  Dashv: "#x2AE4",
  Dcaron: "#x10E",
  Dcy: "#x414",
  Del: "#x2207",
  Dfr: "#x1D507",
  DiacriticalAcute: "acute",
  DiacriticalDot: "#x2D9",
  DiacriticalDoubleAcute: "#x2DD",
  DiacriticalGrave: "#x60",
  DiacriticalTilde: "tilde",
  Diamond: "#x22C4",
  DifferentialD: "#x2146",
  Dopf: "#x1D53B",
  Dot: "#xA8",
  DotDot: "#x20DC",
  DotEqual: "#x2250",
  DoubleContourIntegral: "#x222F",
  DoubleDot: "#xA8",
  DoubleDownArrow: "dArr",
  DoubleLeftArrow: "lArr",
  DoubleLeftRightArrow: "#x21D4",
  DoubleLeftTee: "#x2AE4",
  DoubleLongLeftArrow: "#x27F8",
  DoubleLongLeftRightArrow: "#x27FA",
  DoubleLongRightArrow: "#x27F9",
  DoubleRightArrow: "rArr",
  DoubleRightTee: "#x22A8",
  DoubleUpArrow: "uArr",
  DoubleUpDownArrow: "#x21D5",
  DoubleVerticalBar: "#x2225",
  DownArrow: "darr",
  DownArrowBar: "#x2913",
  DownArrowUpArrow: "#x21F5",
  DownBreve: "#x311",
  DownLeftRightVector: "#x2950",
  DownLeftTeeVector: "#x295E",
  DownLeftVector: "#x21BD",
  DownLeftVectorBar: "#x2956",
  DownRightTeeVector: "#x295F",
  DownRightVector: "#x21C1",
  DownRightVectorBar: "#x2957",
  DownTee: "#x22A4",
  DownTeeArrow: "#x21A7",
  Downarrow: "dArr",
  Dscr: "#x1D49F",
  Dstrok: "#x110",
  ENG: "#x14A",
  Ecaron: "#x11A",
  Ecy: "#x42D",
  Edot: "#x116",
  Efr: "#x1D508",
  Element: "#x2208",
  Emacr: "#x112",
  EmptySmallSquare: "#x25FB",
  EmptyVerySmallSquare: "#x25AB",
  Eogon: "#x118",
  Eopf: "#x1D53C",
  Equal: "#x2A75",
  EqualTilde: "#x2242",
  Equilibrium: "#x21CC",
  Escr: "#x2130",
  Esim: "#x2A73",
  Exists: "exist",
  ExponentialE: "#x2147",
  Fcy: "#x424",
  Ffr: "#x1D509",
  FilledSmallSquare: "#x25FC",
  FilledVerySmallSquare: "#x25AA",
  Fopf: "#x1D53D",
  ForAll: "forall",
  Fouriertrf: "#x2131",
  Fscr: "#x2131",
  GJcy: "#x403",
  GT: "gt",
  Gammad: "#x3DC",
  Gbreve: "#x11E",
  Gcedil: "#x122",
  Gcirc: "#x11C",
  Gcy: "#x413",
  Gdot: "#x120",
  Gfr: "#x1D50A",
  Gg: "#x22D9",
  Gopf: "#x1D53E",
  GreaterEqual: "ge",
  GreaterEqualLess: "#x22DB",
  GreaterFullEqual: "#x2267",
  GreaterGreater: "#x2AA2",
  GreaterLess: "#x2277",
  GreaterSlantEqual: "#x2A7E",
  GreaterTilde: "#x2273",
  Gscr: "#x1D4A2",
  Gt: "#x226B",
  HARDcy: "#x42A",
  Hacek: "#x2C7",
  Hcirc: "#x124",
  Hfr: "#x210C",
  HilbertSpace: "#x210B",
  Hopf: "#x210D",
  HorizontalLine: "#x2500",
  Hscr: "#x210B",
  Hstrok: "#x126",
  HumpDownHump: "#x224E",
  HumpEqual: "#x224F",
  IEcy: "#x415",
  IJlig: "#x132",
  IOcy: "#x401",
  Icy: "#x418",
  Idot: "#x130",
  Ifr: "#x2111",
  Im: "#x2111",
  Imacr: "#x12A",
  ImaginaryI: "#x2148",
  Implies: "rArr",
  Int: "#x222C",
  Integral: "int",
  Intersection: "#x22C2",
  InvisibleComma: "#x2063",
  InvisibleTimes: "#x2062",
  Iogon: "#x12E",
  Iopf: "#x1D540",
  Iscr: "#x2110",
  Itilde: "#x128",
  Iukcy: "#x406",
  Jcirc: "#x134",
  Jcy: "#x419",
  Jfr: "#x1D50D",
  Jopf: "#x1D541",
  Jscr: "#x1D4A5",
  Jsercy: "#x408",
  Jukcy: "#x404",
  KHcy: "#x425",
  KJcy: "#x40C",
  Kcedil: "#x136",
  Kcy: "#x41A",
  Kfr: "#x1D50E",
  Kopf: "#x1D542",
  Kscr: "#x1D4A6",
  LJcy: "#x409",
  LT: "lt",
  Lacute: "#x139",
  Lang: "#x27EA",
  Laplacetrf: "#x2112",
  Larr: "#x219E",
  Lcaron: "#x13D",
  Lcedil: "#x13B",
  Lcy: "#x41B",
  LeftAngleBracket: "lang",
  LeftArrow: "larr",
  LeftArrowBar: "#x21E4",
  LeftArrowRightArrow: "#x21C6",
  LeftCeiling: "lceil",
  LeftDoubleBracket: "#x27E6",
  LeftDownTeeVector: "#x2961",
  LeftDownVector: "#x21C3",
  LeftDownVectorBar: "#x2959",
  LeftFloor: "lfloor",
  LeftRightArrow: "harr",
  LeftRightVector: "#x294E",
  LeftTee: "#x22A3",
  LeftTeeArrow: "#x21A4",
  LeftTeeVector: "#x295A",
  LeftTriangle: "#x22B2",
  LeftTriangleBar: "#x29CF",
  LeftTriangleEqual: "#x22B4",
  LeftUpDownVector: "#x2951",
  LeftUpTeeVector: "#x2960",
  LeftUpVector: "#x21BF",
  LeftUpVectorBar: "#x2958",
  LeftVector: "#x21BC",
  LeftVectorBar: "#x2952",
  Leftarrow: "lArr",
  Leftrightarrow: "#x21D4",
  LessEqualGreater: "#x22DA",
  LessFullEqual: "#x2266",
  LessGreater: "#x2276",
  LessLess: "#x2AA1",
  LessSlantEqual: "#x2A7D",
  LessTilde: "#x2272",
  Lfr: "#x1D50F",
  Ll: "#x22D8",
  Lleftarrow: "#x21DA",
  Lmidot: "#x13F",
  LongLeftArrow: "#x27F5",
  LongLeftRightArrow: "#x27F7",
  LongRightArrow: "#x27F6",
  Longleftarrow: "#x27F8",
  Longleftrightarrow: "#x27FA",
  Longrightarrow: "#x27F9",
  Lopf: "#x1D543",
  LowerLeftArrow: "#x2199",
  LowerRightArrow: "#x2198",
  Lscr: "#x2112",
  Lsh: "#x21B0",
  Lstrok: "#x141",
  Lt: "#x226A",
  Map: "#x2905",
  Mcy: "#x41C",
  MediumSpace: "#x205F",
  Mellintrf: "#x2133",
  Mfr: "#x1D510",
  MinusPlus: "#x2213",
  Mopf: "#x1D544",
  Mscr: "#x2133",
  NJcy: "#x40A",
  Nacute: "#x143",
  Ncaron: "#x147",
  Ncedil: "#x145",
  Ncy: "#x41D",
  NegativeMediumSpace: "#x200B",
  NegativeThickSpace: "#x200B",
  NegativeThinSpace: "#x200B",
  NegativeVeryThinSpace: "#x200B",
  NestedGreaterGreater: "#x226B",
  NestedLessLess: "#x226A",
  Nfr: "#x1D511",
  NoBreak: "#x2060",
  NonBreakingSpace: "nbsp",
  Nopf: "#x2115",
  Not: "#x2AEC",
  NotCongruent: "#x2262",
  NotCupCap: "#x226D",
  NotDoubleVerticalBar: "#x2226",
  NotElement: "notin",
  NotEqual: "ne",
  NotEqualTilde: "#x2242;&#x338",
  NotExists: "#x2204",
  NotGreater: "#x226F",
  NotGreaterEqual: "#x2271",
  NotGreaterFullEqual: "#x2267;&#x338",
  NotGreaterGreater: "#x226B;&#x338",
  NotGreaterLess: "#x2279",
  NotGreaterSlantEqual: "#x2A7E;&#x338",
  NotGreaterTilde: "#x2275",
  NotHumpDownHump: "#x224E;&#x338",
  NotHumpEqual: "#x224F;&#x338",
  NotLeftTriangle: "#x22EA",
  NotLeftTriangleBar: "#x29CF;&#x338",
  NotLeftTriangleEqual: "#x22EC",
  NotLess: "#x226E",
  NotLessEqual: "#x2270",
  NotLessGreater: "#x2278",
  NotLessLess: "#x226A;&#x338",
  NotLessSlantEqual: "#x2A7D;&#x338",
  NotLessTilde: "#x2274",
  NotNestedGreaterGreater: "#x2AA2;&#x338",
  NotNestedLessLess: "#x2AA1;&#x338",
  NotPrecedes: "#x2280",
  NotPrecedesEqual: "#x2AAF;&#x338",
  NotPrecedesSlantEqual: "#x22E0",
  NotReverseElement: "#x220C",
  NotRightTriangle: "#x22EB",
  NotRightTriangleBar: "#x29D0;&#x338",
  NotRightTriangleEqual: "#x22ED",
  NotSquareSubset: "#x228F;&#x338",
  NotSquareSubsetEqual: "#x22E2",
  NotSquareSuperset: "#x2290;&#x338",
  NotSquareSupersetEqual: "#x22E3",
  NotSubset: "#x2282;&#x20D2",
  NotSubsetEqual: "#x2288",
  NotSucceeds: "#x2281",
  NotSucceedsEqual: "#x2AB0;&#x338",
  NotSucceedsSlantEqual: "#x22E1",
  NotSucceedsTilde: "#x227F;&#x338",
  NotSuperset: "#x2283;&#x20D2",
  NotSupersetEqual: "#x2289",
  NotTilde: "#x2241",
  NotTildeEqual: "#x2244",
  NotTildeFullEqual: "#x2247",
  NotTildeTilde: "#x2249",
  NotVerticalBar: "#x2224",
  Nscr: "#x1D4A9",
  Ocy: "#x41E",
  Odblac: "#x150",
  Ofr: "#x1D512",
  Omacr: "#x14C",
  Oopf: "#x1D546",
  OpenCurlyDoubleQuote: "ldquo",
  OpenCurlyQuote: "lsquo",
  Or: "#x2A54",
  Oscr: "#x1D4AA",
  Otimes: "#x2A37",
  OverBar: "oline",
  OverBrace: "#x23DE",
  OverBracket: "#x23B4",
  OverParenthesis: "#x23DC",
  PartialD: "part",
  Pcy: "#x41F",
  Pfr: "#x1D513",
  PlusMinus: "#xB1",
  Poincareplane: "#x210C",
  Popf: "#x2119",
  Pr: "#x2ABB",
  Precedes: "#x227A",
  PrecedesEqual: "#x2AAF",
  PrecedesSlantEqual: "#x227C",
  PrecedesTilde: "#x227E",
  Product: "prod",
  Proportion: "#x2237",
  Proportional: "prop",
  Pscr: "#x1D4AB",
  QUOT: "quot",
  Qfr: "#x1D514",
  Qopf: "#x211A",
  Qscr: "#x1D4AC",
  RBarr: "#x2910",
  REG: "reg",
  Racute: "#x154",
  Rang: "#x27EB",
  Rarr: "#x21A0",
  Rarrtl: "#x2916",
  Rcaron: "#x158",
  Rcedil: "#x156",
  Rcy: "#x420",
  Re: "#x211C",
  ReverseElement: "ni",
  ReverseEquilibrium: "#x21CB",
  ReverseUpEquilibrium: "#x296F",
  Rfr: "#x211C",
  RightAngleBracket: "rang",
  RightArrow: "rarr",
  RightArrowBar: "#x21E5",
  RightArrowLeftArrow: "#x21C4",
  RightCeiling: "rceil",
  RightDoubleBracket: "#x27E7",
  RightDownTeeVector: "#x295D",
  RightDownVector: "#x21C2",
  RightDownVectorBar: "#x2955",
  RightFloor: "rfloor",
  RightTee: "#x22A2",
  RightTeeArrow: "#x21A6",
  RightTeeVector: "#x295B",
  RightTriangle: "#x22B3",
  RightTriangleBar: "#x29D0",
  RightTriangleEqual: "#x22B5",
  RightUpDownVector: "#x294F",
  RightUpTeeVector: "#x295C",
  RightUpVector: "#x21BE",
  RightUpVectorBar: "#x2954",
  RightVector: "#x21C0",
  RightVectorBar: "#x2953",
  Rightarrow: "rArr",
  Ropf: "#x211D",
  RoundImplies: "#x2970",
  Rrightarrow: "#x21DB",
  Rscr: "#x211B",
  Rsh: "#x21B1",
  RuleDelayed: "#x29F4",
  SHCHcy: "#x429",
  SHcy: "#x428",
  SOFTcy: "#x42C",
  Sacute: "#x15A",
  Sc: "#x2ABC",
  Scedil: "#x15E",
  Scirc: "#x15C",
  Scy: "#x421",
  Sfr: "#x1D516",
  ShortDownArrow: "darr",
  ShortLeftArrow: "larr",
  ShortRightArrow: "rarr",
  ShortUpArrow: "uarr",
  SmallCircle: "#x2218",
  Sopf: "#x1D54A",
  Sqrt: "#x221A",
  Square: "#x25A1",
  SquareIntersection: "#x2293",
  SquareSubset: "#x228F",
  SquareSubsetEqual: "#x2291",
  SquareSuperset: "#x2290",
  SquareSupersetEqual: "#x2292",
  SquareUnion: "#x2294",
  Sscr: "#x1D4AE",
  Star: "#x22C6",
  Sub: "#x22D0",
  Subset: "#x22D0",
  SubsetEqual: "sube",
  Succeeds: "#x227B",
  SucceedsEqual: "#x2AB0",
  SucceedsSlantEqual: "#x227D",
  SucceedsTilde: "#x227F",
  SuchThat: "ni",
  Sum: "sum",
  Sup: "#x22D1",
  Superset: "sup",
  SupersetEqual: "supe",
  Supset: "#x22D1",
  TRADE: "trade",
  TSHcy: "#x40B",
  TScy: "#x426",
  Tab: "#x9",
  Tcaron: "#x164",
  Tcedil: "#x162",
  Tcy: "#x422",
  Tfr: "#x1D517",
  Therefore: "there4",
  ThickSpace: "#x205F;&#x200A",
  ThinSpace: "thinsp",
  Tilde: "sim",
  TildeEqual: "#x2243",
  TildeFullEqual: "cong",
  TildeTilde: "#x2248",
  Topf: "#x1D54B",
  TripleDot: "#x20DB",
  Tscr: "#x1D4AF",
  Tstrok: "#x166",
  Uarr: "#x219F",
  Uarrocir: "#x2949",
  Ubrcy: "#x40E",
  Ubreve: "#x16C",
  Ucy: "#x423",
  Udblac: "#x170",
  Ufr: "#x1D518",
  Umacr: "#x16A",
  UnderBrace: "#x23DF",
  UnderBracket: "#x23B5",
  UnderParenthesis: "#x23DD",
  Union: "#x22C3",
  UnionPlus: "#x228E",
  Uogon: "#x172",
  Uopf: "#x1D54C",
  UpArrow: "uarr",
  UpArrowBar: "#x2912",
  UpArrowDownArrow: "#x21C5",
  UpDownArrow: "#x2195",
  UpEquilibrium: "#x296E",
  UpTee: "#x22A5",
  UpTeeArrow: "#x21A5",
  Uparrow: "uArr",
  Updownarrow: "#x21D5",
  UpperLeftArrow: "#x2196",
  UpperRightArrow: "#x2197",
  Upsi: "#x3D2",
  Uring: "#x16E",
  Uscr: "#x1D4B0",
  Utilde: "#x168",
  VDash: "#x22AB",
  Vbar: "#x2AEB",
  Vcy: "#x412",
  Vdash: "#x22A9",
  Vdashl: "#x2AE6",
  Vee: "#x22C1",
  Verbar: "#x2016",
  Vert: "#x2016",
  VerticalBar: "#x2223",
  VerticalSeparator: "#x2758",
  VerticalTilde: "#x2240",
  VeryThinSpace: "#x200A",
  Vfr: "#x1D519",
  Vopf: "#x1D54D",
  Vscr: "#x1D4B1",
  Vvdash: "#x22AA",
  Wcirc: "#x174",
  Wedge: "#x22C0",
  Wfr: "#x1D51A",
  Wopf: "#x1D54E",
  Wscr: "#x1D4B2",
  Xfr: "#x1D51B",
  Xopf: "#x1D54F",
  Xscr: "#x1D4B3",
  YAcy: "#x42F",
  YIcy: "#x407",
  YUcy: "#x42E",
  Ycirc: "#x176",
  Ycy: "#x42B",
  Yfr: "#x1D51C",
  Yopf: "#x1D550",
  Yscr: "#x1D4B4",
  ZHcy: "#x416",
  Zacute: "#x179",
  Zcaron: "#x17D",
  Zcy: "#x417",
  Zdot: "#x17B",
  ZeroWidthSpace: "#x200B",
  Zfr: "#x2128",
  Zopf: "#x2124",
  Zscr: "#x1D4B5",
  abreve: "#x103",
  ac: "#x223E",
  acE: "#x223E;&#x333",
  acd: "#x223F",
  acy: "#x430",
  af: "#x2061",
  afr: "#x1D51E",
  aleph: "#x2135",
  amacr: "#x101",
  amalg: "#x2A3F",
  andand: "#x2A55",
  andd: "#x2A5C",
  andslope: "#x2A58",
  andv: "#x2A5A",
  ange: "#x29A4",
  angle: "ang",
  angmsd: "#x2221",
  angmsdaa: "#x29A8",
  angmsdab: "#x29A9",
  angmsdac: "#x29AA",
  angmsdad: "#x29AB",
  angmsdae: "#x29AC",
  angmsdaf: "#x29AD",
  angmsdag: "#x29AE",
  angmsdah: "#x29AF",
  angrt: "#x221F",
  angrtvb: "#x22BE",
  angrtvbd: "#x299D",
  angsph: "#x2222",
  angst: "#xC5",
  angzarr: "#x237C",
  aogon: "#x105",
  aopf: "#x1D552",
  ap: "#x2248",
  apE: "#x2A70",
  apacir: "#x2A6F",
  ape: "#x224A",
  apid: "#x224B",
  approx: "#x2248",
  approxeq: "#x224A",
  ascr: "#x1D4B6",
  asympeq: "#x224D",
  awconint: "#x2233",
  awint: "#x2A11",
  bNot: "#x2AED",
  backcong: "#x224C",
  backepsilon: "#x3F6",
  backprime: "#x2035",
  backsim: "#x223D",
  backsimeq: "#x22CD",
  barvee: "#x22BD",
  barwed: "#x2305",
  barwedge: "#x2305",
  bbrk: "#x23B5",
  bbrktbrk: "#x23B6",
  bcong: "#x224C",
  bcy: "#x431",
  becaus: "#x2235",
  because: "#x2235",
  bemptyv: "#x29B0",
  bepsi: "#x3F6",
  bernou: "#x212C",
  beth: "#x2136",
  between: "#x226C",
  bfr: "#x1D51F",
  bigcap: "#x22C2",
  bigcirc: "#x25EF",
  bigcup: "#x22C3",
  bigodot: "#x2A00",
  bigoplus: "#x2A01",
  bigotimes: "#x2A02",
  bigsqcup: "#x2A06",
  bigstar: "#x2605",
  bigtriangledown: "#x25BD",
  bigtriangleup: "#x25B3",
  biguplus: "#x2A04",
  bigvee: "#x22C1",
  bigwedge: "#x22C0",
  bkarow: "#x290D",
  blacklozenge: "#x29EB",
  blacksquare: "#x25AA",
  blacktriangle: "#x25B4",
  blacktriangledown: "#x25BE",
  blacktriangleleft: "#x25C2",
  blacktriangleright: "#x25B8",
  blank: "#x2423",
  blk12: "#x2592",
  blk14: "#x2591",
  blk34: "#x2593",
  block: "#x2588",
  bne: "&#x20E5",
  bnequiv: "#x2261;&#x20E5",
  bnot: "#x2310",
  bopf: "#x1D553",
  bot: "#x22A5",
  bottom: "#x22A5",
  bowtie: "#x22C8",
  boxDL: "#x2557",
  boxDR: "#x2554",
  boxDl: "#x2556",
  boxDr: "#x2553",
  boxH: "#x2550",
  boxHD: "#x2566",
  boxHU: "#x2569",
  boxHd: "#x2564",
  boxHu: "#x2567",
  boxUL: "#x255D",
  boxUR: "#x255A",
  boxUl: "#x255C",
  boxUr: "#x2559",
  boxV: "#x2551",
  boxVH: "#x256C",
  boxVL: "#x2563",
  boxVR: "#x2560",
  boxVh: "#x256B",
  boxVl: "#x2562",
  boxVr: "#x255F",
  boxbox: "#x29C9",
  boxdL: "#x2555",
  boxdR: "#x2552",
  boxdl: "#x2510",
  boxdr: "#x250C",
  boxh: "#x2500",
  boxhD: "#x2565",
  boxhU: "#x2568",
  boxhd: "#x252C",
  boxhu: "#x2534",
  boxminus: "#x229F",
  boxplus: "#x229E",
  boxtimes: "#x22A0",
  boxuL: "#x255B",
  boxuR: "#x2558",
  boxul: "#x2518",
  boxur: "#x2514",
  boxv: "#x2502",
  boxvH: "#x256A",
  boxvL: "#x2561",
  boxvR: "#x255E",
  boxvh: "#x253C",
  boxvl: "#x2524",
  boxvr: "#x251C",
  bprime: "#x2035",
  breve: "#x2D8",
  bscr: "#x1D4B7",
  bsemi: "#x204F",
  bsim: "#x223D",
  bsime: "#x22CD",
  bsolb: "#x29C5",
  bsolhsub: "#x27C8",
  bullet: "bull",
  bump: "#x224E",
  bumpE: "#x2AAE",
  bumpe: "#x224F",
  bumpeq: "#x224F",
  cacute: "#x107",
  capand: "#x2A44",
  capbrcup: "#x2A49",
  capcap: "#x2A4B",
  capcup: "#x2A47",
  capdot: "#x2A40",
  caps: "#x2229;&#xFE00",
  caret: "#x2041",
  caron: "#x2C7",
  ccaps: "#x2A4D",
  ccaron: "#x10D",
  ccirc: "#x109",
  ccups: "#x2A4C",
  ccupssm: "#x2A50",
  cdot: "#x10B",
  cemptyv: "#x29B2",
  centerdot: "middot",
  cfr: "#x1D520",
  chcy: "#x447",
  check: "#x2713",
  checkmark: "#x2713",
  cir: "#x25CB",
  cirE: "#x29C3",
  circeq: "#x2257",
  circlearrowleft: "#x21BA",
  circlearrowright: "#x21BB",
  circledR: "reg",
  circledS: "#x24C8",
  circledast: "#x229B",
  circledcirc: "#x229A",
  circleddash: "#x229D",
  cire: "#x2257",
  cirfnint: "#x2A10",
  cirmid: "#x2AEF",
  cirscir: "#x29C2",
  clubsuit: "clubs",
  colone: "#x2254",
  coloneq: "#x2254",
  comp: "#x2201",
  compfn: "#x2218",
  complement: "#x2201",
  complexes: "#x2102",
  congdot: "#x2A6D",
  conint: "#x222E",
  copf: "#x1D554",
  coprod: "#x2210",
  copysr: "#x2117",
  cross: "#x2717",
  cscr: "#x1D4B8",
  csub: "#x2ACF",
  csube: "#x2AD1",
  csup: "#x2AD0",
  csupe: "#x2AD2",
  ctdot: "#x22EF",
  cudarrl: "#x2938",
  cudarrr: "#x2935",
  cuepr: "#x22DE",
  cuesc: "#x22DF",
  cularr: "#x21B6",
  cularrp: "#x293D",
  cupbrcap: "#x2A48",
  cupcap: "#x2A46",
  cupcup: "#x2A4A",
  cupdot: "#x228D",
  cupor: "#x2A45",
  cups: "#x222A;&#xFE00",
  curarr: "#x21B7",
  curarrm: "#x293C",
  curlyeqprec: "#x22DE",
  curlyeqsucc: "#x22DF",
  curlyvee: "#x22CE",
  curlywedge: "#x22CF",
  curvearrowleft: "#x21B6",
  curvearrowright: "#x21B7",
  cuvee: "#x22CE",
  cuwed: "#x22CF",
  cwconint: "#x2232",
  cwint: "#x2231",
  cylcty: "#x232D",
  dHar: "#x2965",
  daleth: "#x2138",
  dash: "#x2010",
  dashv: "#x22A3",
  dbkarow: "#x290F",
  dblac: "#x2DD",
  dcaron: "#x10F",
  dcy: "#x434",
  dd: "#x2146",
  ddagger: "Dagger",
  ddarr: "#x21CA",
  ddotseq: "#x2A77",
  demptyv: "#x29B1",
  dfisht: "#x297F",
  dfr: "#x1D521",
  dharl: "#x21C3",
  dharr: "#x21C2",
  diam: "#x22C4",
  diamond: "#x22C4",
  diamondsuit: "diams",
  die: "#xA8",
  digamma: "#x3DD",
  disin: "#x22F2",
  div: "#xF7",
  divideontimes: "#x22C7",
  divonx: "#x22C7",
  djcy: "#x452",
  dlcorn: "#x231E",
  dlcrop: "#x230D",
  dopf: "#x1D555",
  dot: "#x2D9",
  doteq: "#x2250",
  doteqdot: "#x2251",
  dotminus: "#x2238",
  dotplus: "#x2214",
  dotsquare: "#x22A1",
  doublebarwedge: "#x2306",
  downarrow: "darr",
  downdownarrows: "#x21CA",
  downharpoonleft: "#x21C3",
  downharpoonright: "#x21C2",
  drbkarow: "#x2910",
  drcorn: "#x231F",
  drcrop: "#x230C",
  dscr: "#x1D4B9",
  dscy: "#x455",
  dsol: "#x29F6",
  dstrok: "#x111",
  dtdot: "#x22F1",
  dtri: "#x25BF",
  dtrif: "#x25BE",
  duarr: "#x21F5",
  duhar: "#x296F",
  dwangle: "#x29A6",
  dzcy: "#x45F",
  dzigrarr: "#x27FF",
  eDDot: "#x2A77",
  eDot: "#x2251",
  easter: "#x2A6E",
  ecaron: "#x11B",
  ecir: "#x2256",
  ecolon: "#x2255",
  ecy: "#x44D",
  edot: "#x117",
  ee: "#x2147",
  efDot: "#x2252",
  efr: "#x1D522",
  eg: "#x2A9A",
  egs: "#x2A96",
  egsdot: "#x2A98",
  el: "#x2A99",
  elinters: "#x23E7",
  ell: "#x2113",
  els: "#x2A95",
  elsdot: "#x2A97",
  emacr: "#x113",
  emptyset: "empty",
  emptyv: "empty",
  emsp13: "#x2004",
  emsp14: "#x2005",
  eng: "#x14B",
  eogon: "#x119",
  eopf: "#x1D556",
  epar: "#x22D5",
  eparsl: "#x29E3",
  eplus: "#x2A71",
  epsi: "#x3B5",
  epsiv: "#x3F5",
  eqcirc: "#x2256",
  eqcolon: "#x2255",
  eqsim: "#x2242",
  eqslantgtr: "#x2A96",
  eqslantless: "#x2A95",
  equest: "#x225F",
  equivDD: "#x2A78",
  eqvparsl: "#x29E5",
  erDot: "#x2253",
  erarr: "#x2971",
  escr: "#x212F",
  esdot: "#x2250",
  esim: "#x2242",
  expectation: "#x2130",
  exponentiale: "#x2147",
  fallingdotseq: "#x2252",
  fcy: "#x444",
  female: "#x2640",
  ffilig: "#xFB03",
  fflig: "#xFB00",
  ffllig: "#xFB04",
  ffr: "#x1D523",
  filig: "#xFB01",
  flat: "#x266D",
  fllig: "#xFB02",
  fltns: "#x25B1",
  fopf: "#x1D557",
  fork: "#x22D4",
  forkv: "#x2AD9",
  fpartint: "#x2A0D",
  frac13: "#x2153",
  frac15: "#x2155",
  frac16: "#x2159",
  frac18: "#x215B",
  frac23: "#x2154",
  frac25: "#x2156",
  frac35: "#x2157",
  frac38: "#x215C",
  frac45: "#x2158",
  frac56: "#x215A",
  frac58: "#x215D",
  frac78: "#x215E",
  frown: "#x2322",
  fscr: "#x1D4BB",
  gE: "#x2267",
  gEl: "#x2A8C",
  gacute: "#x1F5",
  gammad: "#x3DD",
  gap: "#x2A86",
  gbreve: "#x11F",
  gcirc: "#x11D",
  gcy: "#x433",
  gdot: "#x121",
  gel: "#x22DB",
  geq: "ge",
  geqq: "#x2267",
  geqslant: "#x2A7E",
  ges: "#x2A7E",
  gescc: "#x2AA9",
  gesdot: "#x2A80",
  gesdoto: "#x2A82",
  gesdotol: "#x2A84",
  gesl: "#x22DB;&#xFE00",
  gesles: "#x2A94",
  gfr: "#x1D524",
  gg: "#x226B",
  ggg: "#x22D9",
  gimel: "#x2137",
  gjcy: "#x453",
  gl: "#x2277",
  glE: "#x2A92",
  gla: "#x2AA5",
  glj: "#x2AA4",
  gnE: "#x2269",
  gnap: "#x2A8A",
  gnapprox: "#x2A8A",
  gne: "#x2A88",
  gneq: "#x2A88",
  gneqq: "#x2269",
  gnsim: "#x22E7",
  gopf: "#x1D558",
  grave: "#x60",
  gscr: "#x210A",
  gsim: "#x2273",
  gsime: "#x2A8E",
  gsiml: "#x2A90",
  gtcc: "#x2AA7",
  gtcir: "#x2A7A",
  gtdot: "#x22D7",
  gtlPar: "#x2995",
  gtquest: "#x2A7C",
  gtrapprox: "#x2A86",
  gtrarr: "#x2978",
  gtrdot: "#x22D7",
  gtreqless: "#x22DB",
  gtreqqless: "#x2A8C",
  gtrless: "#x2277",
  gtrsim: "#x2273",
  gvertneqq: "#x2269;&#xFE00",
  gvnE: "#x2269;&#xFE00",
  hairsp: "#x200A",
  half: "#xBD",
  hamilt: "#x210B",
  hardcy: "#x44A",
  harrcir: "#x2948",
  harrw: "#x21AD",
  hbar: "#x210F",
  hcirc: "#x125",
  heartsuit: "hearts",
  hercon: "#x22B9",
  hfr: "#x1D525",
  hksearow: "#x2925",
  hkswarow: "#x2926",
  hoarr: "#x21FF",
  homtht: "#x223B",
  hookleftarrow: "#x21A9",
  hookrightarrow: "#x21AA",
  hopf: "#x1D559",
  horbar: "#x2015",
  hscr: "#x1D4BD",
  hslash: "#x210F",
  hstrok: "#x127",
  hybull: "#x2043",
  hyphen: "#x2010",
  ic: "#x2063",
  icy: "#x438",
  iecy: "#x435",
  iff: "#x21D4",
  ifr: "#x1D526",
  ii: "#x2148",
  iiiint: "#x2A0C",
  iiint: "#x222D",
  iinfin: "#x29DC",
  iiota: "#x2129",
  ijlig: "#x133",
  imacr: "#x12B",
  imagline: "#x2110",
  imagpart: "#x2111",
  imath: "#x131",
  imof: "#x22B7",
  imped: "#x1B5",
  in: "#x2208",
  incare: "#x2105",
  infintie: "#x29DD",
  inodot: "#x131",
  intcal: "#x22BA",
  integers: "#x2124",
  intercal: "#x22BA",
  intlarhk: "#x2A17",
  intprod: "#x2A3C",
  iocy: "#x451",
  iogon: "#x12F",
  iopf: "#x1D55A",
  iprod: "#x2A3C",
  iscr: "#x1D4BE",
  isinE: "#x22F9",
  isindot: "#x22F5",
  isins: "#x22F4",
  isinsv: "#x22F3",
  isinv: "#x2208",
  it: "#x2062",
  itilde: "#x129",
  iukcy: "#x456",
  jcirc: "#x135",
  jcy: "#x439",
  jfr: "#x1D527",
  jmath: "#x237",
  jopf: "#x1D55B",
  jscr: "#x1D4BF",
  jsercy: "#x458",
  jukcy: "#x454",
  kappav: "#x3F0",
  kcedil: "#x137",
  kcy: "#x43A",
  kfr: "#x1D528",
  kgreen: "#x138",
  khcy: "#x445",
  kjcy: "#x45C",
  kopf: "#x1D55C",
  kscr: "#x1D4C0",
  lAarr: "#x21DA",
  lAtail: "#x291B",
  lBarr: "#x290E",
  lE: "#x2266",
  lEg: "#x2A8B",
  lHar: "#x2962",
  lacute: "#x13A",
  laemptyv: "#x29B4",
  lagran: "#x2112",
  langd: "#x2991",
  langle: "lang",
  lap: "#x2A85",
  larrb: "#x21E4",
  larrbfs: "#x291F",
  larrfs: "#x291D",
  larrhk: "#x21A9",
  larrlp: "#x21AB",
  larrpl: "#x2939",
  larrsim: "#x2973",
  larrtl: "#x21A2",
  lat: "#x2AAB",
  latail: "#x2919",
  late: "#x2AAD",
  lates: "#x2AAD;&#xFE00",
  lbarr: "#x290C",
  lbbrk: "#x2772",
  lbrace: "{",
  lbrack: "[",
  lbrke: "#x298B",
  lbrksld: "#x298F",
  lbrkslu: "#x298D",
  lcaron: "#x13E",
  lcedil: "#x13C",
  lcub: "{",
  lcy: "#x43B",
  ldca: "#x2936",
  ldquor: "bdquo",
  ldrdhar: "#x2967",
  ldrushar: "#x294B",
  ldsh: "#x21B2",
  leftarrow: "larr",
  leftarrowtail: "#x21A2",
  leftharpoondown: "#x21BD",
  leftharpoonup: "#x21BC",
  leftleftarrows: "#x21C7",
  leftrightarrow: "harr",
  leftrightarrows: "#x21C6",
  leftrightharpoons: "#x21CB",
  leftrightsquigarrow: "#x21AD",
  leftthreetimes: "#x22CB",
  leg: "#x22DA",
  leq: "le",
  leqq: "#x2266",
  leqslant: "#x2A7D",
  les: "#x2A7D",
  lescc: "#x2AA8",
  lesdot: "#x2A7F",
  lesdoto: "#x2A81",
  lesdotor: "#x2A83",
  lesg: "#x22DA;&#xFE00",
  lesges: "#x2A93",
  lessapprox: "#x2A85",
  lessdot: "#x22D6",
  lesseqgtr: "#x22DA",
  lesseqqgtr: "#x2A8B",
  lessgtr: "#x2276",
  lesssim: "#x2272",
  lfisht: "#x297C",
  lfr: "#x1D529",
  lg: "#x2276",
  lgE: "#x2A91",
  lhard: "#x21BD",
  lharu: "#x21BC",
  lharul: "#x296A",
  lhblk: "#x2584",
  ljcy: "#x459",
  ll: "#x226A",
  llarr: "#x21C7",
  llcorner: "#x231E",
  llhard: "#x296B",
  lltri: "#x25FA",
  lmidot: "#x140",
  lmoust: "#x23B0",
  lmoustache: "#x23B0",
  lnE: "#x2268",
  lnap: "#x2A89",
  lnapprox: "#x2A89",
  lne: "#x2A87",
  lneq: "#x2A87",
  lneqq: "#x2268",
  lnsim: "#x22E6",
  loang: "#x27EC",
  loarr: "#x21FD",
  lobrk: "#x27E6",
  longleftarrow: "#x27F5",
  longleftrightarrow: "#x27F7",
  longmapsto: "#x27FC",
  longrightarrow: "#x27F6",
  looparrowleft: "#x21AB",
  looparrowright: "#x21AC",
  lopar: "#x2985",
  lopf: "#x1D55D",
  loplus: "#x2A2D",
  lotimes: "#x2A34",
  lozenge: "loz",
  lozf: "#x29EB",
  lparlt: "#x2993",
  lrarr: "#x21C6",
  lrcorner: "#x231F",
  lrhar: "#x21CB",
  lrhard: "#x296D",
  lrtri: "#x22BF",
  lscr: "#x1D4C1",
  lsh: "#x21B0",
  lsim: "#x2272",
  lsime: "#x2A8D",
  lsimg: "#x2A8F",
  lsquor: "sbquo",
  lstrok: "#x142",
  ltcc: "#x2AA6",
  ltcir: "#x2A79",
  ltdot: "#x22D6",
  lthree: "#x22CB",
  ltimes: "#x22C9",
  ltlarr: "#x2976",
  ltquest: "#x2A7B",
  ltrPar: "#x2996",
  ltri: "#x25C3",
  ltrie: "#x22B4",
  ltrif: "#x25C2",
  lurdshar: "#x294A",
  luruhar: "#x2966",
  lvertneqq: "#x2268;&#xFE00",
  lvnE: "#x2268;&#xFE00",
  mDDot: "#x223A",
  male: "#x2642",
  malt: "#x2720",
  maltese: "#x2720",
  map: "#x21A6",
  mapsto: "#x21A6",
  mapstodown: "#x21A7",
  mapstoleft: "#x21A4",
  mapstoup: "#x21A5",
  marker: "#x25AE",
  mcomma: "#x2A29",
  mcy: "#x43C",
  measuredangle: "#x2221",
  mfr: "#x1D52A",
  mho: "#x2127",
  mid: "#x2223",
  midcir: "#x2AF0",
  minusb: "#x229F",
  minusd: "#x2238",
  minusdu: "#x2A2A",
  mlcp: "#x2ADB",
  mldr: "#x2026",
  mnplus: "#x2213",
  models: "#x22A7",
  mopf: "#x1D55E",
  mp: "#x2213",
  mscr: "#x1D4C2",
  mstpos: "#x223E",
  multimap: "#x22B8",
  mumap: "#x22B8",
  nGg: "#x22D9;&#x338",
  nGt: "#x226B;&#x20D2",
  nGtv: "#x226B;&#x338",
  nLeftarrow: "#x21CD",
  nLeftrightarrow: "#x21CE",
  nLl: "#x22D8;&#x338",
  nLt: "#x226A;&#x20D2",
  nLtv: "#x226A;&#x338",
  nRightarrow: "#x21CF",
  nVDash: "#x22AF",
  nVdash: "#x22AE",
  nacute: "#x144",
  nang: "#x2220;&#x20D2",
  nap: "#x2249",
  napE: "#x2A70;&#x338",
  napid: "#x224B;&#x338",
  napos: "#x149",
  napprox: "#x2249",
  natur: "#x266E",
  natural: "#x266E",
  naturals: "#x2115",
  nbump: "#x224E;&#x338",
  nbumpe: "#x224F;&#x338",
  ncap: "#x2A43",
  ncaron: "#x148",
  ncedil: "#x146",
  ncong: "#x2247",
  ncongdot: "#x2A6D;&#x338",
  ncup: "#x2A42",
  ncy: "#x43D",
  neArr: "#x21D7",
  nearhk: "#x2924",
  nearr: "#x2197",
  nearrow: "#x2197",
  nedot: "#x2250;&#x338",
  nequiv: "#x2262",
  nesear: "#x2928",
  nesim: "#x2242;&#x338",
  nexist: "#x2204",
  nexists: "#x2204",
  nfr: "#x1D52B",
  ngE: "#x2267;&#x338",
  nge: "#x2271",
  ngeq: "#x2271",
  ngeqq: "#x2267;&#x338",
  ngeqslant: "#x2A7E;&#x338",
  nges: "#x2A7E;&#x338",
  ngsim: "#x2275",
  ngt: "#x226F",
  ngtr: "#x226F",
  nhArr: "#x21CE",
  nharr: "#x21AE",
  nhpar: "#x2AF2",
  nis: "#x22FC",
  nisd: "#x22FA",
  niv: "ni",
  njcy: "#x45A",
  nlArr: "#x21CD",
  nlE: "#x2266;&#x338",
  nlarr: "#x219A",
  nldr: "#x2025",
  nle: "#x2270",
  nleftarrow: "#x219A",
  nleftrightarrow: "#x21AE",
  nleq: "#x2270",
  nleqq: "#x2266;&#x338",
  nleqslant: "#x2A7D;&#x338",
  nles: "#x2A7D;&#x338",
  nless: "#x226E",
  nlsim: "#x2274",
  nlt: "#x226E",
  nltri: "#x22EA",
  nltrie: "#x22EC",
  nmid: "#x2224",
  nopf: "#x1D55F",
  notinE: "#x22F9;&#x338",
  notindot: "#x22F5;&#x338",
  notinva: "notin",
  notinvb: "#x22F7",
  notinvc: "#x22F6",
  notni: "#x220C",
  notniva: "#x220C",
  notnivb: "#x22FE",
  notnivc: "#x22FD",
  npar: "#x2226",
  nparallel: "#x2226",
  nparsl: "#x2AFD;&#x20E5",
  npart: "#x2202;&#x338",
  npolint: "#x2A14",
  npr: "#x2280",
  nprcue: "#x22E0",
  npre: "#x2AAF;&#x338",
  nprec: "#x2280",
  npreceq: "#x2AAF;&#x338",
  nrArr: "#x21CF",
  nrarr: "#x219B",
  nrarrc: "#x2933;&#x338",
  nrarrw: "#x219D;&#x338",
  nrightarrow: "#x219B",
  nrtri: "#x22EB",
  nrtrie: "#x22ED",
  nsc: "#x2281",
  nsccue: "#x22E1",
  nsce: "#x2AB0;&#x338",
  nscr: "#x1D4C3",
  nshortmid: "#x2224",
  nshortparallel: "#x2226",
  nsim: "#x2241",
  nsime: "#x2244",
  nsimeq: "#x2244",
  nsmid: "#x2224",
  nspar: "#x2226",
  nsqsube: "#x22E2",
  nsqsupe: "#x22E3",
  nsubE: "#x2AC5;&#x338",
  nsube: "#x2288",
  nsubset: "#x2282;&#x20D2",
  nsubseteq: "#x2288",
  nsubseteqq: "#x2AC5;&#x338",
  nsucc: "#x2281",
  nsucceq: "#x2AB0;&#x338",
  nsup: "#x2285",
  nsupE: "#x2AC6;&#x338",
  nsupe: "#x2289",
  nsupset: "#x2283;&#x20D2",
  nsupseteq: "#x2289",
  nsupseteqq: "#x2AC6;&#x338",
  ntgl: "#x2279",
  ntlg: "#x2278",
  ntriangleleft: "#x22EA",
  ntrianglelefteq: "#x22EC",
  ntriangleright: "#x22EB",
  ntrianglerighteq: "#x22ED",
  numero: "#x2116",
  numsp: "#x2007",
  nvDash: "#x22AD",
  nvHarr: "#x2904",
  nvap: "#x224D;&#x20D2",
  nvdash: "#x22AC",
  nvge: "#x2265;&#x20D2",
  nvgt: "#x3E;&#x20D2",
  nvinfin: "#x29DE",
  nvlArr: "#x2902",
  nvle: "#x2264;&#x20D2",
  nvlt: "#x3C;&#x20D2",
  nvltrie: "#x22B4;&#x20D2",
  nvrArr: "#x2903",
  nvrtrie: "#x22B5;&#x20D2",
  nvsim: "#x223C;&#x20D2",
  nwArr: "#x21D6",
  nwarhk: "#x2923",
  nwarr: "#x2196",
  nwarrow: "#x2196",
  nwnear: "#x2927",
  oS: "#x24C8",
  oast: "#x229B",
  ocir: "#x229A",
  ocy: "#x43E",
  odash: "#x229D",
  odblac: "#x151",
  odiv: "#x2A38",
  odot: "#x2299",
  odsold: "#x29BC",
  ofcir: "#x29BF",
  ofr: "#x1D52C",
  ogon: "#x2DB",
  ogt: "#x29C1",
  ohbar: "#x29B5",
  ohm: "#x3A9",
  oint: "#x222E",
  olarr: "#x21BA",
  olcir: "#x29BE",
  olcross: "#x29BB",
  olt: "#x29C0",
  omacr: "#x14D",
  omid: "#x29B6",
  ominus: "#x2296",
  oopf: "#x1D560",
  opar: "#x29B7",
  operp: "#x29B9",
  orarr: "#x21BB",
  ord: "#x2A5D",
  order: "#x2134",
  orderof: "#x2134",
  origof: "#x22B6",
  oror: "#x2A56",
  orslope: "#x2A57",
  orv: "#x2A5B",
  oscr: "#x2134",
  osol: "#x2298",
  otimesas: "#x2A36",
  ovbar: "#x233D",
  par: "#x2225",
  parallel: "#x2225",
  parsim: "#x2AF3",
  parsl: "#x2AFD",
  pcy: "#x43F",
  pertenk: "#x2031",
  pfr: "#x1D52D",
  phiv: "#x3D5",
  phmmat: "#x2133",
  phone: "#x260E",
  pitchfork: "#x22D4",
  planck: "#x210F",
  planckh: "#x210E",
  plankv: "#x210F",
  plusacir: "#x2A23",
  plusb: "#x229E",
  pluscir: "#x2A22",
  plusdo: "#x2214",
  plusdu: "#x2A25",
  pluse: "#x2A72",
  plussim: "#x2A26",
  plustwo: "#x2A27",
  pm: "#xB1",
  pointint: "#x2A15",
  popf: "#x1D561",
  pr: "#x227A",
  prE: "#x2AB3",
  prap: "#x2AB7",
  prcue: "#x227C",
  pre: "#x2AAF",
  prec: "#x227A",
  precapprox: "#x2AB7",
  preccurlyeq: "#x227C",
  preceq: "#x2AAF",
  precnapprox: "#x2AB9",
  precneqq: "#x2AB5",
  precnsim: "#x22E8",
  precsim: "#x227E",
  primes: "#x2119",
  prnE: "#x2AB5",
  prnap: "#x2AB9",
  prnsim: "#x22E8",
  profalar: "#x232E",
  profline: "#x2312",
  profsurf: "#x2313",
  propto: "prop",
  prsim: "#x227E",
  prurel: "#x22B0",
  pscr: "#x1D4C5",
  puncsp: "#x2008",
  qfr: "#x1D52E",
  qint: "#x2A0C",
  qopf: "#x1D562",
  qprime: "#x2057",
  qscr: "#x1D4C6",
  quaternions: "#x210D",
  quatint: "#x2A16",
  questeq: "#x225F",
  rAarr: "#x21DB",
  rAtail: "#x291C",
  rBarr: "#x290F",
  rHar: "#x2964",
  race: "#x223D;&#x331",
  racute: "#x155",
  raemptyv: "#x29B3",
  rangd: "#x2992",
  range: "#x29A5",
  rangle: "rang",
  rarrap: "#x2975",
  rarrb: "#x21E5",
  rarrbfs: "#x2920",
  rarrc: "#x2933",
  rarrfs: "#x291E",
  rarrhk: "#x21AA",
  rarrlp: "#x21AC",
  rarrpl: "#x2945",
  rarrsim: "#x2974",
  rarrtl: "#x21A3",
  rarrw: "#x219D",
  ratail: "#x291A",
  ratio: "#x2236",
  rationals: "#x211A",
  rbarr: "#x290D",
  rbbrk: "#x2773",
  rbrke: "#x298C",
  rbrksld: "#x298E",
  rbrkslu: "#x2990",
  rcaron: "#x159",
  rcedil: "#x157",
  rcy: "#x440",
  rdca: "#x2937",
  rdldhar: "#x2969",
  rdquor: "rdquo",
  rdsh: "#x21B3",
  realine: "#x211B",
  realpart: "#x211C",
  reals: "#x211D",
  rect: "#x25AD",
  rfisht: "#x297D",
  rfr: "#x1D52F",
  rhard: "#x21C1",
  rharu: "#x21C0",
  rharul: "#x296C",
  rhov: "#x3F1",
  rightarrow: "rarr",
  rightarrowtail: "#x21A3",
  rightharpoondown: "#x21C1",
  rightharpoonup: "#x21C0",
  rightleftarrows: "#x21C4",
  rightleftharpoons: "#x21CC",
  rightrightarrows: "#x21C9",
  rightsquigarrow: "#x219D",
  rightthreetimes: "#x22CC",
  ring: "#x2DA",
  risingdotseq: "#x2253",
  rlarr: "#x21C4",
  rlhar: "#x21CC",
  rmoust: "#x23B1",
  rmoustache: "#x23B1",
  rnmid: "#x2AEE",
  roang: "#x27ED",
  roarr: "#x21FE",
  robrk: "#x27E7",
  ropar: "#x2986",
  ropf: "#x1D563",
  roplus: "#x2A2E",
  rotimes: "#x2A35",
  rpargt: "#x2994",
  rppolint: "#x2A12",
  rrarr: "#x21C9",
  rscr: "#x1D4C7",
  rsh: "#x21B1",
  rsquor: "rsquo",
  rthree: "#x22CC",
  rtimes: "#x22CA",
  rtri: "#x25B9",
  rtrie: "#x22B5",
  rtrif: "#x25B8",
  rtriltri: "#x29CE",
  ruluhar: "#x2968",
  rx: "#x211E",
  sacute: "#x15B",
  sc: "#x227B",
  scE: "#x2AB4",
  scap: "#x2AB8",
  sccue: "#x227D",
  sce: "#x2AB0",
  scedil: "#x15F",
  scirc: "#x15D",
  scnE: "#x2AB6",
  scnap: "#x2ABA",
  scnsim: "#x22E9",
  scpolint: "#x2A13",
  scsim: "#x227F",
  scy: "#x441",
  sdotb: "#x22A1",
  sdote: "#x2A66",
  seArr: "#x21D8",
  searhk: "#x2925",
  searr: "#x2198",
  searrow: "#x2198",
  seswar: "#x2929",
  setminus: "#x2216",
  setmn: "#x2216",
  sext: "#x2736",
  sfr: "#x1D530",
  sfrown: "#x2322",
  sharp: "#x266F",
  shchcy: "#x449",
  shcy: "#x448",
  shortmid: "#x2223",
  shortparallel: "#x2225",
  sigmav: "sigmaf",
  simdot: "#x2A6A",
  sime: "#x2243",
  simeq: "#x2243",
  simg: "#x2A9E",
  simgE: "#x2AA0",
  siml: "#x2A9D",
  simlE: "#x2A9F",
  simne: "#x2246",
  simplus: "#x2A24",
  simrarr: "#x2972",
  slarr: "larr",
  smallsetminus: "#x2216",
  smashp: "#x2A33",
  smeparsl: "#x29E4",
  smid: "#x2223",
  smile: "#x2323",
  smt: "#x2AAA",
  smte: "#x2AAC",
  smtes: "#x2AAC;&#xFE00",
  softcy: "#x44C",
  solb: "#x29C4",
  solbar: "#x233F",
  sopf: "#x1D564",
  spadesuit: "spades",
  spar: "#x2225",
  sqcap: "#x2293",
  sqcaps: "#x2293;&#xFE00",
  sqcup: "#x2294",
  sqcups: "#x2294;&#xFE00",
  sqsub: "#x228F",
  sqsube: "#x2291",
  sqsubset: "#x228F",
  sqsubseteq: "#x2291",
  sqsup: "#x2290",
  sqsupe: "#x2292",
  sqsupset: "#x2290",
  sqsupseteq: "#x2292",
  squ: "#x25A1",
  square: "#x25A1",
  squarf: "#x25AA",
  squf: "#x25AA",
  srarr: "rarr",
  sscr: "#x1D4C8",
  ssetmn: "#x2216",
  ssmile: "#x2323",
  sstarf: "#x22C6",
  star: "#x2606",
  starf: "#x2605",
  straightepsilon: "#x3F5",
  straightphi: "#x3D5",
  strns: "macr",
  subE: "#x2AC5",
  subdot: "#x2ABD",
  subedot: "#x2AC3",
  submult: "#x2AC1",
  subnE: "#x2ACB",
  subne: "#x228A",
  subplus: "#x2ABF",
  subrarr: "#x2979",
  subset: "sub",
  subseteq: "sube",
  subseteqq: "#x2AC5",
  subsetneq: "#x228A",
  subsetneqq: "#x2ACB",
  subsim: "#x2AC7",
  subsub: "#x2AD5",
  subsup: "#x2AD3",
  succ: "#x227B",
  succapprox: "#x2AB8",
  succcurlyeq: "#x227D",
  succeq: "#x2AB0",
  succnapprox: "#x2ABA",
  succneqq: "#x2AB6",
  succnsim: "#x22E9",
  succsim: "#x227F",
  sung: "#x266A",
  supE: "#x2AC6",
  supdot: "#x2ABE",
  supdsub: "#x2AD8",
  supedot: "#x2AC4",
  suphsol: "#x27C9",
  suphsub: "#x2AD7",
  suplarr: "#x297B",
  supmult: "#x2AC2",
  supnE: "#x2ACC",
  supne: "#x228B",
  supplus: "#x2AC0",
  supset: "sup",
  supseteq: "supe",
  supseteqq: "#x2AC6",
  supsetneq: "#x228B",
  supsetneqq: "#x2ACC",
  supsim: "#x2AC8",
  supsub: "#x2AD4",
  supsup: "#x2AD6",
  swArr: "#x21D9",
  swarhk: "#x2926",
  swarr: "#x2199",
  swarrow: "#x2199",
  swnwar: "#x292A",
  target: "#x2316",
  tbrk: "#x23B4",
  tcaron: "#x165",
  tcedil: "#x163",
  tcy: "#x442",
  tdot: "#x20DB",
  telrec: "#x2315",
  tfr: "#x1D531",
  therefore: "there4",
  thetav: "#x3D1",
  thickapprox: "#x2248",
  thicksim: "sim",
  thkap: "#x2248",
  thksim: "sim",
  timesb: "#x22A0",
  timesbar: "#x2A31",
  timesd: "#x2A30",
  tint: "#x222D",
  toea: "#x2928",
  top: "#x22A4",
  topbot: "#x2336",
  topcir: "#x2AF1",
  topf: "#x1D565",
  topfork: "#x2ADA",
  tosa: "#x2929",
  tprime: "#x2034",
  triangle: "#x25B5",
  triangledown: "#x25BF",
  triangleleft: "#x25C3",
  trianglelefteq: "#x22B4",
  triangleq: "#x225C",
  triangleright: "#x25B9",
  trianglerighteq: "#x22B5",
  tridot: "#x25EC",
  trie: "#x225C",
  triminus: "#x2A3A",
  triplus: "#x2A39",
  trisb: "#x29CD",
  tritime: "#x2A3B",
  trpezium: "#x23E2",
  tscr: "#x1D4C9",
  tscy: "#x446",
  tshcy: "#x45B",
  tstrok: "#x167",
  twixt: "#x226C",
  twoheadleftarrow: "#x219E",
  twoheadrightarrow: "#x21A0",
  uHar: "#x2963",
  ubrcy: "#x45E",
  ubreve: "#x16D",
  ucy: "#x443",
  udarr: "#x21C5",
  udblac: "#x171",
  udhar: "#x296E",
  ufisht: "#x297E",
  ufr: "#x1D532",
  uharl: "#x21BF",
  uharr: "#x21BE",
  uhblk: "#x2580",
  ulcorn: "#x231C",
  ulcorner: "#x231C",
  ulcrop: "#x230F",
  ultri: "#x25F8",
  umacr: "#x16B",
  uogon: "#x173",
  uopf: "#x1D566",
  uparrow: "uarr",
  updownarrow: "#x2195",
  upharpoonleft: "#x21BF",
  upharpoonright: "#x21BE",
  uplus: "#x228E",
  upsi: "#x3C5",
  upuparrows: "#x21C8",
  urcorn: "#x231D",
  urcorner: "#x231D",
  urcrop: "#x230E",
  uring: "#x16F",
  urtri: "#x25F9",
  uscr: "#x1D4CA",
  utdot: "#x22F0",
  utilde: "#x169",
  utri: "#x25B5",
  utrif: "#x25B4",
  uuarr: "#x21C8",
  uwangle: "#x29A7",
  vArr: "#x21D5",
  vBar: "#x2AE8",
  vBarv: "#x2AE9",
  vDash: "#x22A8",
  vangrt: "#x299C",
  varepsilon: "#x3F5",
  varkappa: "#x3F0",
  varnothing: "empty",
  varphi: "#x3D5",
  varpi: "piv",
  varpropto: "prop",
  varr: "#x2195",
  varrho: "#x3F1",
  varsigma: "sigmaf",
  varsubsetneq: "#x228A;&#xFE00",
  varsubsetneqq: "#x2ACB;&#xFE00",
  varsupsetneq: "#x228B;&#xFE00",
  varsupsetneqq: "#x2ACC;&#xFE00",
  vartheta: "#x3D1",
  vartriangleleft: "#x22B2",
  vartriangleright: "#x22B3",
  vcy: "#x432",
  vdash: "#x22A2",
  vee: "or",
  veebar: "#x22BB",
  veeeq: "#x225A",
  vellip: "#x22EE",
  vfr: "#x1D533",
  vltri: "#x22B2",
  vnsub: "#x2282;&#x20D2",
  vnsup: "#x2283;&#x20D2",
  vopf: "#x1D567",
  vprop: "prop",
  vrtri: "#x22B3",
  vscr: "#x1D4CB",
  vsubnE: "#x2ACB;&#xFE00",
  vsubne: "#x228A;&#xFE00",
  vsupnE: "#x2ACC;&#xFE00",
  vsupne: "#x228B;&#xFE00",
  vzigzag: "#x299A",
  wcirc: "#x175",
  wedbar: "#x2A5F",
  wedge: "and",
  wedgeq: "#x2259",
  wfr: "#x1D534",
  wopf: "#x1D568",
  wp: "#x2118",
  wr: "#x2240",
  wreath: "#x2240",
  wscr: "#x1D4CC",
  xcap: "#x22C2",
  xcirc: "#x25EF",
  xcup: "#x22C3",
  xdtri: "#x25BD",
  xfr: "#x1D535",
  xhArr: "#x27FA",
  xharr: "#x27F7",
  xlArr: "#x27F8",
  xlarr: "#x27F5",
  xmap: "#x27FC",
  xnis: "#x22FB",
  xodot: "#x2A00",
  xopf: "#x1D569",
  xoplus: "#x2A01",
  xotime: "#x2A02",
  xrArr: "#x27F9",
  xrarr: "#x27F6",
  xscr: "#x1D4CD",
  xsqcup: "#x2A06",
  xuplus: "#x2A04",
  xutri: "#x25B3",
  xvee: "#x22C1",
  xwedge: "#x22C0",
  yacy: "#x44F",
  ycirc: "#x177",
  ycy: "#x44B",
  yfr: "#x1D536",
  yicy: "#x457",
  yopf: "#x1D56A",
  yscr: "#x1D4CE",
  yucy: "#x44E",
  zacute: "#x17A",
  zcaron: "#x17E",
  zcy: "#x437",
  zdot: "#x17C",
  zeetrf: "#x2128",
  zfr: "#x1D537",
  zhcy: "#x436",
  zigrarr: "#x21DD",
  zopf: "#x1D56B",
  zscr: "#x1D4CF"
};

// rule: bad-named-html-entity-not-email-friendly

function htmlEntitiesNotEmailFriendly(context) {
  return {
    entity: function entity(_ref) {
      var idxFrom = _ref.idxFrom,
          idxTo = _ref.idxTo;

      if (Object.keys(notEmailFriendly).includes(context.str.slice(idxFrom + 1, idxTo - 1))) {
        context.report({
          ruleId: "bad-named-html-entity-not-email-friendly",
          message: "Email-unfriendly named HTML entity.",
          idxFrom: idxFrom,
          idxTo: idxTo,
          fix: {
            ranges: [[idxFrom, idxTo, "&" + notEmailFriendly[context.str.slice(idxFrom + 1, idxTo - 1)] + ";"]]
          }
        });
      }
    }
  };
}

/*! https://mths.be/he v1.2.0 by @mathias | MIT license */
var he = createCommonjsModule(function (module, exports) {

  (function (root) {
    // Detect free variables `exports`.
    var freeExports = exports; // Detect free variable `module`.

    var freeModule = module && module.exports == freeExports && module; // Detect free variable `global`, from Node.js or Browserified code,
    // and use it as `root`.

    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal;

    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
      root = freeGlobal;
    }
    /*--------------------------------------------------------------------------*/
    // All astral symbols.


    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g; // All ASCII symbols (not just printable ASCII) except those listed in the
    // first column of the overrides table.
    // https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides

    var regexAsciiWhitelist = /[\x01-\x7F]/g; // All BMP symbols that are not ASCII newlines, printable ASCII symbols, or
    // code points listed in the first column of the overrides table on
    // https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.

    var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
    var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
    var encodeMap = {
      '\xAD': 'shy',
      "\u200C": 'zwnj',
      "\u200D": 'zwj',
      "\u200E": 'lrm',
      "\u2063": 'ic',
      "\u2062": 'it',
      "\u2061": 'af',
      "\u200F": 'rlm',
      "\u200B": 'ZeroWidthSpace',
      "\u2060": 'NoBreak',
      "\u0311": 'DownBreve',
      "\u20DB": 'tdot',
      "\u20DC": 'DotDot',
      '\t': 'Tab',
      '\n': 'NewLine',
      "\u2008": 'puncsp',
      "\u205F": 'MediumSpace',
      "\u2009": 'thinsp',
      "\u200A": 'hairsp',
      "\u2004": 'emsp13',
      "\u2002": 'ensp',
      "\u2005": 'emsp14',
      "\u2003": 'emsp',
      "\u2007": 'numsp',
      '\xA0': 'nbsp',
      "\u205F\u200A": 'ThickSpace',
      "\u203E": 'oline',
      '_': 'lowbar',
      "\u2010": 'dash',
      "\u2013": 'ndash',
      "\u2014": 'mdash',
      "\u2015": 'horbar',
      ',': 'comma',
      ';': 'semi',
      "\u204F": 'bsemi',
      ':': 'colon',
      "\u2A74": 'Colone',
      '!': 'excl',
      '\xA1': 'iexcl',
      '?': 'quest',
      '\xBF': 'iquest',
      '.': 'period',
      "\u2025": 'nldr',
      "\u2026": 'mldr',
      '\xB7': 'middot',
      '\'': 'apos',
      "\u2018": 'lsquo',
      "\u2019": 'rsquo',
      "\u201A": 'sbquo',
      "\u2039": 'lsaquo',
      "\u203A": 'rsaquo',
      '"': 'quot',
      "\u201C": 'ldquo',
      "\u201D": 'rdquo',
      "\u201E": 'bdquo',
      '\xAB': 'laquo',
      '\xBB': 'raquo',
      '(': 'lpar',
      ')': 'rpar',
      '[': 'lsqb',
      ']': 'rsqb',
      '{': 'lcub',
      '}': 'rcub',
      "\u2308": 'lceil',
      "\u2309": 'rceil',
      "\u230A": 'lfloor',
      "\u230B": 'rfloor',
      "\u2985": 'lopar',
      "\u2986": 'ropar',
      "\u298B": 'lbrke',
      "\u298C": 'rbrke',
      "\u298D": 'lbrkslu',
      "\u298E": 'rbrksld',
      "\u298F": 'lbrksld',
      "\u2990": 'rbrkslu',
      "\u2991": 'langd',
      "\u2992": 'rangd',
      "\u2993": 'lparlt',
      "\u2994": 'rpargt',
      "\u2995": 'gtlPar',
      "\u2996": 'ltrPar',
      "\u27E6": 'lobrk',
      "\u27E7": 'robrk',
      "\u27E8": 'lang',
      "\u27E9": 'rang',
      "\u27EA": 'Lang',
      "\u27EB": 'Rang',
      "\u27EC": 'loang',
      "\u27ED": 'roang',
      "\u2772": 'lbbrk',
      "\u2773": 'rbbrk',
      "\u2016": 'Vert',
      '\xA7': 'sect',
      '\xB6': 'para',
      '@': 'commat',
      '*': 'ast',
      '/': 'sol',
      'undefined': null,
      '&': 'amp',
      '#': 'num',
      '%': 'percnt',
      "\u2030": 'permil',
      "\u2031": 'pertenk',
      "\u2020": 'dagger',
      "\u2021": 'Dagger',
      "\u2022": 'bull',
      "\u2043": 'hybull',
      "\u2032": 'prime',
      "\u2033": 'Prime',
      "\u2034": 'tprime',
      "\u2057": 'qprime',
      "\u2035": 'bprime',
      "\u2041": 'caret',
      '`': 'grave',
      '\xB4': 'acute',
      "\u02DC": 'tilde',
      '^': 'Hat',
      '\xAF': 'macr',
      "\u02D8": 'breve',
      "\u02D9": 'dot',
      '\xA8': 'die',
      "\u02DA": 'ring',
      "\u02DD": 'dblac',
      '\xB8': 'cedil',
      "\u02DB": 'ogon',
      "\u02C6": 'circ',
      "\u02C7": 'caron',
      '\xB0': 'deg',
      '\xA9': 'copy',
      '\xAE': 'reg',
      "\u2117": 'copysr',
      "\u2118": 'wp',
      "\u211E": 'rx',
      "\u2127": 'mho',
      "\u2129": 'iiota',
      "\u2190": 'larr',
      "\u219A": 'nlarr',
      "\u2192": 'rarr',
      "\u219B": 'nrarr',
      "\u2191": 'uarr',
      "\u2193": 'darr',
      "\u2194": 'harr',
      "\u21AE": 'nharr',
      "\u2195": 'varr',
      "\u2196": 'nwarr',
      "\u2197": 'nearr',
      "\u2198": 'searr',
      "\u2199": 'swarr',
      "\u219D": 'rarrw',
      "\u219D\u0338": 'nrarrw',
      "\u219E": 'Larr',
      "\u219F": 'Uarr',
      "\u21A0": 'Rarr',
      "\u21A1": 'Darr',
      "\u21A2": 'larrtl',
      "\u21A3": 'rarrtl',
      "\u21A4": 'mapstoleft',
      "\u21A5": 'mapstoup',
      "\u21A6": 'map',
      "\u21A7": 'mapstodown',
      "\u21A9": 'larrhk',
      "\u21AA": 'rarrhk',
      "\u21AB": 'larrlp',
      "\u21AC": 'rarrlp',
      "\u21AD": 'harrw',
      "\u21B0": 'lsh',
      "\u21B1": 'rsh',
      "\u21B2": 'ldsh',
      "\u21B3": 'rdsh',
      "\u21B5": 'crarr',
      "\u21B6": 'cularr',
      "\u21B7": 'curarr',
      "\u21BA": 'olarr',
      "\u21BB": 'orarr',
      "\u21BC": 'lharu',
      "\u21BD": 'lhard',
      "\u21BE": 'uharr',
      "\u21BF": 'uharl',
      "\u21C0": 'rharu',
      "\u21C1": 'rhard',
      "\u21C2": 'dharr',
      "\u21C3": 'dharl',
      "\u21C4": 'rlarr',
      "\u21C5": 'udarr',
      "\u21C6": 'lrarr',
      "\u21C7": 'llarr',
      "\u21C8": 'uuarr',
      "\u21C9": 'rrarr',
      "\u21CA": 'ddarr',
      "\u21CB": 'lrhar',
      "\u21CC": 'rlhar',
      "\u21D0": 'lArr',
      "\u21CD": 'nlArr',
      "\u21D1": 'uArr',
      "\u21D2": 'rArr',
      "\u21CF": 'nrArr',
      "\u21D3": 'dArr',
      "\u21D4": 'iff',
      "\u21CE": 'nhArr',
      "\u21D5": 'vArr',
      "\u21D6": 'nwArr',
      "\u21D7": 'neArr',
      "\u21D8": 'seArr',
      "\u21D9": 'swArr',
      "\u21DA": 'lAarr',
      "\u21DB": 'rAarr',
      "\u21DD": 'zigrarr',
      "\u21E4": 'larrb',
      "\u21E5": 'rarrb',
      "\u21F5": 'duarr',
      "\u21FD": 'loarr',
      "\u21FE": 'roarr',
      "\u21FF": 'hoarr',
      "\u2200": 'forall',
      "\u2201": 'comp',
      "\u2202": 'part',
      "\u2202\u0338": 'npart',
      "\u2203": 'exist',
      "\u2204": 'nexist',
      "\u2205": 'empty',
      "\u2207": 'Del',
      "\u2208": 'in',
      "\u2209": 'notin',
      "\u220B": 'ni',
      "\u220C": 'notni',
      "\u03F6": 'bepsi',
      "\u220F": 'prod',
      "\u2210": 'coprod',
      "\u2211": 'sum',
      '+': 'plus',
      '\xB1': 'pm',
      '\xF7': 'div',
      '\xD7': 'times',
      '<': 'lt',
      "\u226E": 'nlt',
      "<\u20D2": 'nvlt',
      '=': 'equals',
      "\u2260": 'ne',
      "=\u20E5": 'bne',
      "\u2A75": 'Equal',
      '>': 'gt',
      "\u226F": 'ngt',
      ">\u20D2": 'nvgt',
      '\xAC': 'not',
      '|': 'vert',
      '\xA6': 'brvbar',
      "\u2212": 'minus',
      "\u2213": 'mp',
      "\u2214": 'plusdo',
      "\u2044": 'frasl',
      "\u2216": 'setmn',
      "\u2217": 'lowast',
      "\u2218": 'compfn',
      "\u221A": 'Sqrt',
      "\u221D": 'prop',
      "\u221E": 'infin',
      "\u221F": 'angrt',
      "\u2220": 'ang',
      "\u2220\u20D2": 'nang',
      "\u2221": 'angmsd',
      "\u2222": 'angsph',
      "\u2223": 'mid',
      "\u2224": 'nmid',
      "\u2225": 'par',
      "\u2226": 'npar',
      "\u2227": 'and',
      "\u2228": 'or',
      "\u2229": 'cap',
      "\u2229\uFE00": 'caps',
      "\u222A": 'cup',
      "\u222A\uFE00": 'cups',
      "\u222B": 'int',
      "\u222C": 'Int',
      "\u222D": 'tint',
      "\u2A0C": 'qint',
      "\u222E": 'oint',
      "\u222F": 'Conint',
      "\u2230": 'Cconint',
      "\u2231": 'cwint',
      "\u2232": 'cwconint',
      "\u2233": 'awconint',
      "\u2234": 'there4',
      "\u2235": 'becaus',
      "\u2236": 'ratio',
      "\u2237": 'Colon',
      "\u2238": 'minusd',
      "\u223A": 'mDDot',
      "\u223B": 'homtht',
      "\u223C": 'sim',
      "\u2241": 'nsim',
      "\u223C\u20D2": 'nvsim',
      "\u223D": 'bsim',
      "\u223D\u0331": 'race',
      "\u223E": 'ac',
      "\u223E\u0333": 'acE',
      "\u223F": 'acd',
      "\u2240": 'wr',
      "\u2242": 'esim',
      "\u2242\u0338": 'nesim',
      "\u2243": 'sime',
      "\u2244": 'nsime',
      "\u2245": 'cong',
      "\u2247": 'ncong',
      "\u2246": 'simne',
      "\u2248": 'ap',
      "\u2249": 'nap',
      "\u224A": 'ape',
      "\u224B": 'apid',
      "\u224B\u0338": 'napid',
      "\u224C": 'bcong',
      "\u224D": 'CupCap',
      "\u226D": 'NotCupCap',
      "\u224D\u20D2": 'nvap',
      "\u224E": 'bump',
      "\u224E\u0338": 'nbump',
      "\u224F": 'bumpe',
      "\u224F\u0338": 'nbumpe',
      "\u2250": 'doteq',
      "\u2250\u0338": 'nedot',
      "\u2251": 'eDot',
      "\u2252": 'efDot',
      "\u2253": 'erDot',
      "\u2254": 'colone',
      "\u2255": 'ecolon',
      "\u2256": 'ecir',
      "\u2257": 'cire',
      "\u2259": 'wedgeq',
      "\u225A": 'veeeq',
      "\u225C": 'trie',
      "\u225F": 'equest',
      "\u2261": 'equiv',
      "\u2262": 'nequiv',
      "\u2261\u20E5": 'bnequiv',
      "\u2264": 'le',
      "\u2270": 'nle',
      "\u2264\u20D2": 'nvle',
      "\u2265": 'ge',
      "\u2271": 'nge',
      "\u2265\u20D2": 'nvge',
      "\u2266": 'lE',
      "\u2266\u0338": 'nlE',
      "\u2267": 'gE',
      "\u2267\u0338": 'ngE',
      "\u2268\uFE00": 'lvnE',
      "\u2268": 'lnE',
      "\u2269": 'gnE',
      "\u2269\uFE00": 'gvnE',
      "\u226A": 'll',
      "\u226A\u0338": 'nLtv',
      "\u226A\u20D2": 'nLt',
      "\u226B": 'gg',
      "\u226B\u0338": 'nGtv',
      "\u226B\u20D2": 'nGt',
      "\u226C": 'twixt',
      "\u2272": 'lsim',
      "\u2274": 'nlsim',
      "\u2273": 'gsim',
      "\u2275": 'ngsim',
      "\u2276": 'lg',
      "\u2278": 'ntlg',
      "\u2277": 'gl',
      "\u2279": 'ntgl',
      "\u227A": 'pr',
      "\u2280": 'npr',
      "\u227B": 'sc',
      "\u2281": 'nsc',
      "\u227C": 'prcue',
      "\u22E0": 'nprcue',
      "\u227D": 'sccue',
      "\u22E1": 'nsccue',
      "\u227E": 'prsim',
      "\u227F": 'scsim',
      "\u227F\u0338": 'NotSucceedsTilde',
      "\u2282": 'sub',
      "\u2284": 'nsub',
      "\u2282\u20D2": 'vnsub',
      "\u2283": 'sup',
      "\u2285": 'nsup',
      "\u2283\u20D2": 'vnsup',
      "\u2286": 'sube',
      "\u2288": 'nsube',
      "\u2287": 'supe',
      "\u2289": 'nsupe',
      "\u228A\uFE00": 'vsubne',
      "\u228A": 'subne',
      "\u228B\uFE00": 'vsupne',
      "\u228B": 'supne',
      "\u228D": 'cupdot',
      "\u228E": 'uplus',
      "\u228F": 'sqsub',
      "\u228F\u0338": 'NotSquareSubset',
      "\u2290": 'sqsup',
      "\u2290\u0338": 'NotSquareSuperset',
      "\u2291": 'sqsube',
      "\u22E2": 'nsqsube',
      "\u2292": 'sqsupe',
      "\u22E3": 'nsqsupe',
      "\u2293": 'sqcap',
      "\u2293\uFE00": 'sqcaps',
      "\u2294": 'sqcup',
      "\u2294\uFE00": 'sqcups',
      "\u2295": 'oplus',
      "\u2296": 'ominus',
      "\u2297": 'otimes',
      "\u2298": 'osol',
      "\u2299": 'odot',
      "\u229A": 'ocir',
      "\u229B": 'oast',
      "\u229D": 'odash',
      "\u229E": 'plusb',
      "\u229F": 'minusb',
      "\u22A0": 'timesb',
      "\u22A1": 'sdotb',
      "\u22A2": 'vdash',
      "\u22AC": 'nvdash',
      "\u22A3": 'dashv',
      "\u22A4": 'top',
      "\u22A5": 'bot',
      "\u22A7": 'models',
      "\u22A8": 'vDash',
      "\u22AD": 'nvDash',
      "\u22A9": 'Vdash',
      "\u22AE": 'nVdash',
      "\u22AA": 'Vvdash',
      "\u22AB": 'VDash',
      "\u22AF": 'nVDash',
      "\u22B0": 'prurel',
      "\u22B2": 'vltri',
      "\u22EA": 'nltri',
      "\u22B3": 'vrtri',
      "\u22EB": 'nrtri',
      "\u22B4": 'ltrie',
      "\u22EC": 'nltrie',
      "\u22B4\u20D2": 'nvltrie',
      "\u22B5": 'rtrie',
      "\u22ED": 'nrtrie',
      "\u22B5\u20D2": 'nvrtrie',
      "\u22B6": 'origof',
      "\u22B7": 'imof',
      "\u22B8": 'mumap',
      "\u22B9": 'hercon',
      "\u22BA": 'intcal',
      "\u22BB": 'veebar',
      "\u22BD": 'barvee',
      "\u22BE": 'angrtvb',
      "\u22BF": 'lrtri',
      "\u22C0": 'Wedge',
      "\u22C1": 'Vee',
      "\u22C2": 'xcap',
      "\u22C3": 'xcup',
      "\u22C4": 'diam',
      "\u22C5": 'sdot',
      "\u22C6": 'Star',
      "\u22C7": 'divonx',
      "\u22C8": 'bowtie',
      "\u22C9": 'ltimes',
      "\u22CA": 'rtimes',
      "\u22CB": 'lthree',
      "\u22CC": 'rthree',
      "\u22CD": 'bsime',
      "\u22CE": 'cuvee',
      "\u22CF": 'cuwed',
      "\u22D0": 'Sub',
      "\u22D1": 'Sup',
      "\u22D2": 'Cap',
      "\u22D3": 'Cup',
      "\u22D4": 'fork',
      "\u22D5": 'epar',
      "\u22D6": 'ltdot',
      "\u22D7": 'gtdot',
      "\u22D8": 'Ll',
      "\u22D8\u0338": 'nLl',
      "\u22D9": 'Gg',
      "\u22D9\u0338": 'nGg',
      "\u22DA\uFE00": 'lesg',
      "\u22DA": 'leg',
      "\u22DB": 'gel',
      "\u22DB\uFE00": 'gesl',
      "\u22DE": 'cuepr',
      "\u22DF": 'cuesc',
      "\u22E6": 'lnsim',
      "\u22E7": 'gnsim',
      "\u22E8": 'prnsim',
      "\u22E9": 'scnsim',
      "\u22EE": 'vellip',
      "\u22EF": 'ctdot',
      "\u22F0": 'utdot',
      "\u22F1": 'dtdot',
      "\u22F2": 'disin',
      "\u22F3": 'isinsv',
      "\u22F4": 'isins',
      "\u22F5": 'isindot',
      "\u22F5\u0338": 'notindot',
      "\u22F6": 'notinvc',
      "\u22F7": 'notinvb',
      "\u22F9": 'isinE',
      "\u22F9\u0338": 'notinE',
      "\u22FA": 'nisd',
      "\u22FB": 'xnis',
      "\u22FC": 'nis',
      "\u22FD": 'notnivc',
      "\u22FE": 'notnivb',
      "\u2305": 'barwed',
      "\u2306": 'Barwed',
      "\u230C": 'drcrop',
      "\u230D": 'dlcrop',
      "\u230E": 'urcrop',
      "\u230F": 'ulcrop',
      "\u2310": 'bnot',
      "\u2312": 'profline',
      "\u2313": 'profsurf',
      "\u2315": 'telrec',
      "\u2316": 'target',
      "\u231C": 'ulcorn',
      "\u231D": 'urcorn',
      "\u231E": 'dlcorn',
      "\u231F": 'drcorn',
      "\u2322": 'frown',
      "\u2323": 'smile',
      "\u232D": 'cylcty',
      "\u232E": 'profalar',
      "\u2336": 'topbot',
      "\u233D": 'ovbar',
      "\u233F": 'solbar',
      "\u237C": 'angzarr',
      "\u23B0": 'lmoust',
      "\u23B1": 'rmoust',
      "\u23B4": 'tbrk',
      "\u23B5": 'bbrk',
      "\u23B6": 'bbrktbrk',
      "\u23DC": 'OverParenthesis',
      "\u23DD": 'UnderParenthesis',
      "\u23DE": 'OverBrace',
      "\u23DF": 'UnderBrace',
      "\u23E2": 'trpezium',
      "\u23E7": 'elinters',
      "\u2423": 'blank',
      "\u2500": 'boxh',
      "\u2502": 'boxv',
      "\u250C": 'boxdr',
      "\u2510": 'boxdl',
      "\u2514": 'boxur',
      "\u2518": 'boxul',
      "\u251C": 'boxvr',
      "\u2524": 'boxvl',
      "\u252C": 'boxhd',
      "\u2534": 'boxhu',
      "\u253C": 'boxvh',
      "\u2550": 'boxH',
      "\u2551": 'boxV',
      "\u2552": 'boxdR',
      "\u2553": 'boxDr',
      "\u2554": 'boxDR',
      "\u2555": 'boxdL',
      "\u2556": 'boxDl',
      "\u2557": 'boxDL',
      "\u2558": 'boxuR',
      "\u2559": 'boxUr',
      "\u255A": 'boxUR',
      "\u255B": 'boxuL',
      "\u255C": 'boxUl',
      "\u255D": 'boxUL',
      "\u255E": 'boxvR',
      "\u255F": 'boxVr',
      "\u2560": 'boxVR',
      "\u2561": 'boxvL',
      "\u2562": 'boxVl',
      "\u2563": 'boxVL',
      "\u2564": 'boxHd',
      "\u2565": 'boxhD',
      "\u2566": 'boxHD',
      "\u2567": 'boxHu',
      "\u2568": 'boxhU',
      "\u2569": 'boxHU',
      "\u256A": 'boxvH',
      "\u256B": 'boxVh',
      "\u256C": 'boxVH',
      "\u2580": 'uhblk',
      "\u2584": 'lhblk',
      "\u2588": 'block',
      "\u2591": 'blk14',
      "\u2592": 'blk12',
      "\u2593": 'blk34',
      "\u25A1": 'squ',
      "\u25AA": 'squf',
      "\u25AB": 'EmptyVerySmallSquare',
      "\u25AD": 'rect',
      "\u25AE": 'marker',
      "\u25B1": 'fltns',
      "\u25B3": 'xutri',
      "\u25B4": 'utrif',
      "\u25B5": 'utri',
      "\u25B8": 'rtrif',
      "\u25B9": 'rtri',
      "\u25BD": 'xdtri',
      "\u25BE": 'dtrif',
      "\u25BF": 'dtri',
      "\u25C2": 'ltrif',
      "\u25C3": 'ltri',
      "\u25CA": 'loz',
      "\u25CB": 'cir',
      "\u25EC": 'tridot',
      "\u25EF": 'xcirc',
      "\u25F8": 'ultri',
      "\u25F9": 'urtri',
      "\u25FA": 'lltri',
      "\u25FB": 'EmptySmallSquare',
      "\u25FC": 'FilledSmallSquare',
      "\u2605": 'starf',
      "\u2606": 'star',
      "\u260E": 'phone',
      "\u2640": 'female',
      "\u2642": 'male',
      "\u2660": 'spades',
      "\u2663": 'clubs',
      "\u2665": 'hearts',
      "\u2666": 'diams',
      "\u266A": 'sung',
      "\u2713": 'check',
      "\u2717": 'cross',
      "\u2720": 'malt',
      "\u2736": 'sext',
      "\u2758": 'VerticalSeparator',
      "\u27C8": 'bsolhsub',
      "\u27C9": 'suphsol',
      "\u27F5": 'xlarr',
      "\u27F6": 'xrarr',
      "\u27F7": 'xharr',
      "\u27F8": 'xlArr',
      "\u27F9": 'xrArr',
      "\u27FA": 'xhArr',
      "\u27FC": 'xmap',
      "\u27FF": 'dzigrarr',
      "\u2902": 'nvlArr',
      "\u2903": 'nvrArr',
      "\u2904": 'nvHarr',
      "\u2905": 'Map',
      "\u290C": 'lbarr',
      "\u290D": 'rbarr',
      "\u290E": 'lBarr',
      "\u290F": 'rBarr',
      "\u2910": 'RBarr',
      "\u2911": 'DDotrahd',
      "\u2912": 'UpArrowBar',
      "\u2913": 'DownArrowBar',
      "\u2916": 'Rarrtl',
      "\u2919": 'latail',
      "\u291A": 'ratail',
      "\u291B": 'lAtail',
      "\u291C": 'rAtail',
      "\u291D": 'larrfs',
      "\u291E": 'rarrfs',
      "\u291F": 'larrbfs',
      "\u2920": 'rarrbfs',
      "\u2923": 'nwarhk',
      "\u2924": 'nearhk',
      "\u2925": 'searhk',
      "\u2926": 'swarhk',
      "\u2927": 'nwnear',
      "\u2928": 'toea',
      "\u2929": 'tosa',
      "\u292A": 'swnwar',
      "\u2933": 'rarrc',
      "\u2933\u0338": 'nrarrc',
      "\u2935": 'cudarrr',
      "\u2936": 'ldca',
      "\u2937": 'rdca',
      "\u2938": 'cudarrl',
      "\u2939": 'larrpl',
      "\u293C": 'curarrm',
      "\u293D": 'cularrp',
      "\u2945": 'rarrpl',
      "\u2948": 'harrcir',
      "\u2949": 'Uarrocir',
      "\u294A": 'lurdshar',
      "\u294B": 'ldrushar',
      "\u294E": 'LeftRightVector',
      "\u294F": 'RightUpDownVector',
      "\u2950": 'DownLeftRightVector',
      "\u2951": 'LeftUpDownVector',
      "\u2952": 'LeftVectorBar',
      "\u2953": 'RightVectorBar',
      "\u2954": 'RightUpVectorBar',
      "\u2955": 'RightDownVectorBar',
      "\u2956": 'DownLeftVectorBar',
      "\u2957": 'DownRightVectorBar',
      "\u2958": 'LeftUpVectorBar',
      "\u2959": 'LeftDownVectorBar',
      "\u295A": 'LeftTeeVector',
      "\u295B": 'RightTeeVector',
      "\u295C": 'RightUpTeeVector',
      "\u295D": 'RightDownTeeVector',
      "\u295E": 'DownLeftTeeVector',
      "\u295F": 'DownRightTeeVector',
      "\u2960": 'LeftUpTeeVector',
      "\u2961": 'LeftDownTeeVector',
      "\u2962": 'lHar',
      "\u2963": 'uHar',
      "\u2964": 'rHar',
      "\u2965": 'dHar',
      "\u2966": 'luruhar',
      "\u2967": 'ldrdhar',
      "\u2968": 'ruluhar',
      "\u2969": 'rdldhar',
      "\u296A": 'lharul',
      "\u296B": 'llhard',
      "\u296C": 'rharul',
      "\u296D": 'lrhard',
      "\u296E": 'udhar',
      "\u296F": 'duhar',
      "\u2970": 'RoundImplies',
      "\u2971": 'erarr',
      "\u2972": 'simrarr',
      "\u2973": 'larrsim',
      "\u2974": 'rarrsim',
      "\u2975": 'rarrap',
      "\u2976": 'ltlarr',
      "\u2978": 'gtrarr',
      "\u2979": 'subrarr',
      "\u297B": 'suplarr',
      "\u297C": 'lfisht',
      "\u297D": 'rfisht',
      "\u297E": 'ufisht',
      "\u297F": 'dfisht',
      "\u299A": 'vzigzag',
      "\u299C": 'vangrt',
      "\u299D": 'angrtvbd',
      "\u29A4": 'ange',
      "\u29A5": 'range',
      "\u29A6": 'dwangle',
      "\u29A7": 'uwangle',
      "\u29A8": 'angmsdaa',
      "\u29A9": 'angmsdab',
      "\u29AA": 'angmsdac',
      "\u29AB": 'angmsdad',
      "\u29AC": 'angmsdae',
      "\u29AD": 'angmsdaf',
      "\u29AE": 'angmsdag',
      "\u29AF": 'angmsdah',
      "\u29B0": 'bemptyv',
      "\u29B1": 'demptyv',
      "\u29B2": 'cemptyv',
      "\u29B3": 'raemptyv',
      "\u29B4": 'laemptyv',
      "\u29B5": 'ohbar',
      "\u29B6": 'omid',
      "\u29B7": 'opar',
      "\u29B9": 'operp',
      "\u29BB": 'olcross',
      "\u29BC": 'odsold',
      "\u29BE": 'olcir',
      "\u29BF": 'ofcir',
      "\u29C0": 'olt',
      "\u29C1": 'ogt',
      "\u29C2": 'cirscir',
      "\u29C3": 'cirE',
      "\u29C4": 'solb',
      "\u29C5": 'bsolb',
      "\u29C9": 'boxbox',
      "\u29CD": 'trisb',
      "\u29CE": 'rtriltri',
      "\u29CF": 'LeftTriangleBar',
      "\u29CF\u0338": 'NotLeftTriangleBar',
      "\u29D0": 'RightTriangleBar',
      "\u29D0\u0338": 'NotRightTriangleBar',
      "\u29DC": 'iinfin',
      "\u29DD": 'infintie',
      "\u29DE": 'nvinfin',
      "\u29E3": 'eparsl',
      "\u29E4": 'smeparsl',
      "\u29E5": 'eqvparsl',
      "\u29EB": 'lozf',
      "\u29F4": 'RuleDelayed',
      "\u29F6": 'dsol',
      "\u2A00": 'xodot',
      "\u2A01": 'xoplus',
      "\u2A02": 'xotime',
      "\u2A04": 'xuplus',
      "\u2A06": 'xsqcup',
      "\u2A0D": 'fpartint',
      "\u2A10": 'cirfnint',
      "\u2A11": 'awint',
      "\u2A12": 'rppolint',
      "\u2A13": 'scpolint',
      "\u2A14": 'npolint',
      "\u2A15": 'pointint',
      "\u2A16": 'quatint',
      "\u2A17": 'intlarhk',
      "\u2A22": 'pluscir',
      "\u2A23": 'plusacir',
      "\u2A24": 'simplus',
      "\u2A25": 'plusdu',
      "\u2A26": 'plussim',
      "\u2A27": 'plustwo',
      "\u2A29": 'mcomma',
      "\u2A2A": 'minusdu',
      "\u2A2D": 'loplus',
      "\u2A2E": 'roplus',
      "\u2A2F": 'Cross',
      "\u2A30": 'timesd',
      "\u2A31": 'timesbar',
      "\u2A33": 'smashp',
      "\u2A34": 'lotimes',
      "\u2A35": 'rotimes',
      "\u2A36": 'otimesas',
      "\u2A37": 'Otimes',
      "\u2A38": 'odiv',
      "\u2A39": 'triplus',
      "\u2A3A": 'triminus',
      "\u2A3B": 'tritime',
      "\u2A3C": 'iprod',
      "\u2A3F": 'amalg',
      "\u2A40": 'capdot',
      "\u2A42": 'ncup',
      "\u2A43": 'ncap',
      "\u2A44": 'capand',
      "\u2A45": 'cupor',
      "\u2A46": 'cupcap',
      "\u2A47": 'capcup',
      "\u2A48": 'cupbrcap',
      "\u2A49": 'capbrcup',
      "\u2A4A": 'cupcup',
      "\u2A4B": 'capcap',
      "\u2A4C": 'ccups',
      "\u2A4D": 'ccaps',
      "\u2A50": 'ccupssm',
      "\u2A53": 'And',
      "\u2A54": 'Or',
      "\u2A55": 'andand',
      "\u2A56": 'oror',
      "\u2A57": 'orslope',
      "\u2A58": 'andslope',
      "\u2A5A": 'andv',
      "\u2A5B": 'orv',
      "\u2A5C": 'andd',
      "\u2A5D": 'ord',
      "\u2A5F": 'wedbar',
      "\u2A66": 'sdote',
      "\u2A6A": 'simdot',
      "\u2A6D": 'congdot',
      "\u2A6D\u0338": 'ncongdot',
      "\u2A6E": 'easter',
      "\u2A6F": 'apacir',
      "\u2A70": 'apE',
      "\u2A70\u0338": 'napE',
      "\u2A71": 'eplus',
      "\u2A72": 'pluse',
      "\u2A73": 'Esim',
      "\u2A77": 'eDDot',
      "\u2A78": 'equivDD',
      "\u2A79": 'ltcir',
      "\u2A7A": 'gtcir',
      "\u2A7B": 'ltquest',
      "\u2A7C": 'gtquest',
      "\u2A7D": 'les',
      "\u2A7D\u0338": 'nles',
      "\u2A7E": 'ges',
      "\u2A7E\u0338": 'nges',
      "\u2A7F": 'lesdot',
      "\u2A80": 'gesdot',
      "\u2A81": 'lesdoto',
      "\u2A82": 'gesdoto',
      "\u2A83": 'lesdotor',
      "\u2A84": 'gesdotol',
      "\u2A85": 'lap',
      "\u2A86": 'gap',
      "\u2A87": 'lne',
      "\u2A88": 'gne',
      "\u2A89": 'lnap',
      "\u2A8A": 'gnap',
      "\u2A8B": 'lEg',
      "\u2A8C": 'gEl',
      "\u2A8D": 'lsime',
      "\u2A8E": 'gsime',
      "\u2A8F": 'lsimg',
      "\u2A90": 'gsiml',
      "\u2A91": 'lgE',
      "\u2A92": 'glE',
      "\u2A93": 'lesges',
      "\u2A94": 'gesles',
      "\u2A95": 'els',
      "\u2A96": 'egs',
      "\u2A97": 'elsdot',
      "\u2A98": 'egsdot',
      "\u2A99": 'el',
      "\u2A9A": 'eg',
      "\u2A9D": 'siml',
      "\u2A9E": 'simg',
      "\u2A9F": 'simlE',
      "\u2AA0": 'simgE',
      "\u2AA1": 'LessLess',
      "\u2AA1\u0338": 'NotNestedLessLess',
      "\u2AA2": 'GreaterGreater',
      "\u2AA2\u0338": 'NotNestedGreaterGreater',
      "\u2AA4": 'glj',
      "\u2AA5": 'gla',
      "\u2AA6": 'ltcc',
      "\u2AA7": 'gtcc',
      "\u2AA8": 'lescc',
      "\u2AA9": 'gescc',
      "\u2AAA": 'smt',
      "\u2AAB": 'lat',
      "\u2AAC": 'smte',
      "\u2AAC\uFE00": 'smtes',
      "\u2AAD": 'late',
      "\u2AAD\uFE00": 'lates',
      "\u2AAE": 'bumpE',
      "\u2AAF": 'pre',
      "\u2AAF\u0338": 'npre',
      "\u2AB0": 'sce',
      "\u2AB0\u0338": 'nsce',
      "\u2AB3": 'prE',
      "\u2AB4": 'scE',
      "\u2AB5": 'prnE',
      "\u2AB6": 'scnE',
      "\u2AB7": 'prap',
      "\u2AB8": 'scap',
      "\u2AB9": 'prnap',
      "\u2ABA": 'scnap',
      "\u2ABB": 'Pr',
      "\u2ABC": 'Sc',
      "\u2ABD": 'subdot',
      "\u2ABE": 'supdot',
      "\u2ABF": 'subplus',
      "\u2AC0": 'supplus',
      "\u2AC1": 'submult',
      "\u2AC2": 'supmult',
      "\u2AC3": 'subedot',
      "\u2AC4": 'supedot',
      "\u2AC5": 'subE',
      "\u2AC5\u0338": 'nsubE',
      "\u2AC6": 'supE',
      "\u2AC6\u0338": 'nsupE',
      "\u2AC7": 'subsim',
      "\u2AC8": 'supsim',
      "\u2ACB\uFE00": 'vsubnE',
      "\u2ACB": 'subnE',
      "\u2ACC\uFE00": 'vsupnE',
      "\u2ACC": 'supnE',
      "\u2ACF": 'csub',
      "\u2AD0": 'csup',
      "\u2AD1": 'csube',
      "\u2AD2": 'csupe',
      "\u2AD3": 'subsup',
      "\u2AD4": 'supsub',
      "\u2AD5": 'subsub',
      "\u2AD6": 'supsup',
      "\u2AD7": 'suphsub',
      "\u2AD8": 'supdsub',
      "\u2AD9": 'forkv',
      "\u2ADA": 'topfork',
      "\u2ADB": 'mlcp',
      "\u2AE4": 'Dashv',
      "\u2AE6": 'Vdashl',
      "\u2AE7": 'Barv',
      "\u2AE8": 'vBar',
      "\u2AE9": 'vBarv',
      "\u2AEB": 'Vbar',
      "\u2AEC": 'Not',
      "\u2AED": 'bNot',
      "\u2AEE": 'rnmid',
      "\u2AEF": 'cirmid',
      "\u2AF0": 'midcir',
      "\u2AF1": 'topcir',
      "\u2AF2": 'nhpar',
      "\u2AF3": 'parsim',
      "\u2AFD": 'parsl',
      "\u2AFD\u20E5": 'nparsl',
      "\u266D": 'flat',
      "\u266E": 'natur',
      "\u266F": 'sharp',
      '\xA4': 'curren',
      '\xA2': 'cent',
      '$': 'dollar',
      '\xA3': 'pound',
      '\xA5': 'yen',
      "\u20AC": 'euro',
      '\xB9': 'sup1',
      '\xBD': 'half',
      "\u2153": 'frac13',
      '\xBC': 'frac14',
      "\u2155": 'frac15',
      "\u2159": 'frac16',
      "\u215B": 'frac18',
      '\xB2': 'sup2',
      "\u2154": 'frac23',
      "\u2156": 'frac25',
      '\xB3': 'sup3',
      '\xBE': 'frac34',
      "\u2157": 'frac35',
      "\u215C": 'frac38',
      "\u2158": 'frac45',
      "\u215A": 'frac56',
      "\u215D": 'frac58',
      "\u215E": 'frac78',
      "\uD835\uDCB6": 'ascr',
      "\uD835\uDD52": 'aopf',
      "\uD835\uDD1E": 'afr',
      "\uD835\uDD38": 'Aopf',
      "\uD835\uDD04": 'Afr',
      "\uD835\uDC9C": 'Ascr',
      '\xAA': 'ordf',
      '\xE1': 'aacute',
      '\xC1': 'Aacute',
      '\xE0': 'agrave',
      '\xC0': 'Agrave',
      "\u0103": 'abreve',
      "\u0102": 'Abreve',
      '\xE2': 'acirc',
      '\xC2': 'Acirc',
      '\xE5': 'aring',
      '\xC5': 'angst',
      '\xE4': 'auml',
      '\xC4': 'Auml',
      '\xE3': 'atilde',
      '\xC3': 'Atilde',
      "\u0105": 'aogon',
      "\u0104": 'Aogon',
      "\u0101": 'amacr',
      "\u0100": 'Amacr',
      '\xE6': 'aelig',
      '\xC6': 'AElig',
      "\uD835\uDCB7": 'bscr',
      "\uD835\uDD53": 'bopf',
      "\uD835\uDD1F": 'bfr',
      "\uD835\uDD39": 'Bopf',
      "\u212C": 'Bscr',
      "\uD835\uDD05": 'Bfr',
      "\uD835\uDD20": 'cfr',
      "\uD835\uDCB8": 'cscr',
      "\uD835\uDD54": 'copf',
      "\u212D": 'Cfr',
      "\uD835\uDC9E": 'Cscr',
      "\u2102": 'Copf',
      "\u0107": 'cacute',
      "\u0106": 'Cacute',
      "\u0109": 'ccirc',
      "\u0108": 'Ccirc',
      "\u010D": 'ccaron',
      "\u010C": 'Ccaron',
      "\u010B": 'cdot',
      "\u010A": 'Cdot',
      '\xE7': 'ccedil',
      '\xC7': 'Ccedil',
      "\u2105": 'incare',
      "\uD835\uDD21": 'dfr',
      "\u2146": 'dd',
      "\uD835\uDD55": 'dopf',
      "\uD835\uDCB9": 'dscr',
      "\uD835\uDC9F": 'Dscr',
      "\uD835\uDD07": 'Dfr',
      "\u2145": 'DD',
      "\uD835\uDD3B": 'Dopf',
      "\u010F": 'dcaron',
      "\u010E": 'Dcaron',
      "\u0111": 'dstrok',
      "\u0110": 'Dstrok',
      '\xF0': 'eth',
      '\xD0': 'ETH',
      "\u2147": 'ee',
      "\u212F": 'escr',
      "\uD835\uDD22": 'efr',
      "\uD835\uDD56": 'eopf',
      "\u2130": 'Escr',
      "\uD835\uDD08": 'Efr',
      "\uD835\uDD3C": 'Eopf',
      '\xE9': 'eacute',
      '\xC9': 'Eacute',
      '\xE8': 'egrave',
      '\xC8': 'Egrave',
      '\xEA': 'ecirc',
      '\xCA': 'Ecirc',
      "\u011B": 'ecaron',
      "\u011A": 'Ecaron',
      '\xEB': 'euml',
      '\xCB': 'Euml',
      "\u0117": 'edot',
      "\u0116": 'Edot',
      "\u0119": 'eogon',
      "\u0118": 'Eogon',
      "\u0113": 'emacr',
      "\u0112": 'Emacr',
      "\uD835\uDD23": 'ffr',
      "\uD835\uDD57": 'fopf',
      "\uD835\uDCBB": 'fscr',
      "\uD835\uDD09": 'Ffr',
      "\uD835\uDD3D": 'Fopf',
      "\u2131": 'Fscr',
      "\uFB00": 'fflig',
      "\uFB03": 'ffilig',
      "\uFB04": 'ffllig',
      "\uFB01": 'filig',
      'fj': 'fjlig',
      "\uFB02": 'fllig',
      "\u0192": 'fnof',
      "\u210A": 'gscr',
      "\uD835\uDD58": 'gopf',
      "\uD835\uDD24": 'gfr',
      "\uD835\uDCA2": 'Gscr',
      "\uD835\uDD3E": 'Gopf',
      "\uD835\uDD0A": 'Gfr',
      "\u01F5": 'gacute',
      "\u011F": 'gbreve',
      "\u011E": 'Gbreve',
      "\u011D": 'gcirc',
      "\u011C": 'Gcirc',
      "\u0121": 'gdot',
      "\u0120": 'Gdot',
      "\u0122": 'Gcedil',
      "\uD835\uDD25": 'hfr',
      "\u210E": 'planckh',
      "\uD835\uDCBD": 'hscr',
      "\uD835\uDD59": 'hopf',
      "\u210B": 'Hscr',
      "\u210C": 'Hfr',
      "\u210D": 'Hopf',
      "\u0125": 'hcirc',
      "\u0124": 'Hcirc',
      "\u210F": 'hbar',
      "\u0127": 'hstrok',
      "\u0126": 'Hstrok',
      "\uD835\uDD5A": 'iopf',
      "\uD835\uDD26": 'ifr',
      "\uD835\uDCBE": 'iscr',
      "\u2148": 'ii',
      "\uD835\uDD40": 'Iopf',
      "\u2110": 'Iscr',
      "\u2111": 'Im',
      '\xED': 'iacute',
      '\xCD': 'Iacute',
      '\xEC': 'igrave',
      '\xCC': 'Igrave',
      '\xEE': 'icirc',
      '\xCE': 'Icirc',
      '\xEF': 'iuml',
      '\xCF': 'Iuml',
      "\u0129": 'itilde',
      "\u0128": 'Itilde',
      "\u0130": 'Idot',
      "\u012F": 'iogon',
      "\u012E": 'Iogon',
      "\u012B": 'imacr',
      "\u012A": 'Imacr',
      "\u0133": 'ijlig',
      "\u0132": 'IJlig',
      "\u0131": 'imath',
      "\uD835\uDCBF": 'jscr',
      "\uD835\uDD5B": 'jopf',
      "\uD835\uDD27": 'jfr',
      "\uD835\uDCA5": 'Jscr',
      "\uD835\uDD0D": 'Jfr',
      "\uD835\uDD41": 'Jopf',
      "\u0135": 'jcirc',
      "\u0134": 'Jcirc',
      "\u0237": 'jmath',
      "\uD835\uDD5C": 'kopf',
      "\uD835\uDCC0": 'kscr',
      "\uD835\uDD28": 'kfr',
      "\uD835\uDCA6": 'Kscr',
      "\uD835\uDD42": 'Kopf',
      "\uD835\uDD0E": 'Kfr',
      "\u0137": 'kcedil',
      "\u0136": 'Kcedil',
      "\uD835\uDD29": 'lfr',
      "\uD835\uDCC1": 'lscr',
      "\u2113": 'ell',
      "\uD835\uDD5D": 'lopf',
      "\u2112": 'Lscr',
      "\uD835\uDD0F": 'Lfr',
      "\uD835\uDD43": 'Lopf',
      "\u013A": 'lacute',
      "\u0139": 'Lacute',
      "\u013E": 'lcaron',
      "\u013D": 'Lcaron',
      "\u013C": 'lcedil',
      "\u013B": 'Lcedil',
      "\u0142": 'lstrok',
      "\u0141": 'Lstrok',
      "\u0140": 'lmidot',
      "\u013F": 'Lmidot',
      "\uD835\uDD2A": 'mfr',
      "\uD835\uDD5E": 'mopf',
      "\uD835\uDCC2": 'mscr',
      "\uD835\uDD10": 'Mfr',
      "\uD835\uDD44": 'Mopf',
      "\u2133": 'Mscr',
      "\uD835\uDD2B": 'nfr',
      "\uD835\uDD5F": 'nopf',
      "\uD835\uDCC3": 'nscr',
      "\u2115": 'Nopf',
      "\uD835\uDCA9": 'Nscr',
      "\uD835\uDD11": 'Nfr',
      "\u0144": 'nacute',
      "\u0143": 'Nacute',
      "\u0148": 'ncaron',
      "\u0147": 'Ncaron',
      '\xF1': 'ntilde',
      '\xD1': 'Ntilde',
      "\u0146": 'ncedil',
      "\u0145": 'Ncedil',
      "\u2116": 'numero',
      "\u014B": 'eng',
      "\u014A": 'ENG',
      "\uD835\uDD60": 'oopf',
      "\uD835\uDD2C": 'ofr',
      "\u2134": 'oscr',
      "\uD835\uDCAA": 'Oscr',
      "\uD835\uDD12": 'Ofr',
      "\uD835\uDD46": 'Oopf',
      '\xBA': 'ordm',
      '\xF3': 'oacute',
      '\xD3': 'Oacute',
      '\xF2': 'ograve',
      '\xD2': 'Ograve',
      '\xF4': 'ocirc',
      '\xD4': 'Ocirc',
      '\xF6': 'ouml',
      '\xD6': 'Ouml',
      "\u0151": 'odblac',
      "\u0150": 'Odblac',
      '\xF5': 'otilde',
      '\xD5': 'Otilde',
      '\xF8': 'oslash',
      '\xD8': 'Oslash',
      "\u014D": 'omacr',
      "\u014C": 'Omacr',
      "\u0153": 'oelig',
      "\u0152": 'OElig',
      "\uD835\uDD2D": 'pfr',
      "\uD835\uDCC5": 'pscr',
      "\uD835\uDD61": 'popf',
      "\u2119": 'Popf',
      "\uD835\uDD13": 'Pfr',
      "\uD835\uDCAB": 'Pscr',
      "\uD835\uDD62": 'qopf',
      "\uD835\uDD2E": 'qfr',
      "\uD835\uDCC6": 'qscr',
      "\uD835\uDCAC": 'Qscr',
      "\uD835\uDD14": 'Qfr',
      "\u211A": 'Qopf',
      "\u0138": 'kgreen',
      "\uD835\uDD2F": 'rfr',
      "\uD835\uDD63": 'ropf',
      "\uD835\uDCC7": 'rscr',
      "\u211B": 'Rscr',
      "\u211C": 'Re',
      "\u211D": 'Ropf',
      "\u0155": 'racute',
      "\u0154": 'Racute',
      "\u0159": 'rcaron',
      "\u0158": 'Rcaron',
      "\u0157": 'rcedil',
      "\u0156": 'Rcedil',
      "\uD835\uDD64": 'sopf',
      "\uD835\uDCC8": 'sscr',
      "\uD835\uDD30": 'sfr',
      "\uD835\uDD4A": 'Sopf',
      "\uD835\uDD16": 'Sfr',
      "\uD835\uDCAE": 'Sscr',
      "\u24C8": 'oS',
      "\u015B": 'sacute',
      "\u015A": 'Sacute',
      "\u015D": 'scirc',
      "\u015C": 'Scirc',
      "\u0161": 'scaron',
      "\u0160": 'Scaron',
      "\u015F": 'scedil',
      "\u015E": 'Scedil',
      '\xDF': 'szlig',
      "\uD835\uDD31": 'tfr',
      "\uD835\uDCC9": 'tscr',
      "\uD835\uDD65": 'topf',
      "\uD835\uDCAF": 'Tscr',
      "\uD835\uDD17": 'Tfr',
      "\uD835\uDD4B": 'Topf',
      "\u0165": 'tcaron',
      "\u0164": 'Tcaron',
      "\u0163": 'tcedil',
      "\u0162": 'Tcedil',
      "\u2122": 'trade',
      "\u0167": 'tstrok',
      "\u0166": 'Tstrok',
      "\uD835\uDCCA": 'uscr',
      "\uD835\uDD66": 'uopf',
      "\uD835\uDD32": 'ufr',
      "\uD835\uDD4C": 'Uopf',
      "\uD835\uDD18": 'Ufr',
      "\uD835\uDCB0": 'Uscr',
      '\xFA': 'uacute',
      '\xDA': 'Uacute',
      '\xF9': 'ugrave',
      '\xD9': 'Ugrave',
      "\u016D": 'ubreve',
      "\u016C": 'Ubreve',
      '\xFB': 'ucirc',
      '\xDB': 'Ucirc',
      "\u016F": 'uring',
      "\u016E": 'Uring',
      '\xFC': 'uuml',
      '\xDC': 'Uuml',
      "\u0171": 'udblac',
      "\u0170": 'Udblac',
      "\u0169": 'utilde',
      "\u0168": 'Utilde',
      "\u0173": 'uogon',
      "\u0172": 'Uogon',
      "\u016B": 'umacr',
      "\u016A": 'Umacr',
      "\uD835\uDD33": 'vfr',
      "\uD835\uDD67": 'vopf',
      "\uD835\uDCCB": 'vscr',
      "\uD835\uDD19": 'Vfr',
      "\uD835\uDD4D": 'Vopf',
      "\uD835\uDCB1": 'Vscr',
      "\uD835\uDD68": 'wopf',
      "\uD835\uDCCC": 'wscr',
      "\uD835\uDD34": 'wfr',
      "\uD835\uDCB2": 'Wscr',
      "\uD835\uDD4E": 'Wopf',
      "\uD835\uDD1A": 'Wfr',
      "\u0175": 'wcirc',
      "\u0174": 'Wcirc',
      "\uD835\uDD35": 'xfr',
      "\uD835\uDCCD": 'xscr',
      "\uD835\uDD69": 'xopf',
      "\uD835\uDD4F": 'Xopf',
      "\uD835\uDD1B": 'Xfr',
      "\uD835\uDCB3": 'Xscr',
      "\uD835\uDD36": 'yfr',
      "\uD835\uDCCE": 'yscr',
      "\uD835\uDD6A": 'yopf',
      "\uD835\uDCB4": 'Yscr',
      "\uD835\uDD1C": 'Yfr',
      "\uD835\uDD50": 'Yopf',
      '\xFD': 'yacute',
      '\xDD': 'Yacute',
      "\u0177": 'ycirc',
      "\u0176": 'Ycirc',
      '\xFF': 'yuml',
      "\u0178": 'Yuml',
      "\uD835\uDCCF": 'zscr',
      "\uD835\uDD37": 'zfr',
      "\uD835\uDD6B": 'zopf',
      "\u2128": 'Zfr',
      "\u2124": 'Zopf',
      "\uD835\uDCB5": 'Zscr',
      "\u017A": 'zacute',
      "\u0179": 'Zacute',
      "\u017E": 'zcaron',
      "\u017D": 'Zcaron',
      "\u017C": 'zdot',
      "\u017B": 'Zdot',
      "\u01B5": 'imped',
      '\xFE': 'thorn',
      '\xDE': 'THORN',
      "\u0149": 'napos',
      "\u03B1": 'alpha',
      "\u0391": 'Alpha',
      "\u03B2": 'beta',
      "\u0392": 'Beta',
      "\u03B3": 'gamma',
      "\u0393": 'Gamma',
      "\u03B4": 'delta',
      "\u0394": 'Delta',
      "\u03B5": 'epsi',
      "\u03F5": 'epsiv',
      "\u0395": 'Epsilon',
      "\u03DD": 'gammad',
      "\u03DC": 'Gammad',
      "\u03B6": 'zeta',
      "\u0396": 'Zeta',
      "\u03B7": 'eta',
      "\u0397": 'Eta',
      "\u03B8": 'theta',
      "\u03D1": 'thetav',
      "\u0398": 'Theta',
      "\u03B9": 'iota',
      "\u0399": 'Iota',
      "\u03BA": 'kappa',
      "\u03F0": 'kappav',
      "\u039A": 'Kappa',
      "\u03BB": 'lambda',
      "\u039B": 'Lambda',
      "\u03BC": 'mu',
      '\xB5': 'micro',
      "\u039C": 'Mu',
      "\u03BD": 'nu',
      "\u039D": 'Nu',
      "\u03BE": 'xi',
      "\u039E": 'Xi',
      "\u03BF": 'omicron',
      "\u039F": 'Omicron',
      "\u03C0": 'pi',
      "\u03D6": 'piv',
      "\u03A0": 'Pi',
      "\u03C1": 'rho',
      "\u03F1": 'rhov',
      "\u03A1": 'Rho',
      "\u03C3": 'sigma',
      "\u03A3": 'Sigma',
      "\u03C2": 'sigmaf',
      "\u03C4": 'tau',
      "\u03A4": 'Tau',
      "\u03C5": 'upsi',
      "\u03A5": 'Upsilon',
      "\u03D2": 'Upsi',
      "\u03C6": 'phi',
      "\u03D5": 'phiv',
      "\u03A6": 'Phi',
      "\u03C7": 'chi',
      "\u03A7": 'Chi',
      "\u03C8": 'psi',
      "\u03A8": 'Psi',
      "\u03C9": 'omega',
      "\u03A9": 'ohm',
      "\u0430": 'acy',
      "\u0410": 'Acy',
      "\u0431": 'bcy',
      "\u0411": 'Bcy',
      "\u0432": 'vcy',
      "\u0412": 'Vcy',
      "\u0433": 'gcy',
      "\u0413": 'Gcy',
      "\u0453": 'gjcy',
      "\u0403": 'GJcy',
      "\u0434": 'dcy',
      "\u0414": 'Dcy',
      "\u0452": 'djcy',
      "\u0402": 'DJcy',
      "\u0435": 'iecy',
      "\u0415": 'IEcy',
      "\u0451": 'iocy',
      "\u0401": 'IOcy',
      "\u0454": 'jukcy',
      "\u0404": 'Jukcy',
      "\u0436": 'zhcy',
      "\u0416": 'ZHcy',
      "\u0437": 'zcy',
      "\u0417": 'Zcy',
      "\u0455": 'dscy',
      "\u0405": 'DScy',
      "\u0438": 'icy',
      "\u0418": 'Icy',
      "\u0456": 'iukcy',
      "\u0406": 'Iukcy',
      "\u0457": 'yicy',
      "\u0407": 'YIcy',
      "\u0439": 'jcy',
      "\u0419": 'Jcy',
      "\u0458": 'jsercy',
      "\u0408": 'Jsercy',
      "\u043A": 'kcy',
      "\u041A": 'Kcy',
      "\u045C": 'kjcy',
      "\u040C": 'KJcy',
      "\u043B": 'lcy',
      "\u041B": 'Lcy',
      "\u0459": 'ljcy',
      "\u0409": 'LJcy',
      "\u043C": 'mcy',
      "\u041C": 'Mcy',
      "\u043D": 'ncy',
      "\u041D": 'Ncy',
      "\u045A": 'njcy',
      "\u040A": 'NJcy',
      "\u043E": 'ocy',
      "\u041E": 'Ocy',
      "\u043F": 'pcy',
      "\u041F": 'Pcy',
      "\u0440": 'rcy',
      "\u0420": 'Rcy',
      "\u0441": 'scy',
      "\u0421": 'Scy',
      "\u0442": 'tcy',
      "\u0422": 'Tcy',
      "\u045B": 'tshcy',
      "\u040B": 'TSHcy',
      "\u0443": 'ucy',
      "\u0423": 'Ucy',
      "\u045E": 'ubrcy',
      "\u040E": 'Ubrcy',
      "\u0444": 'fcy',
      "\u0424": 'Fcy',
      "\u0445": 'khcy',
      "\u0425": 'KHcy',
      "\u0446": 'tscy',
      "\u0426": 'TScy',
      "\u0447": 'chcy',
      "\u0427": 'CHcy',
      "\u045F": 'dzcy',
      "\u040F": 'DZcy',
      "\u0448": 'shcy',
      "\u0428": 'SHcy',
      "\u0449": 'shchcy',
      "\u0429": 'SHCHcy',
      "\u044A": 'hardcy',
      "\u042A": 'HARDcy',
      "\u044B": 'ycy',
      "\u042B": 'Ycy',
      "\u044C": 'softcy',
      "\u042C": 'SOFTcy',
      "\u044D": 'ecy',
      "\u042D": 'Ecy',
      "\u044E": 'yucy',
      "\u042E": 'YUcy',
      "\u044F": 'yacy',
      "\u042F": 'YAcy',
      "\u2135": 'aleph',
      "\u2136": 'beth',
      "\u2137": 'gimel',
      "\u2138": 'daleth'
    };
    var regexEscape = /["&'<>`]/g;
    var escapeMap = {
      '"': '&quot;',
      '&': '&amp;',
      '\'': '&#x27;',
      '<': '&lt;',
      // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
      // following is not strictly necessary unless it’s part of a tag or an
      // unquoted attribute value. We’re only escaping it to support those
      // situations, and for XML support.
      '>': '&gt;',
      // In Internet Explorer ≤ 8, the backtick character can be used
      // to break out of (un)quoted attribute values or HTML comments.
      // See http://html5sec.org/#102, http://html5sec.org/#108, and
      // http://html5sec.org/#133.
      '`': '&#x60;'
    };
    var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
    var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
    var decodeMap = {
      'aacute': '\xE1',
      'Aacute': '\xC1',
      'abreve': "\u0103",
      'Abreve': "\u0102",
      'ac': "\u223E",
      'acd': "\u223F",
      'acE': "\u223E\u0333",
      'acirc': '\xE2',
      'Acirc': '\xC2',
      'acute': '\xB4',
      'acy': "\u0430",
      'Acy': "\u0410",
      'aelig': '\xE6',
      'AElig': '\xC6',
      'af': "\u2061",
      'afr': "\uD835\uDD1E",
      'Afr': "\uD835\uDD04",
      'agrave': '\xE0',
      'Agrave': '\xC0',
      'alefsym': "\u2135",
      'aleph': "\u2135",
      'alpha': "\u03B1",
      'Alpha': "\u0391",
      'amacr': "\u0101",
      'Amacr': "\u0100",
      'amalg': "\u2A3F",
      'amp': '&',
      'AMP': '&',
      'and': "\u2227",
      'And': "\u2A53",
      'andand': "\u2A55",
      'andd': "\u2A5C",
      'andslope': "\u2A58",
      'andv': "\u2A5A",
      'ang': "\u2220",
      'ange': "\u29A4",
      'angle': "\u2220",
      'angmsd': "\u2221",
      'angmsdaa': "\u29A8",
      'angmsdab': "\u29A9",
      'angmsdac': "\u29AA",
      'angmsdad': "\u29AB",
      'angmsdae': "\u29AC",
      'angmsdaf': "\u29AD",
      'angmsdag': "\u29AE",
      'angmsdah': "\u29AF",
      'angrt': "\u221F",
      'angrtvb': "\u22BE",
      'angrtvbd': "\u299D",
      'angsph': "\u2222",
      'angst': '\xC5',
      'angzarr': "\u237C",
      'aogon': "\u0105",
      'Aogon': "\u0104",
      'aopf': "\uD835\uDD52",
      'Aopf': "\uD835\uDD38",
      'ap': "\u2248",
      'apacir': "\u2A6F",
      'ape': "\u224A",
      'apE': "\u2A70",
      'apid': "\u224B",
      'apos': '\'',
      'ApplyFunction': "\u2061",
      'approx': "\u2248",
      'approxeq': "\u224A",
      'aring': '\xE5',
      'Aring': '\xC5',
      'ascr': "\uD835\uDCB6",
      'Ascr': "\uD835\uDC9C",
      'Assign': "\u2254",
      'ast': '*',
      'asymp': "\u2248",
      'asympeq': "\u224D",
      'atilde': '\xE3',
      'Atilde': '\xC3',
      'auml': '\xE4',
      'Auml': '\xC4',
      'awconint': "\u2233",
      'awint': "\u2A11",
      'backcong': "\u224C",
      'backepsilon': "\u03F6",
      'backprime': "\u2035",
      'backsim': "\u223D",
      'backsimeq': "\u22CD",
      'Backslash': "\u2216",
      'Barv': "\u2AE7",
      'barvee': "\u22BD",
      'barwed': "\u2305",
      'Barwed': "\u2306",
      'barwedge': "\u2305",
      'bbrk': "\u23B5",
      'bbrktbrk': "\u23B6",
      'bcong': "\u224C",
      'bcy': "\u0431",
      'Bcy': "\u0411",
      'bdquo': "\u201E",
      'becaus': "\u2235",
      'because': "\u2235",
      'Because': "\u2235",
      'bemptyv': "\u29B0",
      'bepsi': "\u03F6",
      'bernou': "\u212C",
      'Bernoullis': "\u212C",
      'beta': "\u03B2",
      'Beta': "\u0392",
      'beth': "\u2136",
      'between': "\u226C",
      'bfr': "\uD835\uDD1F",
      'Bfr': "\uD835\uDD05",
      'bigcap': "\u22C2",
      'bigcirc': "\u25EF",
      'bigcup': "\u22C3",
      'bigodot': "\u2A00",
      'bigoplus': "\u2A01",
      'bigotimes': "\u2A02",
      'bigsqcup': "\u2A06",
      'bigstar': "\u2605",
      'bigtriangledown': "\u25BD",
      'bigtriangleup': "\u25B3",
      'biguplus': "\u2A04",
      'bigvee': "\u22C1",
      'bigwedge': "\u22C0",
      'bkarow': "\u290D",
      'blacklozenge': "\u29EB",
      'blacksquare': "\u25AA",
      'blacktriangle': "\u25B4",
      'blacktriangledown': "\u25BE",
      'blacktriangleleft': "\u25C2",
      'blacktriangleright': "\u25B8",
      'blank': "\u2423",
      'blk12': "\u2592",
      'blk14': "\u2591",
      'blk34': "\u2593",
      'block': "\u2588",
      'bne': "=\u20E5",
      'bnequiv': "\u2261\u20E5",
      'bnot': "\u2310",
      'bNot': "\u2AED",
      'bopf': "\uD835\uDD53",
      'Bopf': "\uD835\uDD39",
      'bot': "\u22A5",
      'bottom': "\u22A5",
      'bowtie': "\u22C8",
      'boxbox': "\u29C9",
      'boxdl': "\u2510",
      'boxdL': "\u2555",
      'boxDl': "\u2556",
      'boxDL': "\u2557",
      'boxdr': "\u250C",
      'boxdR': "\u2552",
      'boxDr': "\u2553",
      'boxDR': "\u2554",
      'boxh': "\u2500",
      'boxH': "\u2550",
      'boxhd': "\u252C",
      'boxhD': "\u2565",
      'boxHd': "\u2564",
      'boxHD': "\u2566",
      'boxhu': "\u2534",
      'boxhU': "\u2568",
      'boxHu': "\u2567",
      'boxHU': "\u2569",
      'boxminus': "\u229F",
      'boxplus': "\u229E",
      'boxtimes': "\u22A0",
      'boxul': "\u2518",
      'boxuL': "\u255B",
      'boxUl': "\u255C",
      'boxUL': "\u255D",
      'boxur': "\u2514",
      'boxuR': "\u2558",
      'boxUr': "\u2559",
      'boxUR': "\u255A",
      'boxv': "\u2502",
      'boxV': "\u2551",
      'boxvh': "\u253C",
      'boxvH': "\u256A",
      'boxVh': "\u256B",
      'boxVH': "\u256C",
      'boxvl': "\u2524",
      'boxvL': "\u2561",
      'boxVl': "\u2562",
      'boxVL': "\u2563",
      'boxvr': "\u251C",
      'boxvR': "\u255E",
      'boxVr': "\u255F",
      'boxVR': "\u2560",
      'bprime': "\u2035",
      'breve': "\u02D8",
      'Breve': "\u02D8",
      'brvbar': '\xA6',
      'bscr': "\uD835\uDCB7",
      'Bscr': "\u212C",
      'bsemi': "\u204F",
      'bsim': "\u223D",
      'bsime': "\u22CD",
      'bsol': '\\',
      'bsolb': "\u29C5",
      'bsolhsub': "\u27C8",
      'bull': "\u2022",
      'bullet': "\u2022",
      'bump': "\u224E",
      'bumpe': "\u224F",
      'bumpE': "\u2AAE",
      'bumpeq': "\u224F",
      'Bumpeq': "\u224E",
      'cacute': "\u0107",
      'Cacute': "\u0106",
      'cap': "\u2229",
      'Cap': "\u22D2",
      'capand': "\u2A44",
      'capbrcup': "\u2A49",
      'capcap': "\u2A4B",
      'capcup': "\u2A47",
      'capdot': "\u2A40",
      'CapitalDifferentialD': "\u2145",
      'caps': "\u2229\uFE00",
      'caret': "\u2041",
      'caron': "\u02C7",
      'Cayleys': "\u212D",
      'ccaps': "\u2A4D",
      'ccaron': "\u010D",
      'Ccaron': "\u010C",
      'ccedil': '\xE7',
      'Ccedil': '\xC7',
      'ccirc': "\u0109",
      'Ccirc': "\u0108",
      'Cconint': "\u2230",
      'ccups': "\u2A4C",
      'ccupssm': "\u2A50",
      'cdot': "\u010B",
      'Cdot': "\u010A",
      'cedil': '\xB8',
      'Cedilla': '\xB8',
      'cemptyv': "\u29B2",
      'cent': '\xA2',
      'centerdot': '\xB7',
      'CenterDot': '\xB7',
      'cfr': "\uD835\uDD20",
      'Cfr': "\u212D",
      'chcy': "\u0447",
      'CHcy': "\u0427",
      'check': "\u2713",
      'checkmark': "\u2713",
      'chi': "\u03C7",
      'Chi': "\u03A7",
      'cir': "\u25CB",
      'circ': "\u02C6",
      'circeq': "\u2257",
      'circlearrowleft': "\u21BA",
      'circlearrowright': "\u21BB",
      'circledast': "\u229B",
      'circledcirc': "\u229A",
      'circleddash': "\u229D",
      'CircleDot': "\u2299",
      'circledR': '\xAE',
      'circledS': "\u24C8",
      'CircleMinus': "\u2296",
      'CirclePlus': "\u2295",
      'CircleTimes': "\u2297",
      'cire': "\u2257",
      'cirE': "\u29C3",
      'cirfnint': "\u2A10",
      'cirmid': "\u2AEF",
      'cirscir': "\u29C2",
      'ClockwiseContourIntegral': "\u2232",
      'CloseCurlyDoubleQuote': "\u201D",
      'CloseCurlyQuote': "\u2019",
      'clubs': "\u2663",
      'clubsuit': "\u2663",
      'colon': ':',
      'Colon': "\u2237",
      'colone': "\u2254",
      'Colone': "\u2A74",
      'coloneq': "\u2254",
      'comma': ',',
      'commat': '@',
      'comp': "\u2201",
      'compfn': "\u2218",
      'complement': "\u2201",
      'complexes': "\u2102",
      'cong': "\u2245",
      'congdot': "\u2A6D",
      'Congruent': "\u2261",
      'conint': "\u222E",
      'Conint': "\u222F",
      'ContourIntegral': "\u222E",
      'copf': "\uD835\uDD54",
      'Copf': "\u2102",
      'coprod': "\u2210",
      'Coproduct': "\u2210",
      'copy': '\xA9',
      'COPY': '\xA9',
      'copysr': "\u2117",
      'CounterClockwiseContourIntegral': "\u2233",
      'crarr': "\u21B5",
      'cross': "\u2717",
      'Cross': "\u2A2F",
      'cscr': "\uD835\uDCB8",
      'Cscr': "\uD835\uDC9E",
      'csub': "\u2ACF",
      'csube': "\u2AD1",
      'csup': "\u2AD0",
      'csupe': "\u2AD2",
      'ctdot': "\u22EF",
      'cudarrl': "\u2938",
      'cudarrr': "\u2935",
      'cuepr': "\u22DE",
      'cuesc': "\u22DF",
      'cularr': "\u21B6",
      'cularrp': "\u293D",
      'cup': "\u222A",
      'Cup': "\u22D3",
      'cupbrcap': "\u2A48",
      'cupcap': "\u2A46",
      'CupCap': "\u224D",
      'cupcup': "\u2A4A",
      'cupdot': "\u228D",
      'cupor': "\u2A45",
      'cups': "\u222A\uFE00",
      'curarr': "\u21B7",
      'curarrm': "\u293C",
      'curlyeqprec': "\u22DE",
      'curlyeqsucc': "\u22DF",
      'curlyvee': "\u22CE",
      'curlywedge': "\u22CF",
      'curren': '\xA4',
      'curvearrowleft': "\u21B6",
      'curvearrowright': "\u21B7",
      'cuvee': "\u22CE",
      'cuwed': "\u22CF",
      'cwconint': "\u2232",
      'cwint': "\u2231",
      'cylcty': "\u232D",
      'dagger': "\u2020",
      'Dagger': "\u2021",
      'daleth': "\u2138",
      'darr': "\u2193",
      'dArr': "\u21D3",
      'Darr': "\u21A1",
      'dash': "\u2010",
      'dashv': "\u22A3",
      'Dashv': "\u2AE4",
      'dbkarow': "\u290F",
      'dblac': "\u02DD",
      'dcaron': "\u010F",
      'Dcaron': "\u010E",
      'dcy': "\u0434",
      'Dcy': "\u0414",
      'dd': "\u2146",
      'DD': "\u2145",
      'ddagger': "\u2021",
      'ddarr': "\u21CA",
      'DDotrahd': "\u2911",
      'ddotseq': "\u2A77",
      'deg': '\xB0',
      'Del': "\u2207",
      'delta': "\u03B4",
      'Delta': "\u0394",
      'demptyv': "\u29B1",
      'dfisht': "\u297F",
      'dfr': "\uD835\uDD21",
      'Dfr': "\uD835\uDD07",
      'dHar': "\u2965",
      'dharl': "\u21C3",
      'dharr': "\u21C2",
      'DiacriticalAcute': '\xB4',
      'DiacriticalDot': "\u02D9",
      'DiacriticalDoubleAcute': "\u02DD",
      'DiacriticalGrave': '`',
      'DiacriticalTilde': "\u02DC",
      'diam': "\u22C4",
      'diamond': "\u22C4",
      'Diamond': "\u22C4",
      'diamondsuit': "\u2666",
      'diams': "\u2666",
      'die': '\xA8',
      'DifferentialD': "\u2146",
      'digamma': "\u03DD",
      'disin': "\u22F2",
      'div': '\xF7',
      'divide': '\xF7',
      'divideontimes': "\u22C7",
      'divonx': "\u22C7",
      'djcy': "\u0452",
      'DJcy': "\u0402",
      'dlcorn': "\u231E",
      'dlcrop': "\u230D",
      'dollar': '$',
      'dopf': "\uD835\uDD55",
      'Dopf': "\uD835\uDD3B",
      'dot': "\u02D9",
      'Dot': '\xA8',
      'DotDot': "\u20DC",
      'doteq': "\u2250",
      'doteqdot': "\u2251",
      'DotEqual': "\u2250",
      'dotminus': "\u2238",
      'dotplus': "\u2214",
      'dotsquare': "\u22A1",
      'doublebarwedge': "\u2306",
      'DoubleContourIntegral': "\u222F",
      'DoubleDot': '\xA8',
      'DoubleDownArrow': "\u21D3",
      'DoubleLeftArrow': "\u21D0",
      'DoubleLeftRightArrow': "\u21D4",
      'DoubleLeftTee': "\u2AE4",
      'DoubleLongLeftArrow': "\u27F8",
      'DoubleLongLeftRightArrow': "\u27FA",
      'DoubleLongRightArrow': "\u27F9",
      'DoubleRightArrow': "\u21D2",
      'DoubleRightTee': "\u22A8",
      'DoubleUpArrow': "\u21D1",
      'DoubleUpDownArrow': "\u21D5",
      'DoubleVerticalBar': "\u2225",
      'downarrow': "\u2193",
      'Downarrow': "\u21D3",
      'DownArrow': "\u2193",
      'DownArrowBar': "\u2913",
      'DownArrowUpArrow': "\u21F5",
      'DownBreve': "\u0311",
      'downdownarrows': "\u21CA",
      'downharpoonleft': "\u21C3",
      'downharpoonright': "\u21C2",
      'DownLeftRightVector': "\u2950",
      'DownLeftTeeVector': "\u295E",
      'DownLeftVector': "\u21BD",
      'DownLeftVectorBar': "\u2956",
      'DownRightTeeVector': "\u295F",
      'DownRightVector': "\u21C1",
      'DownRightVectorBar': "\u2957",
      'DownTee': "\u22A4",
      'DownTeeArrow': "\u21A7",
      'drbkarow': "\u2910",
      'drcorn': "\u231F",
      'drcrop': "\u230C",
      'dscr': "\uD835\uDCB9",
      'Dscr': "\uD835\uDC9F",
      'dscy': "\u0455",
      'DScy': "\u0405",
      'dsol': "\u29F6",
      'dstrok': "\u0111",
      'Dstrok': "\u0110",
      'dtdot': "\u22F1",
      'dtri': "\u25BF",
      'dtrif': "\u25BE",
      'duarr': "\u21F5",
      'duhar': "\u296F",
      'dwangle': "\u29A6",
      'dzcy': "\u045F",
      'DZcy': "\u040F",
      'dzigrarr': "\u27FF",
      'eacute': '\xE9',
      'Eacute': '\xC9',
      'easter': "\u2A6E",
      'ecaron': "\u011B",
      'Ecaron': "\u011A",
      'ecir': "\u2256",
      'ecirc': '\xEA',
      'Ecirc': '\xCA',
      'ecolon': "\u2255",
      'ecy': "\u044D",
      'Ecy': "\u042D",
      'eDDot': "\u2A77",
      'edot': "\u0117",
      'eDot': "\u2251",
      'Edot': "\u0116",
      'ee': "\u2147",
      'efDot': "\u2252",
      'efr': "\uD835\uDD22",
      'Efr': "\uD835\uDD08",
      'eg': "\u2A9A",
      'egrave': '\xE8',
      'Egrave': '\xC8',
      'egs': "\u2A96",
      'egsdot': "\u2A98",
      'el': "\u2A99",
      'Element': "\u2208",
      'elinters': "\u23E7",
      'ell': "\u2113",
      'els': "\u2A95",
      'elsdot': "\u2A97",
      'emacr': "\u0113",
      'Emacr': "\u0112",
      'empty': "\u2205",
      'emptyset': "\u2205",
      'EmptySmallSquare': "\u25FB",
      'emptyv': "\u2205",
      'EmptyVerySmallSquare': "\u25AB",
      'emsp': "\u2003",
      'emsp13': "\u2004",
      'emsp14': "\u2005",
      'eng': "\u014B",
      'ENG': "\u014A",
      'ensp': "\u2002",
      'eogon': "\u0119",
      'Eogon': "\u0118",
      'eopf': "\uD835\uDD56",
      'Eopf': "\uD835\uDD3C",
      'epar': "\u22D5",
      'eparsl': "\u29E3",
      'eplus': "\u2A71",
      'epsi': "\u03B5",
      'epsilon': "\u03B5",
      'Epsilon': "\u0395",
      'epsiv': "\u03F5",
      'eqcirc': "\u2256",
      'eqcolon': "\u2255",
      'eqsim': "\u2242",
      'eqslantgtr': "\u2A96",
      'eqslantless': "\u2A95",
      'Equal': "\u2A75",
      'equals': '=',
      'EqualTilde': "\u2242",
      'equest': "\u225F",
      'Equilibrium': "\u21CC",
      'equiv': "\u2261",
      'equivDD': "\u2A78",
      'eqvparsl': "\u29E5",
      'erarr': "\u2971",
      'erDot': "\u2253",
      'escr': "\u212F",
      'Escr': "\u2130",
      'esdot': "\u2250",
      'esim': "\u2242",
      'Esim': "\u2A73",
      'eta': "\u03B7",
      'Eta': "\u0397",
      'eth': '\xF0',
      'ETH': '\xD0',
      'euml': '\xEB',
      'Euml': '\xCB',
      'euro': "\u20AC",
      'excl': '!',
      'exist': "\u2203",
      'Exists': "\u2203",
      'expectation': "\u2130",
      'exponentiale': "\u2147",
      'ExponentialE': "\u2147",
      'fallingdotseq': "\u2252",
      'fcy': "\u0444",
      'Fcy': "\u0424",
      'female': "\u2640",
      'ffilig': "\uFB03",
      'fflig': "\uFB00",
      'ffllig': "\uFB04",
      'ffr': "\uD835\uDD23",
      'Ffr': "\uD835\uDD09",
      'filig': "\uFB01",
      'FilledSmallSquare': "\u25FC",
      'FilledVerySmallSquare': "\u25AA",
      'fjlig': 'fj',
      'flat': "\u266D",
      'fllig': "\uFB02",
      'fltns': "\u25B1",
      'fnof': "\u0192",
      'fopf': "\uD835\uDD57",
      'Fopf': "\uD835\uDD3D",
      'forall': "\u2200",
      'ForAll': "\u2200",
      'fork': "\u22D4",
      'forkv': "\u2AD9",
      'Fouriertrf': "\u2131",
      'fpartint': "\u2A0D",
      'frac12': '\xBD',
      'frac13': "\u2153",
      'frac14': '\xBC',
      'frac15': "\u2155",
      'frac16': "\u2159",
      'frac18': "\u215B",
      'frac23': "\u2154",
      'frac25': "\u2156",
      'frac34': '\xBE',
      'frac35': "\u2157",
      'frac38': "\u215C",
      'frac45': "\u2158",
      'frac56': "\u215A",
      'frac58': "\u215D",
      'frac78': "\u215E",
      'frasl': "\u2044",
      'frown': "\u2322",
      'fscr': "\uD835\uDCBB",
      'Fscr': "\u2131",
      'gacute': "\u01F5",
      'gamma': "\u03B3",
      'Gamma': "\u0393",
      'gammad': "\u03DD",
      'Gammad': "\u03DC",
      'gap': "\u2A86",
      'gbreve': "\u011F",
      'Gbreve': "\u011E",
      'Gcedil': "\u0122",
      'gcirc': "\u011D",
      'Gcirc': "\u011C",
      'gcy': "\u0433",
      'Gcy': "\u0413",
      'gdot': "\u0121",
      'Gdot': "\u0120",
      'ge': "\u2265",
      'gE': "\u2267",
      'gel': "\u22DB",
      'gEl': "\u2A8C",
      'geq': "\u2265",
      'geqq': "\u2267",
      'geqslant': "\u2A7E",
      'ges': "\u2A7E",
      'gescc': "\u2AA9",
      'gesdot': "\u2A80",
      'gesdoto': "\u2A82",
      'gesdotol': "\u2A84",
      'gesl': "\u22DB\uFE00",
      'gesles': "\u2A94",
      'gfr': "\uD835\uDD24",
      'Gfr': "\uD835\uDD0A",
      'gg': "\u226B",
      'Gg': "\u22D9",
      'ggg': "\u22D9",
      'gimel': "\u2137",
      'gjcy': "\u0453",
      'GJcy': "\u0403",
      'gl': "\u2277",
      'gla': "\u2AA5",
      'glE': "\u2A92",
      'glj': "\u2AA4",
      'gnap': "\u2A8A",
      'gnapprox': "\u2A8A",
      'gne': "\u2A88",
      'gnE': "\u2269",
      'gneq': "\u2A88",
      'gneqq': "\u2269",
      'gnsim': "\u22E7",
      'gopf': "\uD835\uDD58",
      'Gopf': "\uD835\uDD3E",
      'grave': '`',
      'GreaterEqual': "\u2265",
      'GreaterEqualLess': "\u22DB",
      'GreaterFullEqual': "\u2267",
      'GreaterGreater': "\u2AA2",
      'GreaterLess': "\u2277",
      'GreaterSlantEqual': "\u2A7E",
      'GreaterTilde': "\u2273",
      'gscr': "\u210A",
      'Gscr': "\uD835\uDCA2",
      'gsim': "\u2273",
      'gsime': "\u2A8E",
      'gsiml': "\u2A90",
      'gt': '>',
      'Gt': "\u226B",
      'GT': '>',
      'gtcc': "\u2AA7",
      'gtcir': "\u2A7A",
      'gtdot': "\u22D7",
      'gtlPar': "\u2995",
      'gtquest': "\u2A7C",
      'gtrapprox': "\u2A86",
      'gtrarr': "\u2978",
      'gtrdot': "\u22D7",
      'gtreqless': "\u22DB",
      'gtreqqless': "\u2A8C",
      'gtrless': "\u2277",
      'gtrsim': "\u2273",
      'gvertneqq': "\u2269\uFE00",
      'gvnE': "\u2269\uFE00",
      'Hacek': "\u02C7",
      'hairsp': "\u200A",
      'half': '\xBD',
      'hamilt': "\u210B",
      'hardcy': "\u044A",
      'HARDcy': "\u042A",
      'harr': "\u2194",
      'hArr': "\u21D4",
      'harrcir': "\u2948",
      'harrw': "\u21AD",
      'Hat': '^',
      'hbar': "\u210F",
      'hcirc': "\u0125",
      'Hcirc': "\u0124",
      'hearts': "\u2665",
      'heartsuit': "\u2665",
      'hellip': "\u2026",
      'hercon': "\u22B9",
      'hfr': "\uD835\uDD25",
      'Hfr': "\u210C",
      'HilbertSpace': "\u210B",
      'hksearow': "\u2925",
      'hkswarow': "\u2926",
      'hoarr': "\u21FF",
      'homtht': "\u223B",
      'hookleftarrow': "\u21A9",
      'hookrightarrow': "\u21AA",
      'hopf': "\uD835\uDD59",
      'Hopf': "\u210D",
      'horbar': "\u2015",
      'HorizontalLine': "\u2500",
      'hscr': "\uD835\uDCBD",
      'Hscr': "\u210B",
      'hslash': "\u210F",
      'hstrok': "\u0127",
      'Hstrok': "\u0126",
      'HumpDownHump': "\u224E",
      'HumpEqual': "\u224F",
      'hybull': "\u2043",
      'hyphen': "\u2010",
      'iacute': '\xED',
      'Iacute': '\xCD',
      'ic': "\u2063",
      'icirc': '\xEE',
      'Icirc': '\xCE',
      'icy': "\u0438",
      'Icy': "\u0418",
      'Idot': "\u0130",
      'iecy': "\u0435",
      'IEcy': "\u0415",
      'iexcl': '\xA1',
      'iff': "\u21D4",
      'ifr': "\uD835\uDD26",
      'Ifr': "\u2111",
      'igrave': '\xEC',
      'Igrave': '\xCC',
      'ii': "\u2148",
      'iiiint': "\u2A0C",
      'iiint': "\u222D",
      'iinfin': "\u29DC",
      'iiota': "\u2129",
      'ijlig': "\u0133",
      'IJlig': "\u0132",
      'Im': "\u2111",
      'imacr': "\u012B",
      'Imacr': "\u012A",
      'image': "\u2111",
      'ImaginaryI': "\u2148",
      'imagline': "\u2110",
      'imagpart': "\u2111",
      'imath': "\u0131",
      'imof': "\u22B7",
      'imped': "\u01B5",
      'Implies': "\u21D2",
      'in': "\u2208",
      'incare': "\u2105",
      'infin': "\u221E",
      'infintie': "\u29DD",
      'inodot': "\u0131",
      'int': "\u222B",
      'Int': "\u222C",
      'intcal': "\u22BA",
      'integers': "\u2124",
      'Integral': "\u222B",
      'intercal': "\u22BA",
      'Intersection': "\u22C2",
      'intlarhk': "\u2A17",
      'intprod': "\u2A3C",
      'InvisibleComma': "\u2063",
      'InvisibleTimes': "\u2062",
      'iocy': "\u0451",
      'IOcy': "\u0401",
      'iogon': "\u012F",
      'Iogon': "\u012E",
      'iopf': "\uD835\uDD5A",
      'Iopf': "\uD835\uDD40",
      'iota': "\u03B9",
      'Iota': "\u0399",
      'iprod': "\u2A3C",
      'iquest': '\xBF',
      'iscr': "\uD835\uDCBE",
      'Iscr': "\u2110",
      'isin': "\u2208",
      'isindot': "\u22F5",
      'isinE': "\u22F9",
      'isins': "\u22F4",
      'isinsv': "\u22F3",
      'isinv': "\u2208",
      'it': "\u2062",
      'itilde': "\u0129",
      'Itilde': "\u0128",
      'iukcy': "\u0456",
      'Iukcy': "\u0406",
      'iuml': '\xEF',
      'Iuml': '\xCF',
      'jcirc': "\u0135",
      'Jcirc': "\u0134",
      'jcy': "\u0439",
      'Jcy': "\u0419",
      'jfr': "\uD835\uDD27",
      'Jfr': "\uD835\uDD0D",
      'jmath': "\u0237",
      'jopf': "\uD835\uDD5B",
      'Jopf': "\uD835\uDD41",
      'jscr': "\uD835\uDCBF",
      'Jscr': "\uD835\uDCA5",
      'jsercy': "\u0458",
      'Jsercy': "\u0408",
      'jukcy': "\u0454",
      'Jukcy': "\u0404",
      'kappa': "\u03BA",
      'Kappa': "\u039A",
      'kappav': "\u03F0",
      'kcedil': "\u0137",
      'Kcedil': "\u0136",
      'kcy': "\u043A",
      'Kcy': "\u041A",
      'kfr': "\uD835\uDD28",
      'Kfr': "\uD835\uDD0E",
      'kgreen': "\u0138",
      'khcy': "\u0445",
      'KHcy': "\u0425",
      'kjcy': "\u045C",
      'KJcy': "\u040C",
      'kopf': "\uD835\uDD5C",
      'Kopf': "\uD835\uDD42",
      'kscr': "\uD835\uDCC0",
      'Kscr': "\uD835\uDCA6",
      'lAarr': "\u21DA",
      'lacute': "\u013A",
      'Lacute': "\u0139",
      'laemptyv': "\u29B4",
      'lagran': "\u2112",
      'lambda': "\u03BB",
      'Lambda': "\u039B",
      'lang': "\u27E8",
      'Lang': "\u27EA",
      'langd': "\u2991",
      'langle': "\u27E8",
      'lap': "\u2A85",
      'Laplacetrf': "\u2112",
      'laquo': '\xAB',
      'larr': "\u2190",
      'lArr': "\u21D0",
      'Larr': "\u219E",
      'larrb': "\u21E4",
      'larrbfs': "\u291F",
      'larrfs': "\u291D",
      'larrhk': "\u21A9",
      'larrlp': "\u21AB",
      'larrpl': "\u2939",
      'larrsim': "\u2973",
      'larrtl': "\u21A2",
      'lat': "\u2AAB",
      'latail': "\u2919",
      'lAtail': "\u291B",
      'late': "\u2AAD",
      'lates': "\u2AAD\uFE00",
      'lbarr': "\u290C",
      'lBarr': "\u290E",
      'lbbrk': "\u2772",
      'lbrace': '{',
      'lbrack': '[',
      'lbrke': "\u298B",
      'lbrksld': "\u298F",
      'lbrkslu': "\u298D",
      'lcaron': "\u013E",
      'Lcaron': "\u013D",
      'lcedil': "\u013C",
      'Lcedil': "\u013B",
      'lceil': "\u2308",
      'lcub': '{',
      'lcy': "\u043B",
      'Lcy': "\u041B",
      'ldca': "\u2936",
      'ldquo': "\u201C",
      'ldquor': "\u201E",
      'ldrdhar': "\u2967",
      'ldrushar': "\u294B",
      'ldsh': "\u21B2",
      'le': "\u2264",
      'lE': "\u2266",
      'LeftAngleBracket': "\u27E8",
      'leftarrow': "\u2190",
      'Leftarrow': "\u21D0",
      'LeftArrow': "\u2190",
      'LeftArrowBar': "\u21E4",
      'LeftArrowRightArrow': "\u21C6",
      'leftarrowtail': "\u21A2",
      'LeftCeiling': "\u2308",
      'LeftDoubleBracket': "\u27E6",
      'LeftDownTeeVector': "\u2961",
      'LeftDownVector': "\u21C3",
      'LeftDownVectorBar': "\u2959",
      'LeftFloor': "\u230A",
      'leftharpoondown': "\u21BD",
      'leftharpoonup': "\u21BC",
      'leftleftarrows': "\u21C7",
      'leftrightarrow': "\u2194",
      'Leftrightarrow': "\u21D4",
      'LeftRightArrow': "\u2194",
      'leftrightarrows': "\u21C6",
      'leftrightharpoons': "\u21CB",
      'leftrightsquigarrow': "\u21AD",
      'LeftRightVector': "\u294E",
      'LeftTee': "\u22A3",
      'LeftTeeArrow': "\u21A4",
      'LeftTeeVector': "\u295A",
      'leftthreetimes': "\u22CB",
      'LeftTriangle': "\u22B2",
      'LeftTriangleBar': "\u29CF",
      'LeftTriangleEqual': "\u22B4",
      'LeftUpDownVector': "\u2951",
      'LeftUpTeeVector': "\u2960",
      'LeftUpVector': "\u21BF",
      'LeftUpVectorBar': "\u2958",
      'LeftVector': "\u21BC",
      'LeftVectorBar': "\u2952",
      'leg': "\u22DA",
      'lEg': "\u2A8B",
      'leq': "\u2264",
      'leqq': "\u2266",
      'leqslant': "\u2A7D",
      'les': "\u2A7D",
      'lescc': "\u2AA8",
      'lesdot': "\u2A7F",
      'lesdoto': "\u2A81",
      'lesdotor': "\u2A83",
      'lesg': "\u22DA\uFE00",
      'lesges': "\u2A93",
      'lessapprox': "\u2A85",
      'lessdot': "\u22D6",
      'lesseqgtr': "\u22DA",
      'lesseqqgtr': "\u2A8B",
      'LessEqualGreater': "\u22DA",
      'LessFullEqual': "\u2266",
      'LessGreater': "\u2276",
      'lessgtr': "\u2276",
      'LessLess': "\u2AA1",
      'lesssim': "\u2272",
      'LessSlantEqual': "\u2A7D",
      'LessTilde': "\u2272",
      'lfisht': "\u297C",
      'lfloor': "\u230A",
      'lfr': "\uD835\uDD29",
      'Lfr': "\uD835\uDD0F",
      'lg': "\u2276",
      'lgE': "\u2A91",
      'lHar': "\u2962",
      'lhard': "\u21BD",
      'lharu': "\u21BC",
      'lharul': "\u296A",
      'lhblk': "\u2584",
      'ljcy': "\u0459",
      'LJcy': "\u0409",
      'll': "\u226A",
      'Ll': "\u22D8",
      'llarr': "\u21C7",
      'llcorner': "\u231E",
      'Lleftarrow': "\u21DA",
      'llhard': "\u296B",
      'lltri': "\u25FA",
      'lmidot': "\u0140",
      'Lmidot': "\u013F",
      'lmoust': "\u23B0",
      'lmoustache': "\u23B0",
      'lnap': "\u2A89",
      'lnapprox': "\u2A89",
      'lne': "\u2A87",
      'lnE': "\u2268",
      'lneq': "\u2A87",
      'lneqq': "\u2268",
      'lnsim': "\u22E6",
      'loang': "\u27EC",
      'loarr': "\u21FD",
      'lobrk': "\u27E6",
      'longleftarrow': "\u27F5",
      'Longleftarrow': "\u27F8",
      'LongLeftArrow': "\u27F5",
      'longleftrightarrow': "\u27F7",
      'Longleftrightarrow': "\u27FA",
      'LongLeftRightArrow': "\u27F7",
      'longmapsto': "\u27FC",
      'longrightarrow': "\u27F6",
      'Longrightarrow': "\u27F9",
      'LongRightArrow': "\u27F6",
      'looparrowleft': "\u21AB",
      'looparrowright': "\u21AC",
      'lopar': "\u2985",
      'lopf': "\uD835\uDD5D",
      'Lopf': "\uD835\uDD43",
      'loplus': "\u2A2D",
      'lotimes': "\u2A34",
      'lowast': "\u2217",
      'lowbar': '_',
      'LowerLeftArrow': "\u2199",
      'LowerRightArrow': "\u2198",
      'loz': "\u25CA",
      'lozenge': "\u25CA",
      'lozf': "\u29EB",
      'lpar': '(',
      'lparlt': "\u2993",
      'lrarr': "\u21C6",
      'lrcorner': "\u231F",
      'lrhar': "\u21CB",
      'lrhard': "\u296D",
      'lrm': "\u200E",
      'lrtri': "\u22BF",
      'lsaquo': "\u2039",
      'lscr': "\uD835\uDCC1",
      'Lscr': "\u2112",
      'lsh': "\u21B0",
      'Lsh': "\u21B0",
      'lsim': "\u2272",
      'lsime': "\u2A8D",
      'lsimg': "\u2A8F",
      'lsqb': '[',
      'lsquo': "\u2018",
      'lsquor': "\u201A",
      'lstrok': "\u0142",
      'Lstrok': "\u0141",
      'lt': '<',
      'Lt': "\u226A",
      'LT': '<',
      'ltcc': "\u2AA6",
      'ltcir': "\u2A79",
      'ltdot': "\u22D6",
      'lthree': "\u22CB",
      'ltimes': "\u22C9",
      'ltlarr': "\u2976",
      'ltquest': "\u2A7B",
      'ltri': "\u25C3",
      'ltrie': "\u22B4",
      'ltrif': "\u25C2",
      'ltrPar': "\u2996",
      'lurdshar': "\u294A",
      'luruhar': "\u2966",
      'lvertneqq': "\u2268\uFE00",
      'lvnE': "\u2268\uFE00",
      'macr': '\xAF',
      'male': "\u2642",
      'malt': "\u2720",
      'maltese': "\u2720",
      'map': "\u21A6",
      'Map': "\u2905",
      'mapsto': "\u21A6",
      'mapstodown': "\u21A7",
      'mapstoleft': "\u21A4",
      'mapstoup': "\u21A5",
      'marker': "\u25AE",
      'mcomma': "\u2A29",
      'mcy': "\u043C",
      'Mcy': "\u041C",
      'mdash': "\u2014",
      'mDDot': "\u223A",
      'measuredangle': "\u2221",
      'MediumSpace': "\u205F",
      'Mellintrf': "\u2133",
      'mfr': "\uD835\uDD2A",
      'Mfr': "\uD835\uDD10",
      'mho': "\u2127",
      'micro': '\xB5',
      'mid': "\u2223",
      'midast': '*',
      'midcir': "\u2AF0",
      'middot': '\xB7',
      'minus': "\u2212",
      'minusb': "\u229F",
      'minusd': "\u2238",
      'minusdu': "\u2A2A",
      'MinusPlus': "\u2213",
      'mlcp': "\u2ADB",
      'mldr': "\u2026",
      'mnplus': "\u2213",
      'models': "\u22A7",
      'mopf': "\uD835\uDD5E",
      'Mopf': "\uD835\uDD44",
      'mp': "\u2213",
      'mscr': "\uD835\uDCC2",
      'Mscr': "\u2133",
      'mstpos': "\u223E",
      'mu': "\u03BC",
      'Mu': "\u039C",
      'multimap': "\u22B8",
      'mumap': "\u22B8",
      'nabla': "\u2207",
      'nacute': "\u0144",
      'Nacute': "\u0143",
      'nang': "\u2220\u20D2",
      'nap': "\u2249",
      'napE': "\u2A70\u0338",
      'napid': "\u224B\u0338",
      'napos': "\u0149",
      'napprox': "\u2249",
      'natur': "\u266E",
      'natural': "\u266E",
      'naturals': "\u2115",
      'nbsp': '\xA0',
      'nbump': "\u224E\u0338",
      'nbumpe': "\u224F\u0338",
      'ncap': "\u2A43",
      'ncaron': "\u0148",
      'Ncaron': "\u0147",
      'ncedil': "\u0146",
      'Ncedil': "\u0145",
      'ncong': "\u2247",
      'ncongdot': "\u2A6D\u0338",
      'ncup': "\u2A42",
      'ncy': "\u043D",
      'Ncy': "\u041D",
      'ndash': "\u2013",
      'ne': "\u2260",
      'nearhk': "\u2924",
      'nearr': "\u2197",
      'neArr': "\u21D7",
      'nearrow': "\u2197",
      'nedot': "\u2250\u0338",
      'NegativeMediumSpace': "\u200B",
      'NegativeThickSpace': "\u200B",
      'NegativeThinSpace': "\u200B",
      'NegativeVeryThinSpace': "\u200B",
      'nequiv': "\u2262",
      'nesear': "\u2928",
      'nesim': "\u2242\u0338",
      'NestedGreaterGreater': "\u226B",
      'NestedLessLess': "\u226A",
      'NewLine': '\n',
      'nexist': "\u2204",
      'nexists': "\u2204",
      'nfr': "\uD835\uDD2B",
      'Nfr': "\uD835\uDD11",
      'nge': "\u2271",
      'ngE': "\u2267\u0338",
      'ngeq': "\u2271",
      'ngeqq': "\u2267\u0338",
      'ngeqslant': "\u2A7E\u0338",
      'nges': "\u2A7E\u0338",
      'nGg': "\u22D9\u0338",
      'ngsim': "\u2275",
      'ngt': "\u226F",
      'nGt': "\u226B\u20D2",
      'ngtr': "\u226F",
      'nGtv': "\u226B\u0338",
      'nharr': "\u21AE",
      'nhArr': "\u21CE",
      'nhpar': "\u2AF2",
      'ni': "\u220B",
      'nis': "\u22FC",
      'nisd': "\u22FA",
      'niv': "\u220B",
      'njcy': "\u045A",
      'NJcy': "\u040A",
      'nlarr': "\u219A",
      'nlArr': "\u21CD",
      'nldr': "\u2025",
      'nle': "\u2270",
      'nlE': "\u2266\u0338",
      'nleftarrow': "\u219A",
      'nLeftarrow': "\u21CD",
      'nleftrightarrow': "\u21AE",
      'nLeftrightarrow': "\u21CE",
      'nleq': "\u2270",
      'nleqq': "\u2266\u0338",
      'nleqslant': "\u2A7D\u0338",
      'nles': "\u2A7D\u0338",
      'nless': "\u226E",
      'nLl': "\u22D8\u0338",
      'nlsim': "\u2274",
      'nlt': "\u226E",
      'nLt': "\u226A\u20D2",
      'nltri': "\u22EA",
      'nltrie': "\u22EC",
      'nLtv': "\u226A\u0338",
      'nmid': "\u2224",
      'NoBreak': "\u2060",
      'NonBreakingSpace': '\xA0',
      'nopf': "\uD835\uDD5F",
      'Nopf': "\u2115",
      'not': '\xAC',
      'Not': "\u2AEC",
      'NotCongruent': "\u2262",
      'NotCupCap': "\u226D",
      'NotDoubleVerticalBar': "\u2226",
      'NotElement': "\u2209",
      'NotEqual': "\u2260",
      'NotEqualTilde': "\u2242\u0338",
      'NotExists': "\u2204",
      'NotGreater': "\u226F",
      'NotGreaterEqual': "\u2271",
      'NotGreaterFullEqual': "\u2267\u0338",
      'NotGreaterGreater': "\u226B\u0338",
      'NotGreaterLess': "\u2279",
      'NotGreaterSlantEqual': "\u2A7E\u0338",
      'NotGreaterTilde': "\u2275",
      'NotHumpDownHump': "\u224E\u0338",
      'NotHumpEqual': "\u224F\u0338",
      'notin': "\u2209",
      'notindot': "\u22F5\u0338",
      'notinE': "\u22F9\u0338",
      'notinva': "\u2209",
      'notinvb': "\u22F7",
      'notinvc': "\u22F6",
      'NotLeftTriangle': "\u22EA",
      'NotLeftTriangleBar': "\u29CF\u0338",
      'NotLeftTriangleEqual': "\u22EC",
      'NotLess': "\u226E",
      'NotLessEqual': "\u2270",
      'NotLessGreater': "\u2278",
      'NotLessLess': "\u226A\u0338",
      'NotLessSlantEqual': "\u2A7D\u0338",
      'NotLessTilde': "\u2274",
      'NotNestedGreaterGreater': "\u2AA2\u0338",
      'NotNestedLessLess': "\u2AA1\u0338",
      'notni': "\u220C",
      'notniva': "\u220C",
      'notnivb': "\u22FE",
      'notnivc': "\u22FD",
      'NotPrecedes': "\u2280",
      'NotPrecedesEqual': "\u2AAF\u0338",
      'NotPrecedesSlantEqual': "\u22E0",
      'NotReverseElement': "\u220C",
      'NotRightTriangle': "\u22EB",
      'NotRightTriangleBar': "\u29D0\u0338",
      'NotRightTriangleEqual': "\u22ED",
      'NotSquareSubset': "\u228F\u0338",
      'NotSquareSubsetEqual': "\u22E2",
      'NotSquareSuperset': "\u2290\u0338",
      'NotSquareSupersetEqual': "\u22E3",
      'NotSubset': "\u2282\u20D2",
      'NotSubsetEqual': "\u2288",
      'NotSucceeds': "\u2281",
      'NotSucceedsEqual': "\u2AB0\u0338",
      'NotSucceedsSlantEqual': "\u22E1",
      'NotSucceedsTilde': "\u227F\u0338",
      'NotSuperset': "\u2283\u20D2",
      'NotSupersetEqual': "\u2289",
      'NotTilde': "\u2241",
      'NotTildeEqual': "\u2244",
      'NotTildeFullEqual': "\u2247",
      'NotTildeTilde': "\u2249",
      'NotVerticalBar': "\u2224",
      'npar': "\u2226",
      'nparallel': "\u2226",
      'nparsl': "\u2AFD\u20E5",
      'npart': "\u2202\u0338",
      'npolint': "\u2A14",
      'npr': "\u2280",
      'nprcue': "\u22E0",
      'npre': "\u2AAF\u0338",
      'nprec': "\u2280",
      'npreceq': "\u2AAF\u0338",
      'nrarr': "\u219B",
      'nrArr': "\u21CF",
      'nrarrc': "\u2933\u0338",
      'nrarrw': "\u219D\u0338",
      'nrightarrow': "\u219B",
      'nRightarrow': "\u21CF",
      'nrtri': "\u22EB",
      'nrtrie': "\u22ED",
      'nsc': "\u2281",
      'nsccue': "\u22E1",
      'nsce': "\u2AB0\u0338",
      'nscr': "\uD835\uDCC3",
      'Nscr': "\uD835\uDCA9",
      'nshortmid': "\u2224",
      'nshortparallel': "\u2226",
      'nsim': "\u2241",
      'nsime': "\u2244",
      'nsimeq': "\u2244",
      'nsmid': "\u2224",
      'nspar': "\u2226",
      'nsqsube': "\u22E2",
      'nsqsupe': "\u22E3",
      'nsub': "\u2284",
      'nsube': "\u2288",
      'nsubE': "\u2AC5\u0338",
      'nsubset': "\u2282\u20D2",
      'nsubseteq': "\u2288",
      'nsubseteqq': "\u2AC5\u0338",
      'nsucc': "\u2281",
      'nsucceq': "\u2AB0\u0338",
      'nsup': "\u2285",
      'nsupe': "\u2289",
      'nsupE': "\u2AC6\u0338",
      'nsupset': "\u2283\u20D2",
      'nsupseteq': "\u2289",
      'nsupseteqq': "\u2AC6\u0338",
      'ntgl': "\u2279",
      'ntilde': '\xF1',
      'Ntilde': '\xD1',
      'ntlg': "\u2278",
      'ntriangleleft': "\u22EA",
      'ntrianglelefteq': "\u22EC",
      'ntriangleright': "\u22EB",
      'ntrianglerighteq': "\u22ED",
      'nu': "\u03BD",
      'Nu': "\u039D",
      'num': '#',
      'numero': "\u2116",
      'numsp': "\u2007",
      'nvap': "\u224D\u20D2",
      'nvdash': "\u22AC",
      'nvDash': "\u22AD",
      'nVdash': "\u22AE",
      'nVDash': "\u22AF",
      'nvge': "\u2265\u20D2",
      'nvgt': ">\u20D2",
      'nvHarr': "\u2904",
      'nvinfin': "\u29DE",
      'nvlArr': "\u2902",
      'nvle': "\u2264\u20D2",
      'nvlt': "<\u20D2",
      'nvltrie': "\u22B4\u20D2",
      'nvrArr': "\u2903",
      'nvrtrie': "\u22B5\u20D2",
      'nvsim': "\u223C\u20D2",
      'nwarhk': "\u2923",
      'nwarr': "\u2196",
      'nwArr': "\u21D6",
      'nwarrow': "\u2196",
      'nwnear': "\u2927",
      'oacute': '\xF3',
      'Oacute': '\xD3',
      'oast': "\u229B",
      'ocir': "\u229A",
      'ocirc': '\xF4',
      'Ocirc': '\xD4',
      'ocy': "\u043E",
      'Ocy': "\u041E",
      'odash': "\u229D",
      'odblac': "\u0151",
      'Odblac': "\u0150",
      'odiv': "\u2A38",
      'odot': "\u2299",
      'odsold': "\u29BC",
      'oelig': "\u0153",
      'OElig': "\u0152",
      'ofcir': "\u29BF",
      'ofr': "\uD835\uDD2C",
      'Ofr': "\uD835\uDD12",
      'ogon': "\u02DB",
      'ograve': '\xF2',
      'Ograve': '\xD2',
      'ogt': "\u29C1",
      'ohbar': "\u29B5",
      'ohm': "\u03A9",
      'oint': "\u222E",
      'olarr': "\u21BA",
      'olcir': "\u29BE",
      'olcross': "\u29BB",
      'oline': "\u203E",
      'olt': "\u29C0",
      'omacr': "\u014D",
      'Omacr': "\u014C",
      'omega': "\u03C9",
      'Omega': "\u03A9",
      'omicron': "\u03BF",
      'Omicron': "\u039F",
      'omid': "\u29B6",
      'ominus': "\u2296",
      'oopf': "\uD835\uDD60",
      'Oopf': "\uD835\uDD46",
      'opar': "\u29B7",
      'OpenCurlyDoubleQuote': "\u201C",
      'OpenCurlyQuote': "\u2018",
      'operp': "\u29B9",
      'oplus': "\u2295",
      'or': "\u2228",
      'Or': "\u2A54",
      'orarr': "\u21BB",
      'ord': "\u2A5D",
      'order': "\u2134",
      'orderof': "\u2134",
      'ordf': '\xAA',
      'ordm': '\xBA',
      'origof': "\u22B6",
      'oror': "\u2A56",
      'orslope': "\u2A57",
      'orv': "\u2A5B",
      'oS': "\u24C8",
      'oscr': "\u2134",
      'Oscr': "\uD835\uDCAA",
      'oslash': '\xF8',
      'Oslash': '\xD8',
      'osol': "\u2298",
      'otilde': '\xF5',
      'Otilde': '\xD5',
      'otimes': "\u2297",
      'Otimes': "\u2A37",
      'otimesas': "\u2A36",
      'ouml': '\xF6',
      'Ouml': '\xD6',
      'ovbar': "\u233D",
      'OverBar': "\u203E",
      'OverBrace': "\u23DE",
      'OverBracket': "\u23B4",
      'OverParenthesis': "\u23DC",
      'par': "\u2225",
      'para': '\xB6',
      'parallel': "\u2225",
      'parsim': "\u2AF3",
      'parsl': "\u2AFD",
      'part': "\u2202",
      'PartialD': "\u2202",
      'pcy': "\u043F",
      'Pcy': "\u041F",
      'percnt': '%',
      'period': '.',
      'permil': "\u2030",
      'perp': "\u22A5",
      'pertenk': "\u2031",
      'pfr': "\uD835\uDD2D",
      'Pfr': "\uD835\uDD13",
      'phi': "\u03C6",
      'Phi': "\u03A6",
      'phiv': "\u03D5",
      'phmmat': "\u2133",
      'phone': "\u260E",
      'pi': "\u03C0",
      'Pi': "\u03A0",
      'pitchfork': "\u22D4",
      'piv': "\u03D6",
      'planck': "\u210F",
      'planckh': "\u210E",
      'plankv': "\u210F",
      'plus': '+',
      'plusacir': "\u2A23",
      'plusb': "\u229E",
      'pluscir': "\u2A22",
      'plusdo': "\u2214",
      'plusdu': "\u2A25",
      'pluse': "\u2A72",
      'PlusMinus': '\xB1',
      'plusmn': '\xB1',
      'plussim': "\u2A26",
      'plustwo': "\u2A27",
      'pm': '\xB1',
      'Poincareplane': "\u210C",
      'pointint': "\u2A15",
      'popf': "\uD835\uDD61",
      'Popf': "\u2119",
      'pound': '\xA3',
      'pr': "\u227A",
      'Pr': "\u2ABB",
      'prap': "\u2AB7",
      'prcue': "\u227C",
      'pre': "\u2AAF",
      'prE': "\u2AB3",
      'prec': "\u227A",
      'precapprox': "\u2AB7",
      'preccurlyeq': "\u227C",
      'Precedes': "\u227A",
      'PrecedesEqual': "\u2AAF",
      'PrecedesSlantEqual': "\u227C",
      'PrecedesTilde': "\u227E",
      'preceq': "\u2AAF",
      'precnapprox': "\u2AB9",
      'precneqq': "\u2AB5",
      'precnsim': "\u22E8",
      'precsim': "\u227E",
      'prime': "\u2032",
      'Prime': "\u2033",
      'primes': "\u2119",
      'prnap': "\u2AB9",
      'prnE': "\u2AB5",
      'prnsim': "\u22E8",
      'prod': "\u220F",
      'Product': "\u220F",
      'profalar': "\u232E",
      'profline': "\u2312",
      'profsurf': "\u2313",
      'prop': "\u221D",
      'Proportion': "\u2237",
      'Proportional': "\u221D",
      'propto': "\u221D",
      'prsim': "\u227E",
      'prurel': "\u22B0",
      'pscr': "\uD835\uDCC5",
      'Pscr': "\uD835\uDCAB",
      'psi': "\u03C8",
      'Psi': "\u03A8",
      'puncsp': "\u2008",
      'qfr': "\uD835\uDD2E",
      'Qfr': "\uD835\uDD14",
      'qint': "\u2A0C",
      'qopf': "\uD835\uDD62",
      'Qopf': "\u211A",
      'qprime': "\u2057",
      'qscr': "\uD835\uDCC6",
      'Qscr': "\uD835\uDCAC",
      'quaternions': "\u210D",
      'quatint': "\u2A16",
      'quest': '?',
      'questeq': "\u225F",
      'quot': '"',
      'QUOT': '"',
      'rAarr': "\u21DB",
      'race': "\u223D\u0331",
      'racute': "\u0155",
      'Racute': "\u0154",
      'radic': "\u221A",
      'raemptyv': "\u29B3",
      'rang': "\u27E9",
      'Rang': "\u27EB",
      'rangd': "\u2992",
      'range': "\u29A5",
      'rangle': "\u27E9",
      'raquo': '\xBB',
      'rarr': "\u2192",
      'rArr': "\u21D2",
      'Rarr': "\u21A0",
      'rarrap': "\u2975",
      'rarrb': "\u21E5",
      'rarrbfs': "\u2920",
      'rarrc': "\u2933",
      'rarrfs': "\u291E",
      'rarrhk': "\u21AA",
      'rarrlp': "\u21AC",
      'rarrpl': "\u2945",
      'rarrsim': "\u2974",
      'rarrtl': "\u21A3",
      'Rarrtl': "\u2916",
      'rarrw': "\u219D",
      'ratail': "\u291A",
      'rAtail': "\u291C",
      'ratio': "\u2236",
      'rationals': "\u211A",
      'rbarr': "\u290D",
      'rBarr': "\u290F",
      'RBarr': "\u2910",
      'rbbrk': "\u2773",
      'rbrace': '}',
      'rbrack': ']',
      'rbrke': "\u298C",
      'rbrksld': "\u298E",
      'rbrkslu': "\u2990",
      'rcaron': "\u0159",
      'Rcaron': "\u0158",
      'rcedil': "\u0157",
      'Rcedil': "\u0156",
      'rceil': "\u2309",
      'rcub': '}',
      'rcy': "\u0440",
      'Rcy': "\u0420",
      'rdca': "\u2937",
      'rdldhar': "\u2969",
      'rdquo': "\u201D",
      'rdquor': "\u201D",
      'rdsh': "\u21B3",
      'Re': "\u211C",
      'real': "\u211C",
      'realine': "\u211B",
      'realpart': "\u211C",
      'reals': "\u211D",
      'rect': "\u25AD",
      'reg': '\xAE',
      'REG': '\xAE',
      'ReverseElement': "\u220B",
      'ReverseEquilibrium': "\u21CB",
      'ReverseUpEquilibrium': "\u296F",
      'rfisht': "\u297D",
      'rfloor': "\u230B",
      'rfr': "\uD835\uDD2F",
      'Rfr': "\u211C",
      'rHar': "\u2964",
      'rhard': "\u21C1",
      'rharu': "\u21C0",
      'rharul': "\u296C",
      'rho': "\u03C1",
      'Rho': "\u03A1",
      'rhov': "\u03F1",
      'RightAngleBracket': "\u27E9",
      'rightarrow': "\u2192",
      'Rightarrow': "\u21D2",
      'RightArrow': "\u2192",
      'RightArrowBar': "\u21E5",
      'RightArrowLeftArrow': "\u21C4",
      'rightarrowtail': "\u21A3",
      'RightCeiling': "\u2309",
      'RightDoubleBracket': "\u27E7",
      'RightDownTeeVector': "\u295D",
      'RightDownVector': "\u21C2",
      'RightDownVectorBar': "\u2955",
      'RightFloor': "\u230B",
      'rightharpoondown': "\u21C1",
      'rightharpoonup': "\u21C0",
      'rightleftarrows': "\u21C4",
      'rightleftharpoons': "\u21CC",
      'rightrightarrows': "\u21C9",
      'rightsquigarrow': "\u219D",
      'RightTee': "\u22A2",
      'RightTeeArrow': "\u21A6",
      'RightTeeVector': "\u295B",
      'rightthreetimes': "\u22CC",
      'RightTriangle': "\u22B3",
      'RightTriangleBar': "\u29D0",
      'RightTriangleEqual': "\u22B5",
      'RightUpDownVector': "\u294F",
      'RightUpTeeVector': "\u295C",
      'RightUpVector': "\u21BE",
      'RightUpVectorBar': "\u2954",
      'RightVector': "\u21C0",
      'RightVectorBar': "\u2953",
      'ring': "\u02DA",
      'risingdotseq': "\u2253",
      'rlarr': "\u21C4",
      'rlhar': "\u21CC",
      'rlm': "\u200F",
      'rmoust': "\u23B1",
      'rmoustache': "\u23B1",
      'rnmid': "\u2AEE",
      'roang': "\u27ED",
      'roarr': "\u21FE",
      'robrk': "\u27E7",
      'ropar': "\u2986",
      'ropf': "\uD835\uDD63",
      'Ropf': "\u211D",
      'roplus': "\u2A2E",
      'rotimes': "\u2A35",
      'RoundImplies': "\u2970",
      'rpar': ')',
      'rpargt': "\u2994",
      'rppolint': "\u2A12",
      'rrarr': "\u21C9",
      'Rrightarrow': "\u21DB",
      'rsaquo': "\u203A",
      'rscr': "\uD835\uDCC7",
      'Rscr': "\u211B",
      'rsh': "\u21B1",
      'Rsh': "\u21B1",
      'rsqb': ']',
      'rsquo': "\u2019",
      'rsquor': "\u2019",
      'rthree': "\u22CC",
      'rtimes': "\u22CA",
      'rtri': "\u25B9",
      'rtrie': "\u22B5",
      'rtrif': "\u25B8",
      'rtriltri': "\u29CE",
      'RuleDelayed': "\u29F4",
      'ruluhar': "\u2968",
      'rx': "\u211E",
      'sacute': "\u015B",
      'Sacute': "\u015A",
      'sbquo': "\u201A",
      'sc': "\u227B",
      'Sc': "\u2ABC",
      'scap': "\u2AB8",
      'scaron': "\u0161",
      'Scaron': "\u0160",
      'sccue': "\u227D",
      'sce': "\u2AB0",
      'scE': "\u2AB4",
      'scedil': "\u015F",
      'Scedil': "\u015E",
      'scirc': "\u015D",
      'Scirc': "\u015C",
      'scnap': "\u2ABA",
      'scnE': "\u2AB6",
      'scnsim': "\u22E9",
      'scpolint': "\u2A13",
      'scsim': "\u227F",
      'scy': "\u0441",
      'Scy': "\u0421",
      'sdot': "\u22C5",
      'sdotb': "\u22A1",
      'sdote': "\u2A66",
      'searhk': "\u2925",
      'searr': "\u2198",
      'seArr': "\u21D8",
      'searrow': "\u2198",
      'sect': '\xA7',
      'semi': ';',
      'seswar': "\u2929",
      'setminus': "\u2216",
      'setmn': "\u2216",
      'sext': "\u2736",
      'sfr': "\uD835\uDD30",
      'Sfr': "\uD835\uDD16",
      'sfrown': "\u2322",
      'sharp': "\u266F",
      'shchcy': "\u0449",
      'SHCHcy': "\u0429",
      'shcy': "\u0448",
      'SHcy': "\u0428",
      'ShortDownArrow': "\u2193",
      'ShortLeftArrow': "\u2190",
      'shortmid': "\u2223",
      'shortparallel': "\u2225",
      'ShortRightArrow': "\u2192",
      'ShortUpArrow': "\u2191",
      'shy': '\xAD',
      'sigma': "\u03C3",
      'Sigma': "\u03A3",
      'sigmaf': "\u03C2",
      'sigmav': "\u03C2",
      'sim': "\u223C",
      'simdot': "\u2A6A",
      'sime': "\u2243",
      'simeq': "\u2243",
      'simg': "\u2A9E",
      'simgE': "\u2AA0",
      'siml': "\u2A9D",
      'simlE': "\u2A9F",
      'simne': "\u2246",
      'simplus': "\u2A24",
      'simrarr': "\u2972",
      'slarr': "\u2190",
      'SmallCircle': "\u2218",
      'smallsetminus': "\u2216",
      'smashp': "\u2A33",
      'smeparsl': "\u29E4",
      'smid': "\u2223",
      'smile': "\u2323",
      'smt': "\u2AAA",
      'smte': "\u2AAC",
      'smtes': "\u2AAC\uFE00",
      'softcy': "\u044C",
      'SOFTcy': "\u042C",
      'sol': '/',
      'solb': "\u29C4",
      'solbar': "\u233F",
      'sopf': "\uD835\uDD64",
      'Sopf': "\uD835\uDD4A",
      'spades': "\u2660",
      'spadesuit': "\u2660",
      'spar': "\u2225",
      'sqcap': "\u2293",
      'sqcaps': "\u2293\uFE00",
      'sqcup': "\u2294",
      'sqcups': "\u2294\uFE00",
      'Sqrt': "\u221A",
      'sqsub': "\u228F",
      'sqsube': "\u2291",
      'sqsubset': "\u228F",
      'sqsubseteq': "\u2291",
      'sqsup': "\u2290",
      'sqsupe': "\u2292",
      'sqsupset': "\u2290",
      'sqsupseteq': "\u2292",
      'squ': "\u25A1",
      'square': "\u25A1",
      'Square': "\u25A1",
      'SquareIntersection': "\u2293",
      'SquareSubset': "\u228F",
      'SquareSubsetEqual': "\u2291",
      'SquareSuperset': "\u2290",
      'SquareSupersetEqual': "\u2292",
      'SquareUnion': "\u2294",
      'squarf': "\u25AA",
      'squf': "\u25AA",
      'srarr': "\u2192",
      'sscr': "\uD835\uDCC8",
      'Sscr': "\uD835\uDCAE",
      'ssetmn': "\u2216",
      'ssmile': "\u2323",
      'sstarf': "\u22C6",
      'star': "\u2606",
      'Star': "\u22C6",
      'starf': "\u2605",
      'straightepsilon': "\u03F5",
      'straightphi': "\u03D5",
      'strns': '\xAF',
      'sub': "\u2282",
      'Sub': "\u22D0",
      'subdot': "\u2ABD",
      'sube': "\u2286",
      'subE': "\u2AC5",
      'subedot': "\u2AC3",
      'submult': "\u2AC1",
      'subne': "\u228A",
      'subnE': "\u2ACB",
      'subplus': "\u2ABF",
      'subrarr': "\u2979",
      'subset': "\u2282",
      'Subset': "\u22D0",
      'subseteq': "\u2286",
      'subseteqq': "\u2AC5",
      'SubsetEqual': "\u2286",
      'subsetneq': "\u228A",
      'subsetneqq': "\u2ACB",
      'subsim': "\u2AC7",
      'subsub': "\u2AD5",
      'subsup': "\u2AD3",
      'succ': "\u227B",
      'succapprox': "\u2AB8",
      'succcurlyeq': "\u227D",
      'Succeeds': "\u227B",
      'SucceedsEqual': "\u2AB0",
      'SucceedsSlantEqual': "\u227D",
      'SucceedsTilde': "\u227F",
      'succeq': "\u2AB0",
      'succnapprox': "\u2ABA",
      'succneqq': "\u2AB6",
      'succnsim': "\u22E9",
      'succsim': "\u227F",
      'SuchThat': "\u220B",
      'sum': "\u2211",
      'Sum': "\u2211",
      'sung': "\u266A",
      'sup': "\u2283",
      'Sup': "\u22D1",
      'sup1': '\xB9',
      'sup2': '\xB2',
      'sup3': '\xB3',
      'supdot': "\u2ABE",
      'supdsub': "\u2AD8",
      'supe': "\u2287",
      'supE': "\u2AC6",
      'supedot': "\u2AC4",
      'Superset': "\u2283",
      'SupersetEqual': "\u2287",
      'suphsol': "\u27C9",
      'suphsub': "\u2AD7",
      'suplarr': "\u297B",
      'supmult': "\u2AC2",
      'supne': "\u228B",
      'supnE': "\u2ACC",
      'supplus': "\u2AC0",
      'supset': "\u2283",
      'Supset': "\u22D1",
      'supseteq': "\u2287",
      'supseteqq': "\u2AC6",
      'supsetneq': "\u228B",
      'supsetneqq': "\u2ACC",
      'supsim': "\u2AC8",
      'supsub': "\u2AD4",
      'supsup': "\u2AD6",
      'swarhk': "\u2926",
      'swarr': "\u2199",
      'swArr': "\u21D9",
      'swarrow': "\u2199",
      'swnwar': "\u292A",
      'szlig': '\xDF',
      'Tab': '\t',
      'target': "\u2316",
      'tau': "\u03C4",
      'Tau': "\u03A4",
      'tbrk': "\u23B4",
      'tcaron': "\u0165",
      'Tcaron': "\u0164",
      'tcedil': "\u0163",
      'Tcedil': "\u0162",
      'tcy': "\u0442",
      'Tcy': "\u0422",
      'tdot': "\u20DB",
      'telrec': "\u2315",
      'tfr': "\uD835\uDD31",
      'Tfr': "\uD835\uDD17",
      'there4': "\u2234",
      'therefore': "\u2234",
      'Therefore': "\u2234",
      'theta': "\u03B8",
      'Theta': "\u0398",
      'thetasym': "\u03D1",
      'thetav': "\u03D1",
      'thickapprox': "\u2248",
      'thicksim': "\u223C",
      'ThickSpace': "\u205F\u200A",
      'thinsp': "\u2009",
      'ThinSpace': "\u2009",
      'thkap': "\u2248",
      'thksim': "\u223C",
      'thorn': '\xFE',
      'THORN': '\xDE',
      'tilde': "\u02DC",
      'Tilde': "\u223C",
      'TildeEqual': "\u2243",
      'TildeFullEqual': "\u2245",
      'TildeTilde': "\u2248",
      'times': '\xD7',
      'timesb': "\u22A0",
      'timesbar': "\u2A31",
      'timesd': "\u2A30",
      'tint': "\u222D",
      'toea': "\u2928",
      'top': "\u22A4",
      'topbot': "\u2336",
      'topcir': "\u2AF1",
      'topf': "\uD835\uDD65",
      'Topf': "\uD835\uDD4B",
      'topfork': "\u2ADA",
      'tosa': "\u2929",
      'tprime': "\u2034",
      'trade': "\u2122",
      'TRADE': "\u2122",
      'triangle': "\u25B5",
      'triangledown': "\u25BF",
      'triangleleft': "\u25C3",
      'trianglelefteq': "\u22B4",
      'triangleq': "\u225C",
      'triangleright': "\u25B9",
      'trianglerighteq': "\u22B5",
      'tridot': "\u25EC",
      'trie': "\u225C",
      'triminus': "\u2A3A",
      'TripleDot': "\u20DB",
      'triplus': "\u2A39",
      'trisb': "\u29CD",
      'tritime': "\u2A3B",
      'trpezium': "\u23E2",
      'tscr': "\uD835\uDCC9",
      'Tscr': "\uD835\uDCAF",
      'tscy': "\u0446",
      'TScy': "\u0426",
      'tshcy': "\u045B",
      'TSHcy': "\u040B",
      'tstrok': "\u0167",
      'Tstrok': "\u0166",
      'twixt': "\u226C",
      'twoheadleftarrow': "\u219E",
      'twoheadrightarrow': "\u21A0",
      'uacute': '\xFA',
      'Uacute': '\xDA',
      'uarr': "\u2191",
      'uArr': "\u21D1",
      'Uarr': "\u219F",
      'Uarrocir': "\u2949",
      'ubrcy': "\u045E",
      'Ubrcy': "\u040E",
      'ubreve': "\u016D",
      'Ubreve': "\u016C",
      'ucirc': '\xFB',
      'Ucirc': '\xDB',
      'ucy': "\u0443",
      'Ucy': "\u0423",
      'udarr': "\u21C5",
      'udblac': "\u0171",
      'Udblac': "\u0170",
      'udhar': "\u296E",
      'ufisht': "\u297E",
      'ufr': "\uD835\uDD32",
      'Ufr': "\uD835\uDD18",
      'ugrave': '\xF9',
      'Ugrave': '\xD9',
      'uHar': "\u2963",
      'uharl': "\u21BF",
      'uharr': "\u21BE",
      'uhblk': "\u2580",
      'ulcorn': "\u231C",
      'ulcorner': "\u231C",
      'ulcrop': "\u230F",
      'ultri': "\u25F8",
      'umacr': "\u016B",
      'Umacr': "\u016A",
      'uml': '\xA8',
      'UnderBar': '_',
      'UnderBrace': "\u23DF",
      'UnderBracket': "\u23B5",
      'UnderParenthesis': "\u23DD",
      'Union': "\u22C3",
      'UnionPlus': "\u228E",
      'uogon': "\u0173",
      'Uogon': "\u0172",
      'uopf': "\uD835\uDD66",
      'Uopf': "\uD835\uDD4C",
      'uparrow': "\u2191",
      'Uparrow': "\u21D1",
      'UpArrow': "\u2191",
      'UpArrowBar': "\u2912",
      'UpArrowDownArrow': "\u21C5",
      'updownarrow': "\u2195",
      'Updownarrow': "\u21D5",
      'UpDownArrow': "\u2195",
      'UpEquilibrium': "\u296E",
      'upharpoonleft': "\u21BF",
      'upharpoonright': "\u21BE",
      'uplus': "\u228E",
      'UpperLeftArrow': "\u2196",
      'UpperRightArrow': "\u2197",
      'upsi': "\u03C5",
      'Upsi': "\u03D2",
      'upsih': "\u03D2",
      'upsilon': "\u03C5",
      'Upsilon': "\u03A5",
      'UpTee': "\u22A5",
      'UpTeeArrow': "\u21A5",
      'upuparrows': "\u21C8",
      'urcorn': "\u231D",
      'urcorner': "\u231D",
      'urcrop': "\u230E",
      'uring': "\u016F",
      'Uring': "\u016E",
      'urtri': "\u25F9",
      'uscr': "\uD835\uDCCA",
      'Uscr': "\uD835\uDCB0",
      'utdot': "\u22F0",
      'utilde': "\u0169",
      'Utilde': "\u0168",
      'utri': "\u25B5",
      'utrif': "\u25B4",
      'uuarr': "\u21C8",
      'uuml': '\xFC',
      'Uuml': '\xDC',
      'uwangle': "\u29A7",
      'vangrt': "\u299C",
      'varepsilon': "\u03F5",
      'varkappa': "\u03F0",
      'varnothing': "\u2205",
      'varphi': "\u03D5",
      'varpi': "\u03D6",
      'varpropto': "\u221D",
      'varr': "\u2195",
      'vArr': "\u21D5",
      'varrho': "\u03F1",
      'varsigma': "\u03C2",
      'varsubsetneq': "\u228A\uFE00",
      'varsubsetneqq': "\u2ACB\uFE00",
      'varsupsetneq': "\u228B\uFE00",
      'varsupsetneqq': "\u2ACC\uFE00",
      'vartheta': "\u03D1",
      'vartriangleleft': "\u22B2",
      'vartriangleright': "\u22B3",
      'vBar': "\u2AE8",
      'Vbar': "\u2AEB",
      'vBarv': "\u2AE9",
      'vcy': "\u0432",
      'Vcy': "\u0412",
      'vdash': "\u22A2",
      'vDash': "\u22A8",
      'Vdash': "\u22A9",
      'VDash': "\u22AB",
      'Vdashl': "\u2AE6",
      'vee': "\u2228",
      'Vee': "\u22C1",
      'veebar': "\u22BB",
      'veeeq': "\u225A",
      'vellip': "\u22EE",
      'verbar': '|',
      'Verbar': "\u2016",
      'vert': '|',
      'Vert': "\u2016",
      'VerticalBar': "\u2223",
      'VerticalLine': '|',
      'VerticalSeparator': "\u2758",
      'VerticalTilde': "\u2240",
      'VeryThinSpace': "\u200A",
      'vfr': "\uD835\uDD33",
      'Vfr': "\uD835\uDD19",
      'vltri': "\u22B2",
      'vnsub': "\u2282\u20D2",
      'vnsup': "\u2283\u20D2",
      'vopf': "\uD835\uDD67",
      'Vopf': "\uD835\uDD4D",
      'vprop': "\u221D",
      'vrtri': "\u22B3",
      'vscr': "\uD835\uDCCB",
      'Vscr': "\uD835\uDCB1",
      'vsubne': "\u228A\uFE00",
      'vsubnE': "\u2ACB\uFE00",
      'vsupne': "\u228B\uFE00",
      'vsupnE': "\u2ACC\uFE00",
      'Vvdash': "\u22AA",
      'vzigzag': "\u299A",
      'wcirc': "\u0175",
      'Wcirc': "\u0174",
      'wedbar': "\u2A5F",
      'wedge': "\u2227",
      'Wedge': "\u22C0",
      'wedgeq': "\u2259",
      'weierp': "\u2118",
      'wfr': "\uD835\uDD34",
      'Wfr': "\uD835\uDD1A",
      'wopf': "\uD835\uDD68",
      'Wopf': "\uD835\uDD4E",
      'wp': "\u2118",
      'wr': "\u2240",
      'wreath': "\u2240",
      'wscr': "\uD835\uDCCC",
      'Wscr': "\uD835\uDCB2",
      'xcap': "\u22C2",
      'xcirc': "\u25EF",
      'xcup': "\u22C3",
      'xdtri': "\u25BD",
      'xfr': "\uD835\uDD35",
      'Xfr': "\uD835\uDD1B",
      'xharr': "\u27F7",
      'xhArr': "\u27FA",
      'xi': "\u03BE",
      'Xi': "\u039E",
      'xlarr': "\u27F5",
      'xlArr': "\u27F8",
      'xmap': "\u27FC",
      'xnis': "\u22FB",
      'xodot': "\u2A00",
      'xopf': "\uD835\uDD69",
      'Xopf': "\uD835\uDD4F",
      'xoplus': "\u2A01",
      'xotime': "\u2A02",
      'xrarr': "\u27F6",
      'xrArr': "\u27F9",
      'xscr': "\uD835\uDCCD",
      'Xscr': "\uD835\uDCB3",
      'xsqcup': "\u2A06",
      'xuplus': "\u2A04",
      'xutri': "\u25B3",
      'xvee': "\u22C1",
      'xwedge': "\u22C0",
      'yacute': '\xFD',
      'Yacute': '\xDD',
      'yacy': "\u044F",
      'YAcy': "\u042F",
      'ycirc': "\u0177",
      'Ycirc': "\u0176",
      'ycy': "\u044B",
      'Ycy': "\u042B",
      'yen': '\xA5',
      'yfr': "\uD835\uDD36",
      'Yfr': "\uD835\uDD1C",
      'yicy': "\u0457",
      'YIcy': "\u0407",
      'yopf': "\uD835\uDD6A",
      'Yopf': "\uD835\uDD50",
      'yscr': "\uD835\uDCCE",
      'Yscr': "\uD835\uDCB4",
      'yucy': "\u044E",
      'YUcy': "\u042E",
      'yuml': '\xFF',
      'Yuml': "\u0178",
      'zacute': "\u017A",
      'Zacute': "\u0179",
      'zcaron': "\u017E",
      'Zcaron': "\u017D",
      'zcy': "\u0437",
      'Zcy': "\u0417",
      'zdot': "\u017C",
      'Zdot': "\u017B",
      'zeetrf': "\u2128",
      'ZeroWidthSpace': "\u200B",
      'zeta': "\u03B6",
      'Zeta': "\u0396",
      'zfr': "\uD835\uDD37",
      'Zfr': "\u2128",
      'zhcy': "\u0436",
      'ZHcy': "\u0416",
      'zigrarr': "\u21DD",
      'zopf': "\uD835\uDD6B",
      'Zopf': "\u2124",
      'zscr': "\uD835\uDCCF",
      'Zscr': "\uD835\uDCB5",
      'zwj': "\u200D",
      'zwnj': "\u200C"
    };
    var decodeMapLegacy = {
      'aacute': '\xE1',
      'Aacute': '\xC1',
      'acirc': '\xE2',
      'Acirc': '\xC2',
      'acute': '\xB4',
      'aelig': '\xE6',
      'AElig': '\xC6',
      'agrave': '\xE0',
      'Agrave': '\xC0',
      'amp': '&',
      'AMP': '&',
      'aring': '\xE5',
      'Aring': '\xC5',
      'atilde': '\xE3',
      'Atilde': '\xC3',
      'auml': '\xE4',
      'Auml': '\xC4',
      'brvbar': '\xA6',
      'ccedil': '\xE7',
      'Ccedil': '\xC7',
      'cedil': '\xB8',
      'cent': '\xA2',
      'copy': '\xA9',
      'COPY': '\xA9',
      'curren': '\xA4',
      'deg': '\xB0',
      'divide': '\xF7',
      'eacute': '\xE9',
      'Eacute': '\xC9',
      'ecirc': '\xEA',
      'Ecirc': '\xCA',
      'egrave': '\xE8',
      'Egrave': '\xC8',
      'eth': '\xF0',
      'ETH': '\xD0',
      'euml': '\xEB',
      'Euml': '\xCB',
      'frac12': '\xBD',
      'frac14': '\xBC',
      'frac34': '\xBE',
      'gt': '>',
      'GT': '>',
      'iacute': '\xED',
      'Iacute': '\xCD',
      'icirc': '\xEE',
      'Icirc': '\xCE',
      'iexcl': '\xA1',
      'igrave': '\xEC',
      'Igrave': '\xCC',
      'iquest': '\xBF',
      'iuml': '\xEF',
      'Iuml': '\xCF',
      'laquo': '\xAB',
      'lt': '<',
      'LT': '<',
      'macr': '\xAF',
      'micro': '\xB5',
      'middot': '\xB7',
      'nbsp': '\xA0',
      'not': '\xAC',
      'ntilde': '\xF1',
      'Ntilde': '\xD1',
      'oacute': '\xF3',
      'Oacute': '\xD3',
      'ocirc': '\xF4',
      'Ocirc': '\xD4',
      'ograve': '\xF2',
      'Ograve': '\xD2',
      'ordf': '\xAA',
      'ordm': '\xBA',
      'oslash': '\xF8',
      'Oslash': '\xD8',
      'otilde': '\xF5',
      'Otilde': '\xD5',
      'ouml': '\xF6',
      'Ouml': '\xD6',
      'para': '\xB6',
      'plusmn': '\xB1',
      'pound': '\xA3',
      'quot': '"',
      'QUOT': '"',
      'raquo': '\xBB',
      'reg': '\xAE',
      'REG': '\xAE',
      'sect': '\xA7',
      'shy': '\xAD',
      'sup1': '\xB9',
      'sup2': '\xB2',
      'sup3': '\xB3',
      'szlig': '\xDF',
      'thorn': '\xFE',
      'THORN': '\xDE',
      'times': '\xD7',
      'uacute': '\xFA',
      'Uacute': '\xDA',
      'ucirc': '\xFB',
      'Ucirc': '\xDB',
      'ugrave': '\xF9',
      'Ugrave': '\xD9',
      'uml': '\xA8',
      'uuml': '\xFC',
      'Uuml': '\xDC',
      'yacute': '\xFD',
      'Yacute': '\xDD',
      'yen': '\xA5',
      'yuml': '\xFF'
    };
    var decodeMapNumeric = {
      '0': "\uFFFD",
      '128': "\u20AC",
      '130': "\u201A",
      '131': "\u0192",
      '132': "\u201E",
      '133': "\u2026",
      '134': "\u2020",
      '135': "\u2021",
      '136': "\u02C6",
      '137': "\u2030",
      '138': "\u0160",
      '139': "\u2039",
      '140': "\u0152",
      '142': "\u017D",
      '145': "\u2018",
      '146': "\u2019",
      '147': "\u201C",
      '148': "\u201D",
      '149': "\u2022",
      '150': "\u2013",
      '151': "\u2014",
      '152': "\u02DC",
      '153': "\u2122",
      '154': "\u0161",
      '155': "\u203A",
      '156': "\u0153",
      '158': "\u017E",
      '159': "\u0178"
    };
    var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65000, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
    /*--------------------------------------------------------------------------*/

    var stringFromCharCode = String.fromCharCode;
    var object = {};
    var hasOwnProperty = object.hasOwnProperty;

    var has = function has(object, propertyName) {
      return hasOwnProperty.call(object, propertyName);
    };

    var contains = function contains(array, value) {
      var index = -1;
      var length = array.length;

      while (++index < length) {
        if (array[index] == value) {
          return true;
        }
      }

      return false;
    };

    var merge = function merge(options, defaults) {
      if (!options) {
        return defaults;
      }

      var result = {};
      var key;

      for (key in defaults) {
        // A `hasOwnProperty` check is not needed here, since only recognized
        // option names are used anyway. Any others are ignored.
        result[key] = has(options, key) ? options[key] : defaults[key];
      }

      return result;
    }; // Modified version of `ucs2encode`; see https://mths.be/punycode.


    var codePointToSymbol = function codePointToSymbol(codePoint, strict) {
      var output = '';

      if (codePoint >= 0xD800 && codePoint <= 0xDFFF || codePoint > 0x10FFFF) {
        // See issue #4:
        // “Otherwise, if the number is in the range 0xD800 to 0xDFFF or is
        // greater than 0x10FFFF, then this is a parse error. Return a U+FFFD
        // REPLACEMENT CHARACTER.”
        if (strict) {
          parseError('character reference outside the permissible Unicode range');
        }

        return "\uFFFD";
      }

      if (has(decodeMapNumeric, codePoint)) {
        if (strict) {
          parseError('disallowed character reference');
        }

        return decodeMapNumeric[codePoint];
      }

      if (strict && contains(invalidReferenceCodePoints, codePoint)) {
        parseError('disallowed character reference');
      }

      if (codePoint > 0xFFFF) {
        codePoint -= 0x10000;
        output += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      output += stringFromCharCode(codePoint);
      return output;
    };

    var hexEscape = function hexEscape(codePoint) {
      return '&#x' + codePoint.toString(16).toUpperCase() + ';';
    };

    var decEscape = function decEscape(codePoint) {
      return '&#' + codePoint + ';';
    };

    var parseError = function parseError(message) {
      throw Error('Parse error: ' + message);
    };
    /*--------------------------------------------------------------------------*/


    var encode = function encode(string, options) {
      options = merge(options, encode.options);
      var strict = options.strict;

      if (strict && regexInvalidRawCodePoint.test(string)) {
        parseError('forbidden code point');
      }

      var encodeEverything = options.encodeEverything;
      var useNamedReferences = options.useNamedReferences;
      var allowUnsafeSymbols = options.allowUnsafeSymbols;
      var escapeCodePoint = options.decimal ? decEscape : hexEscape;

      var escapeBmpSymbol = function escapeBmpSymbol(symbol) {
        return escapeCodePoint(symbol.charCodeAt(0));
      };

      if (encodeEverything) {
        // Encode ASCII symbols.
        string = string.replace(regexAsciiWhitelist, function (symbol) {
          // Use named references if requested & possible.
          if (useNamedReferences && has(encodeMap, symbol)) {
            return '&' + encodeMap[symbol] + ';';
          }

          return escapeBmpSymbol(symbol);
        }); // Shorten a few escapes that represent two symbols, of which at least one
        // is within the ASCII range.

        if (useNamedReferences) {
          string = string.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;').replace(/&#x66;&#x6A;/g, '&fjlig;');
        } // Encode non-ASCII symbols.


        if (useNamedReferences) {
          // Encode non-ASCII symbols that can be replaced with a named reference.
          string = string.replace(regexEncodeNonAscii, function (string) {
            // Note: there is no need to check `has(encodeMap, string)` here.
            return '&' + encodeMap[string] + ';';
          });
        } // Note: any remaining non-ASCII symbols are handled outside of the `if`.

      } else if (useNamedReferences) {
        // Apply named character references.
        // Encode `<>"'&` using named character references.
        if (!allowUnsafeSymbols) {
          string = string.replace(regexEscape, function (string) {
            return '&' + encodeMap[string] + ';'; // no need to check `has()` here
          });
        } // Shorten escapes that represent two symbols, of which at least one is
        // `<>"'&`.


        string = string.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;'); // Encode non-ASCII symbols that can be replaced with a named reference.

        string = string.replace(regexEncodeNonAscii, function (string) {
          // Note: there is no need to check `has(encodeMap, string)` here.
          return '&' + encodeMap[string] + ';';
        });
      } else if (!allowUnsafeSymbols) {
        // Encode `<>"'&` using hexadecimal escapes, now that they’re not handled
        // using named character references.
        string = string.replace(regexEscape, escapeBmpSymbol);
      }

      return string // Encode astral symbols.
      .replace(regexAstralSymbols, function ($0) {
        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        var high = $0.charCodeAt(0);
        var low = $0.charCodeAt(1);
        var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
        return escapeCodePoint(codePoint);
      }) // Encode any remaining BMP symbols that are not printable ASCII symbols
      // using a hexadecimal escape.
      .replace(regexBmpWhitelist, escapeBmpSymbol);
    }; // Expose default options (so they can be overridden globally).


    encode.options = {
      'allowUnsafeSymbols': false,
      'encodeEverything': false,
      'strict': false,
      'useNamedReferences': false,
      'decimal': false
    };

    var decode = function decode(html, options) {
      options = merge(options, decode.options);
      var strict = options.strict;

      if (strict && regexInvalidEntity.test(html)) {
        parseError('malformed character reference');
      }

      return html.replace(regexDecode, function ($0, $1, $2, $3, $4, $5, $6, $7, $8) {
        var codePoint;
        var semicolon;
        var decDigits;
        var hexDigits;
        var reference;
        var next;

        if ($1) {
          reference = $1; // Note: there is no need to check `has(decodeMap, reference)`.

          return decodeMap[reference];
        }

        if ($2) {
          // Decode named character references without trailing `;`, e.g. `&amp`.
          // This is only a parse error if it gets converted to `&`, or if it is
          // followed by `=` in an attribute context.
          reference = $2;
          next = $3;

          if (next && options.isAttributeValue) {
            if (strict && next == '=') {
              parseError('`&` did not start a character reference');
            }

            return $0;
          } else {
            if (strict) {
              parseError('named character reference was not terminated by a semicolon');
            } // Note: there is no need to check `has(decodeMapLegacy, reference)`.


            return decodeMapLegacy[reference] + (next || '');
          }
        }

        if ($4) {
          // Decode decimal escapes, e.g. `&#119558;`.
          decDigits = $4;
          semicolon = $5;

          if (strict && !semicolon) {
            parseError('character reference was not terminated by a semicolon');
          }

          codePoint = parseInt(decDigits, 10);
          return codePointToSymbol(codePoint, strict);
        }

        if ($6) {
          // Decode hexadecimal escapes, e.g. `&#x1D306;`.
          hexDigits = $6;
          semicolon = $7;

          if (strict && !semicolon) {
            parseError('character reference was not terminated by a semicolon');
          }

          codePoint = parseInt(hexDigits, 16);
          return codePointToSymbol(codePoint, strict);
        } // If we’re still here, `if ($7)` is implied; it’s an ambiguous
        // ampersand for sure. https://mths.be/notes/ambiguous-ampersands


        if (strict) {
          parseError('named character reference was not terminated by a semicolon');
        }

        return $0;
      });
    }; // Expose default options (so they can be overridden globally).


    decode.options = {
      'isAttributeValue': false,
      'strict': false
    };

    var escape = function escape(string) {
      return string.replace(regexEscape, function ($0) {
        // Note: there is no need to check `has(escapeMap, $0)` here.
        return escapeMap[$0];
      });
    };
    /*--------------------------------------------------------------------------*/


    var he = {
      'version': '1.2.0',
      'encode': encode,
      'decode': decode,
      'escape': escape,
      'unescape': decode
    }; // Some AMD build optimizers, like r.js, check for specific condition patterns
    // like the following:

    if (freeExports && !freeExports.nodeType) {
      if (freeModule) {
        // in Node.js, io.js, or RingoJS v0.8.0+
        freeModule.exports = he;
      } else {
        // in Narwhal or RingoJS v0.7.0-
        for (var key in he) {
          has(he, key) && (freeExports[key] = he[key]);
        }
      }
    } else {
      // in Rhino or a web browser
      root.he = he;
    }
  })(commonjsGlobal);
});

function processStr(str, offset, context, mode) {
  // traverse the value of this text node:
  for (var i = 0, len = str.length; i < len; i++) {
    if ((str[i].charCodeAt(0) > 127 || "<>\"&".includes(str[i])) && (str[i].charCodeAt(0) !== 160 || !Object.keys(context.processedRulesConfig).includes("bad-character-non-breaking-space") || !isAnEnabledValue(context.processedRulesConfig["bad-character-non-breaking-space"]))) {
      var encodedChr = he.encode(str[i], {
        useNamedReferences: mode === "named"
      });

      if (Object.keys(notEmailFriendly).includes(encodedChr.slice(1, encodedChr.length - 1))) {
        encodedChr = "&" + notEmailFriendly[encodedChr.slice(1, encodedChr.length - 1)] + ";";
      }
      var charName = "";

      if (str[i].charCodeAt(0) === 160) {
        charName = " no-break space";
      } else if (str[i].charCodeAt(0) === 38) {
        charName = " ampersand";
      } else if (str[i].charCodeAt(0) === 60) {
        charName = " less than";
      } else if (str[i].charCodeAt(0) === 62) {
        charName = " greater than";
      } else if (str[i].charCodeAt(0) === 34) {
        charName = " double quotes";
      } else if (str[i].charCodeAt(0) === 163) {
        charName = " pound sign";
      }

      context.report({
        ruleId: "character-encode",
        message: "Unencoded" + charName + " character.",
        idxFrom: i + offset,
        idxTo: i + 1 + offset,
        fix: {
          ranges: [[i + offset, i + 1 + offset, encodedChr]]
        }
      });
    }
  }
}

var characterEncode = function characterEncode(context) {
  for (var _len = arguments.length, opts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    opts[_key - 1] = arguments[_key];
  }

  return {
    text: function text(token) { // settle the mode, is it "always" or a default, "never"

      var mode = "named"; // opts array comes already sliced, without 1st element, so opts value
      // is 0th (and onwards if more)

      if (Array.isArray(opts) && ["named", "numeric"].includes(opts[0])) {
        mode = opts[0];
      } // ACTION

      processStr(token.value, token.start, context, mode);
    }
  };
};

function characterUnspacedPunctuation(context, originalOpts) {
  var charCodeMapping = {
    63: "questionMark",
    33: "exclamationMark",
    59: "semicolon",
    187: "rightDoubleAngleQuotMark",
    171: "leftDoubleAngleQuotMark"
  };
  return {
    text: function text(node) {
      var defaults = {
        questionMark: {
          whitespaceLeft: "never",
          whitespaceRight: "always"
        },
        exclamationMark: {
          whitespaceLeft: "never",
          whitespaceRight: "always"
        },
        semicolon: {
          whitespaceLeft: "never",
          whitespaceRight: "always"
        },
        rightDoubleAngleQuotMark: {
          whitespaceLeft: "never",
          whitespaceRight: "always"
        },
        leftDoubleAngleQuotMark: {
          whitespaceLeft: "never",
          whitespaceRight: "always"
        }
      };

      var opts = _objectSpread2(_objectSpread2({}, defaults), originalOpts); // plan: iterate each character from this text chunk/node, query each
      // caught character's surroundings as per config

      for (var i = node.start; i < node.end; i++) {
        var charCode = context.str[i].charCodeAt(0);

        if (charCodeMapping[String(charCode)]) {
          var charName = charCodeMapping[String(charCode)]; // precautions first.
          // if it's an exclamation mark and two dashes follow, we bail right away

          if (charName === "exclamationMark" && context.str[right(context.str, i)] === "-" && context.str[right(context.str, right(context.str, i))] === "-") {
            return;
          }

          if (opts[charName].whitespaceLeft === "never" && i && !context.str[i - 1].trim().length) {
            var idxFrom = left(context.str, i) ? left(context.str, i) + 1 : 0;
            context.report({
              ruleId: "character-unspaced-punctuation",
              idxFrom: idxFrom,
              idxTo: i,
              message: "Remove the whitespace.",
              fix: {
                ranges: [[idxFrom, i]]
              }
            });
          }

          if (opts[charName].whitespaceRight === "never" && i < node.end - 1 && !context.str[i + 1].trim().length) {
            context.report({
              ruleId: "character-unspaced-punctuation",
              idxFrom: i + 1,
              idxTo: right(context.str, i) || context.str.length,
              message: "Remove the whitespace.",
              fix: {
                ranges: [[i + 1, right(context.str, i) || context.str.length]]
              }
            });
          }

          if (opts[charName].whitespaceLeft === "always" && i && context.str[i - 1].trim().length) {
            context.report({
              ruleId: "character-unspaced-punctuation",
              idxFrom: i,
              idxTo: i + 1,
              message: "Add a space.",
              fix: {
                ranges: [[i, i, " "]]
              }
            });
          }

          if (opts[charName].whitespaceRight === "always" && i < node.end - 1 && context.str[i + 1].trim().length) {
            context.report({
              ruleId: "character-unspaced-punctuation",
              idxFrom: i,
              idxTo: i + 1,
              message: "Add a space.",
              fix: {
                ranges: [[i + 1, i + 1, " "]]
              }
            });
          }
        }
      }
    }
  };
}

// -----------------------------------------------------------------------------
// it tap the is-media-descriptor that we already use on tags
// to validate media query selectors, for example (rogue letter "e"):
// @media screeen {
//   ...
// }

function mediaMalformed(context) {
  return {
    at: function at(node) {

      if (node.identifier === "media") {
        var errors = isMediaD(node.query, {
          offset: node.queryStartsAt
        });
        errors.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "media-malformed"
          }));
        });
      } // if (node.tagName === "bold") {
      //   console.log(`037 RAISE ERROR [${node.start}, ${node.end}]`);
      //   context.report({
      //     ruleId: "media-malformed",
      //     message: `Tag "bold" does not exist in HTML.`,
      //     idxFrom: node.start,
      //     idxTo: node.end, // second elem. from last range
      //     fix: {
      //       ranges: [[node.tagNameStartsAt, node.tagNameEndsAt, suggested]]
      //     }
      //   });
      // }

    }
  };
}

function validateCommentClosing(token) {
  var reference = {
    simple: "-->",
    only: "<![endif]-->",
    not: "<!--<![endif]-->"
  }; // if all is fine, end quick

  if (token.kind === "simple" && token.value === "-->" || token.kind === "only" && token.value === "<![endif]-->" || token.kind === "not" && token.value === "<!--<![endif]-->") {
    return [];
  }

  var errorArr = []; // assemble string without whitespace:

  var valueWithoutWhitespace = ""; // first, tackle any inner whitespace

  splitByWhitespace(token.value, function (_ref) {
    var charFrom = _ref[0],
        charTo = _ref[1];
    valueWithoutWhitespace = "" + valueWithoutWhitespace + token.value.slice(charFrom, charTo);
  }, function (_ref2) {
    var whitespaceFrom = _ref2[0],
        whitespaceTo = _ref2[1];
    errorArr.push({
      ruleId: "comment-only-closing-malformed",
      idxFrom: token.start,
      idxTo: token.end,
      message: "Remove whitespace.",
      fix: {
        ranges: [[whitespaceFrom + token.start, whitespaceTo + token.start]]
      }
    });
  }); // if all it took was to remove some whitespace to get a correct value,
  // that's the end - return the "errorArr" with only whitespace ranges:

  if (token.kind === "simple" && valueWithoutWhitespace === "-->" || token.kind === "only" && valueWithoutWhitespace === "<![endif]-->" || token.kind === "not" && valueWithoutWhitespace === "<!--<![endif]-->") {
    return errorArr;
  } // if processing continues, it means something more is wrong
  errorArr.push({
    idxFrom: token.start,
    idxTo: token.end,
    message: "Malformed closing comment tag.",
    fix: {
      ranges: [[token.start, token.end, reference[token.kind]]]
    }
  });
  return errorArr;
}

function commentClosingMalformed(context) {
  return {
    comment: function comment(node) {

      if (node.closing) {
        // run the tag's value past the validator function
        var errorArr = validateCommentClosing(node) || []; // Out of all raised errors, only one can have "ranges.fix" -
        // all other fixes, if any present, will be removed.
        // This is to simplify the rule fix clashing.

        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            keepSeparateWhenFixing: true,
            ruleId: "comment-closing-malformed"
          }));
        });
      }
    }
  };
}

function validateCommentOpening(token) {
  var reference = {
    simple: /<!--/g,
    only: /<!--\[[^\]]+\]>/g,
    not: /<!--\[[^\]]+\]><!-->/g
  }; // if all is fine, end quick

  if (token.kind === "simple" && reference.simple.test(token.value) || token.kind === "only" && reference.only.test(token.value) || token.kind === "not" && reference.not.test(token.value)) {
    return [];
  }

  var errorArr = []; // assemble string without whitespace:

  var valueWithoutWhitespace = "";

  if (token.kind === "simple") { // first, tackle any inner whitespace

    splitByWhitespace(token.value, function (_ref) {
      var charFrom = _ref[0],
          charTo = _ref[1];
      valueWithoutWhitespace = "" + valueWithoutWhitespace + token.value.slice(charFrom, charTo);
    }, function (_ref2) {
      var whitespaceFrom = _ref2[0],
          whitespaceTo = _ref2[1];
      errorArr.push({
        idxFrom: token.start,
        idxTo: token.end,
        message: "Remove whitespace.",
        fix: {
          ranges: [[whitespaceFrom + token.start, whitespaceTo + token.start]]
        }
      });
    });
  } // if all it took was to remove some whitespace to get a correct value,
  // that's the end - return the "errorArr" with only whitespace ranges:

  if (token.kind === "simple" && reference.simple.test(valueWithoutWhitespace) || token.kind === "only" && reference.only.test(valueWithoutWhitespace) || token.kind === "not" && reference.not.test(valueWithoutWhitespace)) {
    return errorArr;
  } // if processing continues, it means something more is wrong
  var wrongBracketType = false; // check the opening tag's beginning:

  if (["only", "not"].includes(token.kind)) {
    // if beginning is malformed:
    findMalformed(token.value, "<!--[", function (_ref3) {
      var idxFrom = _ref3.idxFrom,
          idxTo = _ref3.idxTo;
      var finalIdxTo = idxTo; // take precaution, "not" type openings have very similar
      // ending, <!--> which will get caught as well here!

      if (idxFrom === token.start) {

        if ( // imagine, we searched for "<!--[" in "<!--{if !mso}><!-->" -
        // the idxTo is currently at "{" - search stopped at "{" and caught
        // only "<!--", the frontal part.
        // We check, maybe there's wrong type opening bracket, followed by "if"
        "{(".includes(token.value[idxTo]) && // and "if" follows
        matchRight(token.value, idxTo, "if", {
          trimBeforeMatching: true
        })) {
          wrongBracketType = true;
          finalIdxTo += 1;
        }

        errorArr.push({
          idxFrom: token.start,
          idxTo: token.end,
          message: "Malformed opening comment tag.",
          fix: {
            ranges: [[idxFrom + token.start, finalIdxTo + token.start, "<!--["]]
          }
        });
      }
    });
  } // check the ending part:


  if (token.kind === "not") { // if ending of the opening is malformed:

    findMalformed(token.value, "]><!-->", function (_ref4) {
      var idxFrom = _ref4.idxFrom,
          idxTo = _ref4.idxTo;
      var finalIdxFrom = idxFrom;

      if ("})".includes(token.value[idxFrom - 1]) && // also require that token would start with:
      // "<!--{if" or "<!--(if"
      wrongBracketType) {
        finalIdxFrom -= 1;
      }
      errorArr.push({
        idxFrom: token.start,
        idxTo: token.end,
        message: "Malformed opening comment tag.",
        fix: {
          ranges: [[finalIdxFrom + token.start, idxTo + token.start, "]><!-->"]]
        }
      });
    });
  } else if (token.kind === "only") { // plan: take the value, chomp all ">" and "]" characters
    // from the end of it, then if anything's suspicious,
    // replace all that with tight "]>".

    for (var i = token.value.length; i--;) {
      if (token.value[i].trim().length && !">]".includes(token.value[i])) {
        // if heads already report wrong bracket type, extend by one character
        // and remove that bracket too
        var rangeStart = i + 1;

        if ("})".includes(token.value[i]) && wrongBracketType) {
          rangeStart -= 1;
        }

        if (token.value.slice(i + 1) !== "]>") {
          errorArr.push({
            idxFrom: token.start,
            idxTo: token.end,
            message: "Malformed opening comment tag.",
            fix: {
              ranges: [[rangeStart + token.start, token.end, "]>"]]
            }
          });
        }

        break;
      }
    }
  }

  return errorArr;
}

function commentOpeningMalformed(context) {
  return {
    text: function text(node) {
      findMalformed(node.value, "<!--", function (errorObj) {
        context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
          message: "Malformed opening comment tag.",
          ruleId: "comment-opening-malformed",
          fix: {
            ranges: [[errorObj.idxFrom, errorObj.idxTo, "<!--"]]
          }
        }));
      }, {
        stringOffset: node.start
      });
    },
    comment: function comment(node) {

      if (!node.closing) {
        // run the tag's value past the validator function
        var errorArr = validateCommentOpening(node) || [];
        errorArr.forEach(function (errorObj) {
          context.report(_objectSpread2(_objectSpread2({}, errorObj), {}, {
            ruleId: "comment-opening-malformed"
          }));
        });
      }
    }
  };
}

// rule: comment-mismatching-pair

function commentMismatchingPair(context) {
  return {
    ast: function ast(node) { // we have raw AST, we need to traverse it and find mismatching-kind pairs
      // of type="comment" tokens, only-not or not-only

      traverse(node, // (key, val, innerObj, stop) => {
      function (key, val, innerObj) {
        var current = val !== undefined ? val : key;

        if (isObj(current)) {
          // monkey will traverse every key, every string within.
          // We need to pick the objects of a type we need: "comment"
          // console.log(
          //   `210 ██ ${`\u001b[${35}m${`linter/tagCb():`}\u001b[${39}m`} PING ${`\u001b[${33}m${`current`}\u001b[${39}m`} = ${JSON.stringify(
          //     current,
          //     null,
          //     4
          //   )}`
          // );
          if (current.type === "comment" && current.closing) {
            var previousToken = objectPath.get(node, pathPrev(innerObj.path));

            if (isObj(previousToken) && previousToken.type === "comment" && !previousToken.closing) {
              if (previousToken.kind === "not" && current.kind === "only") { // turn tail into "not"-kind, add front part (<!--)
                // Out of all raised errors, only one can have "ranges.fix" -
                // all other fixes, if any present, will be removed.
                // This is to simplify the rule fix clashing.

                context.report({
                  ruleId: "comment-mismatching-pair",
                  keepSeparateWhenFixing: true,
                  message: "Add \"<!--\".",
                  idxFrom: current.start,
                  idxTo: current.end,
                  fix: {
                    ranges: [[current.start, current.start, "<!--"]]
                  }
                });
              } else if (previousToken.kind === "only" && current.kind === "not") { // turn tail into "only"-kind, remove front part (<!--)
                // Out of all raised errors, only one can have "ranges.fix" -
                // all other fixes, if any present, will be removed.
                // This is to simplify the rule fix clashing.

                context.report({
                  ruleId: "comment-mismatching-pair",
                  keepSeparateWhenFixing: true,
                  message: "Remove \"<!--\".",
                  idxFrom: current.start,
                  idxTo: current.end,
                  fix: {
                    ranges: [[current.start, current.end, "<![endif]-->"]]
                  }
                });
              }
            }
          }
        }

        return current;
      });
    }
  };
}

// rule: comment-conditional-nested
// function commentConditionalNested(context, ...opts) {

function commentConditionalNested(context) {
  return {
    ast: function ast(node) {
      var pathsWithOpeningComments = [];
      traverse(node, // (key, val, innerObj, stop) => {
      function (key, val, innerObj) {
        var current = val !== undefined ? val : key;

        if (isObj(current)) {
          // monkey will traverse every key, every string within.
          // We need to pick the objects of a type we need: "comment"

          if (current.type === "comment") { // first, check, does any opening comment path strings match
            // the start of the current path - because if it is, it's nested
            // and should be reported

            if (pathsWithOpeningComments.some(function (pathStr) {
              return innerObj.path.startsWith(pathStr);
            })) {
              context.report({
                ruleId: "comment-conditional-nested",
                message: "Don't nest comments.",
                idxFrom: current.start,
                idxTo: current.end,
                fix: null
              });
            }

            if (!current.closing) {
              pathsWithOpeningComments.push(innerObj.path);
            }
          }
        }

        return current;
      });
    }
  };
}

// rule: email-td-sibling-padding
// -----------------------------------------------------------------------------
// prohibits use of CSS padding style on TD if sibling TD's are present
function tdSiblingPadding(context) {
  var start;
  var end;
  return {
    tag: function tag(node) {

      if ( // if this node is TR tag
      node.tagName === "tr" && // and it's got at least some some children tags
      Array.isArray(node.children) && // there are more than one TD children tags
      node.children.filter(function (tokenObj) {
        return tokenObj.type === "tag" && tokenObj.tagName === "td" && !tokenObj.closing;
      }).length > 1 && // any one of TD children tags contains a css style property "padding-*"
      node.children.some(function (tokenObj) {
        return tokenObj.type === "tag" && tokenObj.tagName === "td" && !tokenObj.closing && Array.isArray(tokenObj.attribs) && tokenObj.attribs.some(function (attribObj) {
          return attribObj.attribName === "style" && Array.isArray(attribObj.attribValue) && attribObj.attribValue.some(function (attribValueObj) {
            if (typeof attribValueObj.property === "string" && attribValueObj.property.startsWith("padding-")) {
              start = attribValueObj.start;
              end = attribValueObj.end;
              return true;
            }

            return false;
          });
        });
      })) {
        context.report({
          ruleId: "email-td-sibling-padding",
          message: "Don't set padding on TD when sibling TD's are present.",
          idxFrom: start,
          idxTo: end,
          fix: null
        });
      }
    }
  };
}

/**
 * We consume two types of nodes, HTML "style" attributes and head CSS style
 * tag "rule"s. We need to DRY the processing into one place.
 */
function processNode(token, context, mode) { // first let's set the properties array container, it might come
  // from different places, depending is it head CSS styles or inline HTML styles

  var nodeArr;

  if (token.properties !== undefined) {
    // head CSS rule
    nodeArr = token.properties;
  } else if (token.attribValue !== undefined) {
    // inline HTML style attribute
    nodeArr = token.attribValue;
  }

  if (!nodeArr) {
    return;
  } // extract all properties - arr array records
  // all whitespace are as text tokens and we want to exclude them
  // also there can be other types of nodes, comments or ESP tags if
  // it's inline HTML style attribute

  var properties = nodeArr.filter(function (property) {
    return property.property !== undefined;
  });
  var property = properties[~-properties.length];

  if (mode !== "never" && properties && properties.length && property.semi === null && property.valueEnds) {
    var idxFrom = property.start;
    var idxTo = property.end;
    var positionToInsert = property.importantEnds || property.valueEnds || property.propertyEnds;
    context.report({
      ruleId: "css-trailing-semi",
      idxFrom: idxFrom,
      idxTo: idxTo,
      message: "Add a semicolon.",
      fix: {
        ranges: [[positionToInsert, positionToInsert, ";"]]
      }
    });
  } else if (mode === "never" && properties && properties.length && property.semi !== null && property.valueEnds) {
    var _idxFrom = property.start;
    var _idxTo = property.end;
    var positionToRemove = property.semi;
    context.report({
      ruleId: "css-trailing-semi",
      idxFrom: _idxFrom,
      idxTo: _idxTo,
      message: "Remove the semicolon.",
      fix: {
        ranges: [[positionToRemove, positionToRemove + 1]]
      }
    });
  }
}

var trailingSemi = function trailingSemi(context, mode) {
  return {
    rule: function rule(node) {
      processNode(node, context, mode);
    },
    attribute: function attribute(node) {
      processNode(node, context, mode);
    }
  };
};

var cssRuleMalformed = function cssRuleMalformed(context) {
  return {
    rule: function rule(node) {

      if (Array.isArray(node.properties) && node.properties.length) {
        // validateStyle() will report errors into context directly
        validateStyle( // pass whole node, not just properties, because some errors
        // like <style>.a{;} can be indentified only by data on the token
        // root, like "node.openingCurlyAt" etc.
        node, context);
      }
    }
  };
};

// rule: format-prettier
// it tries to format to how Prettier would
// -----------------------------------------------------------------------------
function processCSS(token, context) {
  // group all CSS processing into one function
  var nodeArr;

  if (token.properties !== undefined) {
    // head CSS rule
    nodeArr = token.properties;
  } else if (token.attribValue !== undefined) {
    // inline HTML style attribute
    nodeArr = token.attribValue;
  }

  if (!nodeArr) {
    return;
  } // there can be text nodes within properties array!
  // a whitespace is still a text node!!!!

  nodeArr.filter(function (property) {
    return property.property !== undefined;
  }).forEach(function (property) {
    // console.log(
    //   `055 ${`\u001b[${32}m${`INCOMING`}\u001b[${39}m`} ${`\u001b[${33}m${`property`}\u001b[${39}m`} = ${JSON.stringify(
    //     property,
    //     null,
    //     4
    //   )}`
    // );
    // 1. missing space in after a colon
    if (property.colon && property.valueStarts && (property.valueStarts !== property.colon + 2 || context.str[property.colon + 1] !== " ")) {
      context.report({
        ruleId: "format-prettier",
        idxFrom: property.start,
        idxTo: property.end,
        message: "Put a space before a value.",
        fix: {
          ranges: [[property.colon + 1, property.valueStarts, " "]]
        }
      });
    } // 2. missing space after an !important


    var lastEnding = property.valueEnds || (property.colon ? property.colon + 1 : null) || property.propertyEnds;

    if (property.importantStarts && lastEnding && (lastEnding + 1 !== property.importantStarts || context.str[lastEnding] !== " ")) {
      context.report({
        ruleId: "format-prettier",
        idxFrom: property.start,
        idxTo: property.end,
        message: "Put a space in front of !imporant.",
        fix: {
          ranges: [[lastEnding, property.importantStarts, " "]]
        }
      });
    }
  }); // 3. space after semi
  // It's more complex because 1) space is added only between properties;
  // and 2) only if text of property token is in front - mind you, there
  // can be ESP tokens, comment tokens and so on. Hence we traverse "nodeArr".

  if (nodeArr.length > 1) {
    var somethingMet = false;

    for (var i = 0, len = nodeArr.length; i < len; i++) { // if it's text token, maybe it's whitespace, so enforce its value
      // to be a single space

      if (somethingMet && ( // it's a property
      nodeArr[i].property !== undefined || // or CSS comment
      nodeArr[i].type === "comment" && // and it's an opening comment
      !nodeArr[i].closing || // or ESP token
      nodeArr[i].type === "esp" && // two tokens in front it's a property
      nodeArr[i - 2] && nodeArr[i - 2].property !== undefined) && // and it's text in front
      nodeArr[i - 1].type === "text" && nodeArr[i - 1].value !== " ") {
        context.report({
          ruleId: "format-prettier",
          idxFrom: nodeArr[i - 1].start,
          idxTo: nodeArr[i - 1].end,
          message: "Put a space in front of !imporant.",
          fix: {
            ranges: [[nodeArr[i - 1].start, nodeArr[i - 1].end, " "]]
          }
        });
      } else if ( // we're not at the first token (zero'th element will be falsey)
      i && // it's not a text token in front
      !["text", "esp"].includes(nodeArr[i - 1].type) && // and it's a property currently here
      nodeArr[i].property !== undefined && ( // it's not blank:
      // <style>.a{;;}</style><body>a</body>
      //           ^^
      nodeArr[i].property || nodeArr[i].value || nodeArr[i].important)) {
        // then it's an issue right away because if there was a whitespace gap,
        // it would be a text token
        context.report({
          ruleId: "format-prettier",
          idxFrom: nodeArr[i].start,
          idxTo: nodeArr[i].end,
          message: "Put a space in front.",
          fix: {
            ranges: [[nodeArr[i].start, nodeArr[i].start, " "]]
          }
        });
      }

      if (!somethingMet && (nodeArr[i].type === undefined || nodeArr[i].type !== "text")) {
        somethingMet = true;
      }
    }
  }
}

var formatPrettier = function formatPrettier(context) {
  return {
    rule: function rule(node) { // format the head CSS style rule

      processCSS(node, context);
    },
    attribute: function attribute(node) { // format the inline HTML style attribute CSS rules

      processCSS(node, context);
    }
  };
};

// here we fetch the rules from all the places,
var builtInRules = {};
defineLazyProp(builtInRules, "bad-character-null", function () {
  return badCharacterNull;
});
defineLazyProp(builtInRules, "bad-character-start-of-heading", function () {
  return badCharacterStartOfHeading;
});
defineLazyProp(builtInRules, "bad-character-start-of-text", function () {
  return badCharacterStartOfText;
});
defineLazyProp(builtInRules, "bad-character-end-of-text", function () {
  return badCharacterEndOfText;
});
defineLazyProp(builtInRules, "bad-character-end-of-transmission", function () {
  return badCharacterEndOfTransmission;
});
defineLazyProp(builtInRules, "bad-character-enquiry", function () {
  return badCharacterEnquiry;
});
defineLazyProp(builtInRules, "bad-character-acknowledge", function () {
  return badCharacterAcknowledge;
});
defineLazyProp(builtInRules, "bad-character-bell", function () {
  return badCharacterBell;
});
defineLazyProp(builtInRules, "bad-character-backspace", function () {
  return badCharacterBackspace;
});
defineLazyProp(builtInRules, "bad-character-tabulation", function () {
  return badCharacterTabulation;
});
defineLazyProp(builtInRules, "bad-character-line-tabulation", function () {
  return badCharacterLineTabulation;
});
defineLazyProp(builtInRules, "bad-character-form-feed", function () {
  return badCharacterFormFeed;
});
defineLazyProp(builtInRules, "bad-character-shift-out", function () {
  return badCharacterShiftOut;
});
defineLazyProp(builtInRules, "bad-character-shift-in", function () {
  return badCharacterShiftIn;
});
defineLazyProp(builtInRules, "bad-character-data-link-escape", function () {
  return badCharacterDataLinkEscape;
});
defineLazyProp(builtInRules, "bad-character-device-control-one", function () {
  return badCharacterDeviceControlOne;
});
defineLazyProp(builtInRules, "bad-character-device-control-two", function () {
  return badCharacterDeviceControlTwo;
});
defineLazyProp(builtInRules, "bad-character-device-control-three", function () {
  return badCharacterDeviceControlThree;
});
defineLazyProp(builtInRules, "bad-character-device-control-four", function () {
  return badCharacterDeviceControlFour;
});
defineLazyProp(builtInRules, "bad-character-negative-acknowledge", function () {
  return badCharacterNegativeAcknowledge;
});
defineLazyProp(builtInRules, "bad-character-synchronous-idle", function () {
  return badCharacterSynchronousIdle;
});
defineLazyProp(builtInRules, "bad-character-end-of-transmission-block", function () {
  return badCharacterEndOfTransmissionBlock;
});
defineLazyProp(builtInRules, "bad-character-cancel", function () {
  return badCharacterCancel;
});
defineLazyProp(builtInRules, "bad-character-end-of-medium", function () {
  return badCharacterEndOfMedium;
});
defineLazyProp(builtInRules, "bad-character-substitute", function () {
  return badCharacterSubstitute;
});
defineLazyProp(builtInRules, "bad-character-escape", function () {
  return badCharacterEscape;
});
defineLazyProp(builtInRules, "bad-character-information-separator-four", function () {
  return badCharacterInformationSeparatorFour;
});
defineLazyProp(builtInRules, "bad-character-information-separator-three", function () {
  return badCharacterInformationSeparatorThree;
});
defineLazyProp(builtInRules, "bad-character-information-separator-two", function () {
  return badCharacterInformationSeparatorTwo$1;
});
defineLazyProp(builtInRules, "bad-character-information-separator-one", function () {
  return badCharacterInformationSeparatorTwo;
});
defineLazyProp(builtInRules, "bad-character-delete", function () {
  return badCharacterDelete;
});
defineLazyProp(builtInRules, "bad-character-control-0080", function () {
  return badCharacterControl0080;
});
defineLazyProp(builtInRules, "bad-character-control-0081", function () {
  return badCharacterControl0081;
});
defineLazyProp(builtInRules, "bad-character-break-permitted-here", function () {
  return badCharacterBreakPermittedHere;
});
defineLazyProp(builtInRules, "bad-character-no-break-here", function () {
  return badCharacterNoBreakHere;
});
defineLazyProp(builtInRules, "bad-character-control-0084", function () {
  return badCharacterControl0084;
});
defineLazyProp(builtInRules, "bad-character-next-line", function () {
  return badCharacterNextLine;
});
defineLazyProp(builtInRules, "bad-character-start-of-selected-area", function () {
  return badCharacterStartOfSelectedArea;
});
defineLazyProp(builtInRules, "bad-character-end-of-selected-area", function () {
  return badCharacterEndOfSelectedArea;
});
defineLazyProp(builtInRules, "bad-character-character-tabulation-set", function () {
  return badCharacterCharacterTabulationSet;
});
defineLazyProp(builtInRules, "bad-character-character-tabulation-with-justification", function () {
  return badCharacterCharacterTabulationWithJustification;
});
defineLazyProp(builtInRules, "bad-character-line-tabulation-set", function () {
  return badCharacterLineTabulationSet;
});
defineLazyProp(builtInRules, "bad-character-partial-line-forward", function () {
  return badCharacterPartialLineForward;
});
defineLazyProp(builtInRules, "bad-character-partial-line-backward", function () {
  return badCharacterPartialLineBackward;
});
defineLazyProp(builtInRules, "bad-character-reverse-line-feed", function () {
  return badCharacterReverseLineFeed;
});
defineLazyProp(builtInRules, "bad-character-single-shift-two", function () {
  return badCharacterSingleShiftTwo$1;
});
defineLazyProp(builtInRules, "bad-character-single-shift-three", function () {
  return badCharacterSingleShiftTwo;
});
defineLazyProp(builtInRules, "bad-character-device-control-string", function () {
  return badCharacterDeviceControlString;
});
defineLazyProp(builtInRules, "bad-character-private-use-1", function () {
  return badCharacterPrivateUseOne;
});
defineLazyProp(builtInRules, "bad-character-private-use-2", function () {
  return badCharacterPrivateUseTwo;
});
defineLazyProp(builtInRules, "bad-character-set-transmit-state", function () {
  return badCharacterSetTransmitState;
});
defineLazyProp(builtInRules, "bad-character-cancel-character", function () {
  return badCharacterCancelCharacter;
});
defineLazyProp(builtInRules, "bad-character-message-waiting", function () {
  return badCharacterMessageWaiting;
});
defineLazyProp(builtInRules, "bad-character-start-of-protected-area", function () {
  return badCharacterStartOfProtectedArea;
});
defineLazyProp(builtInRules, "bad-character-end-of-protected-area", function () {
  return badCharacterEndOfProtectedArea;
});
defineLazyProp(builtInRules, "bad-character-start-of-string", function () {
  return badCharacterStartOfString;
});
defineLazyProp(builtInRules, "bad-character-control-0099", function () {
  return badCharacterControl0099;
});
defineLazyProp(builtInRules, "bad-character-single-character-introducer", function () {
  return badCharacterSingleCharacterIntroducer;
});
defineLazyProp(builtInRules, "bad-character-control-sequence-introducer", function () {
  return badCharacterControlSequenceIntroducer;
});
defineLazyProp(builtInRules, "bad-character-string-terminator", function () {
  return badCharacterStringTerminator;
});
defineLazyProp(builtInRules, "bad-character-operating-system-command", function () {
  return badCharacterOperatingSystemCommand;
});
defineLazyProp(builtInRules, "bad-character-private-message", function () {
  return badCharacterPrivateMessage;
});
defineLazyProp(builtInRules, "bad-character-application-program-command", function () {
  return badCharacterApplicationProgramCommand;
});
defineLazyProp(builtInRules, "bad-character-soft-hyphen", function () {
  return badCharacterSoftHyphen;
});
defineLazyProp(builtInRules, "bad-character-non-breaking-space", function () {
  return badCharacterNonBreakingSpace;
});
defineLazyProp(builtInRules, "bad-character-ogham-space-mark", function () {
  return badCharacterOghamSpaceMark;
});
defineLazyProp(builtInRules, "bad-character-en-quad", function () {
  return badCharacterEnQuad;
});
defineLazyProp(builtInRules, "bad-character-em-quad", function () {
  return badCharacterEmQuad;
});
defineLazyProp(builtInRules, "bad-character-en-space", function () {
  return badCharacterEnSpace;
});
defineLazyProp(builtInRules, "bad-character-em-space", function () {
  return badCharacterEmSpace;
});
defineLazyProp(builtInRules, "bad-character-three-per-em-space", function () {
  return badCharacterThreePerEmSpace;
});
defineLazyProp(builtInRules, "bad-character-four-per-em-space", function () {
  return badCharacterFourPerEmSpace;
});
defineLazyProp(builtInRules, "bad-character-six-per-em-space", function () {
  return badCharacterSixPerEmSpace;
});
defineLazyProp(builtInRules, "bad-character-figure-space", function () {
  return badCharacterFigureSpace;
});
defineLazyProp(builtInRules, "bad-character-punctuation-space", function () {
  return badCharacterPunctuationSpace;
});
defineLazyProp(builtInRules, "bad-character-thin-space", function () {
  return badCharacterThinSpace;
});
defineLazyProp(builtInRules, "bad-character-hair-space", function () {
  return badCharacterHairSpace;
});
defineLazyProp(builtInRules, "bad-character-zero-width-space", function () {
  return badCharacterZeroWidthSpace;
});
defineLazyProp(builtInRules, "bad-character-zero-width-non-joiner", function () {
  return badCharacterZeroWidthNonJoiner;
});
defineLazyProp(builtInRules, "bad-character-zero-width-joiner", function () {
  return badCharacterZeroWidthJoiner;
});
defineLazyProp(builtInRules, "bad-character-left-to-right-mark", function () {
  return badCharacterLeftToRightMark;
});
defineLazyProp(builtInRules, "bad-character-right-to-left-mark", function () {
  return badCharacterRightToLeftMark;
});
defineLazyProp(builtInRules, "bad-character-left-to-right-embedding", function () {
  return badCharacterLeftToRightEmbedding;
});
defineLazyProp(builtInRules, "bad-character-right-to-left-embedding", function () {
  return badCharacterRightToLeftEmbedding;
});
defineLazyProp(builtInRules, "bad-character-pop-directional-formatting", function () {
  return badCharacterPopDirectionalFormatting;
});
defineLazyProp(builtInRules, "bad-character-left-to-right-override", function () {
  return badCharacterLeftToRightOverride;
});
defineLazyProp(builtInRules, "bad-character-right-to-left-override", function () {
  return badCharacterRightToLeftOverride;
});
defineLazyProp(builtInRules, "bad-character-word-joiner", function () {
  return badCharacterWordJoiner;
});
defineLazyProp(builtInRules, "bad-character-function-application", function () {
  return badCharacterFunctionApplication;
});
defineLazyProp(builtInRules, "bad-character-invisible-times", function () {
  return badCharacterInvisibleTimes;
});
defineLazyProp(builtInRules, "bad-character-invisible-separator", function () {
  return badCharacterInvisibleSeparator;
});
defineLazyProp(builtInRules, "bad-character-invisible-plus", function () {
  return badCharacterInvisiblePlus;
});
defineLazyProp(builtInRules, "bad-character-left-to-right-isolate", function () {
  return badCharacterLeftToRightIsolate;
});
defineLazyProp(builtInRules, "bad-character-right-to-left-isolate", function () {
  return badCharacterRightToLeftIsolate;
});
defineLazyProp(builtInRules, "bad-character-first-strong-isolate", function () {
  return badCharacterFirstStrongIsolate;
});
defineLazyProp(builtInRules, "bad-character-pop-directional-isolate", function () {
  return badCharacterPopDirectionalIsolate;
});
defineLazyProp(builtInRules, "bad-character-inhibit-symmetric-swapping", function () {
  return badCharacterInhibitSymmetricSwapping;
});
defineLazyProp(builtInRules, "bad-character-activate-symmetric-swapping", function () {
  return badCharacterActivateSymmetricSwapping;
});
defineLazyProp(builtInRules, "bad-character-inhibit-arabic-form-shaping", function () {
  return badCharacterInhibitArabicFormShaping;
});
defineLazyProp(builtInRules, "bad-character-activate-arabic-form-shaping", function () {
  return badCharacterActivateArabicFormShaping;
});
defineLazyProp(builtInRules, "bad-character-national-digit-shapes", function () {
  return badCharacterNationalDigitShapes;
});
defineLazyProp(builtInRules, "bad-character-nominal-digit-shapes", function () {
  return badCharacterNominalDigitShapes;
});
defineLazyProp(builtInRules, "bad-character-zero-width-no-break-space", function () {
  return badCharacterZeroWidthNoBreakSpace;
});
defineLazyProp(builtInRules, "bad-character-interlinear-annotation-anchor", function () {
  return badCharacterInterlinearAnnotationAnchor;
});
defineLazyProp(builtInRules, "bad-character-interlinear-annotation-separator", function () {
  return badCharacterInterlinearAnnotationSeparator;
});
defineLazyProp(builtInRules, "bad-character-interlinear-annotation-terminator", function () {
  return badCharacterInterlinearAnnotationTerminator;
});
defineLazyProp(builtInRules, "bad-character-line-separator", function () {
  return badCharacterLineSeparator;
});
defineLazyProp(builtInRules, "bad-character-paragraph-separator", function () {
  return badCharacterParagraphSeparator;
});
defineLazyProp(builtInRules, "bad-character-narrow-no-break-space", function () {
  return badCharacterNarrowNoBreakSpace;
});
defineLazyProp(builtInRules, "bad-character-medium-mathematical-space", function () {
  return badCharacterMediumMathematicalSpace;
});
defineLazyProp(builtInRules, "bad-character-ideographic-space", function () {
  return badCharacterIdeographicSpace;
});
defineLazyProp(builtInRules, "bad-character-replacement-character", function () {
  return badCharacterReplacementCharacter;
}); // TAG rules
// -----------------------------------------------------------------------------

defineLazyProp(builtInRules, "tag-space-after-opening-bracket", function () {
  return tagSpaceAfterOpeningBracket;
});
defineLazyProp(builtInRules, "tag-space-before-closing-bracket", function () {
  return tagSpaceBeforeClosingBracket;
});
defineLazyProp(builtInRules, "tag-space-between-slash-and-bracket", function () {
  return tagSpaceBetweenSlashAndBracket;
});
defineLazyProp(builtInRules, "tag-table", function () {
  return tagTable;
});
defineLazyProp(builtInRules, "tag-malformed", function () {
  return tagMalformed;
});
defineLazyProp(builtInRules, "tag-closing-backslash", function () {
  return tagClosingBackslash;
});
defineLazyProp(builtInRules, "tag-void-slash", function () {
  return tagVoidSlash;
});
defineLazyProp(builtInRules, "tag-name-case", function () {
  return tagNameCase;
});
defineLazyProp(builtInRules, "tag-is-present", function () {
  return tagIsPresent;
});
defineLazyProp(builtInRules, "tag-bold", function () {
  return tagBold;
});
defineLazyProp(builtInRules, "tag-bad-self-closing", function () {
  return tagBadSelfClosing;
});
defineLazyProp(builtInRules, "attribute-duplicate", function () {
  return attributeDuplicate;
});
defineLazyProp(builtInRules, "attribute-malformed", function () {
  return attributeMalformed;
});
defineLazyProp(builtInRules, "attribute-on-closing-tag", function () {
  return attributeOnClosingTag;
});
defineLazyProp(builtInRules, "attribute-enforce-img-alt", function () {
  return attributeEnforceImgAlt;
});
defineLazyProp(builtInRules, "attribute-validate-abbr", function () {
  return attributeValidateAbbr;
});
defineLazyProp(builtInRules, "attribute-validate-accept-charset", function () {
  return attributeValidateAcceptCharset;
});
defineLazyProp(builtInRules, "attribute-validate-accept", function () {
  return attributeValidateAccept;
});
defineLazyProp(builtInRules, "attribute-validate-accesskey", function () {
  return attributeValidateAccesskey;
});
defineLazyProp(builtInRules, "attribute-validate-action", function () {
  return attributeValidateAction;
});
defineLazyProp(builtInRules, "attribute-validate-align", function () {
  return attributeValidateAlign;
});
defineLazyProp(builtInRules, "attribute-validate-alink", function () {
  return attributeValidateAlink;
});
defineLazyProp(builtInRules, "attribute-validate-alt", function () {
  return attributeValidateAlt;
});
defineLazyProp(builtInRules, "attribute-validate-archive", function () {
  return attributeValidateArchive;
});
defineLazyProp(builtInRules, "attribute-validate-axis", function () {
  return attributeValidateAxis;
});
defineLazyProp(builtInRules, "attribute-validate-background", function () {
  return attributeValidateBackground;
});
defineLazyProp(builtInRules, "attribute-validate-bgcolor", function () {
  return attributeValidateBgcolor;
});
defineLazyProp(builtInRules, "attribute-validate-border", function () {
  return attributeValidateBorder;
});
defineLazyProp(builtInRules, "attribute-validate-cellpadding", function () {
  return attributeValidateCellpadding;
});
defineLazyProp(builtInRules, "attribute-validate-cellspacing", function () {
  return attributeValidateCellspacing;
});
defineLazyProp(builtInRules, "attribute-validate-char", function () {
  return attributeValidateChar;
});
defineLazyProp(builtInRules, "attribute-validate-charoff", function () {
  return attributeValidateCharoff;
});
defineLazyProp(builtInRules, "attribute-validate-charset", function () {
  return attributeValidateCharset;
});
defineLazyProp(builtInRules, "attribute-validate-checked", function () {
  return attributeValidateChecked;
});
defineLazyProp(builtInRules, "attribute-validate-cite", function () {
  return attributeValidateCite;
});
defineLazyProp(builtInRules, "attribute-validate-class", function () {
  return attributeValidateClass;
});
defineLazyProp(builtInRules, "attribute-validate-classid", function () {
  return attributeValidateClassid$1;
});
defineLazyProp(builtInRules, "attribute-validate-clear", function () {
  return attributeValidateClassid;
});
defineLazyProp(builtInRules, "attribute-validate-code", function () {
  return attributeValidateCode;
});
defineLazyProp(builtInRules, "attribute-validate-codebase", function () {
  return attributeValidateCodebase;
});
defineLazyProp(builtInRules, "attribute-validate-codetype", function () {
  return attributeValidateCodetype;
});
defineLazyProp(builtInRules, "attribute-validate-color", function () {
  return attributeValidateColor;
});
defineLazyProp(builtInRules, "attribute-validate-cols", function () {
  return attributeValidateCols;
});
defineLazyProp(builtInRules, "attribute-validate-colspan", function () {
  return attributeValidateColspan;
});
defineLazyProp(builtInRules, "attribute-validate-compact", function () {
  return attributeValidateCompact;
});
defineLazyProp(builtInRules, "attribute-validate-content", function () {
  return attributeValidateContent;
});
defineLazyProp(builtInRules, "attribute-validate-coords", function () {
  return attributeValidateCoords;
});
defineLazyProp(builtInRules, "attribute-validate-data", function () {
  return attributeValidateData;
});
defineLazyProp(builtInRules, "attribute-validate-datetime", function () {
  return attributeValidateDatetime;
});
defineLazyProp(builtInRules, "attribute-validate-declare", function () {
  return attributeValidateDeclare;
});
defineLazyProp(builtInRules, "attribute-validate-defer", function () {
  return attributeValidateDefer;
});
defineLazyProp(builtInRules, "attribute-validate-dir", function () {
  return attributeValidateDir;
});
defineLazyProp(builtInRules, "attribute-validate-disabled", function () {
  return attributeValidateDisabled;
});
defineLazyProp(builtInRules, "attribute-validate-enctype", function () {
  return attributeValidateEnctype;
});
defineLazyProp(builtInRules, "attribute-validate-face", function () {
  return attributeValidateFace;
});
defineLazyProp(builtInRules, "attribute-validate-for", function () {
  return attributeValidateFor;
});
defineLazyProp(builtInRules, "attribute-validate-frame", function () {
  return attributeValidateFrame;
});
defineLazyProp(builtInRules, "attribute-validate-frameborder", function () {
  return attributeValidateFrameborder;
});
defineLazyProp(builtInRules, "attribute-validate-headers", function () {
  return attributeValidateHeaders;
});
defineLazyProp(builtInRules, "attribute-validate-height", function () {
  return attributeValidateHeight;
});
defineLazyProp(builtInRules, "attribute-validate-href", function () {
  return attributeValidateHref;
});
defineLazyProp(builtInRules, "attribute-validate-hreflang", function () {
  return attributeValidateHreflang;
});
defineLazyProp(builtInRules, "attribute-validate-hspace", function () {
  return attributeValidateHspace;
});
defineLazyProp(builtInRules, "attribute-validate-http-equiv", function () {
  return attributeValidateHttpequiv;
});
defineLazyProp(builtInRules, "attribute-validate-id", function () {
  return attributeValidateId;
});
defineLazyProp(builtInRules, "attribute-validate-ismap", function () {
  return attributeValidateIsmap;
});
defineLazyProp(builtInRules, "attribute-validate-label", function () {
  return attributeValidateLabel;
});
defineLazyProp(builtInRules, "attribute-validate-lang", function () {
  return attributeValidateLang;
});
defineLazyProp(builtInRules, "attribute-validate-language", function () {
  return attributeValidateLanguage;
});
defineLazyProp(builtInRules, "attribute-validate-link", function () {
  return attributeValidateLink;
});
defineLazyProp(builtInRules, "attribute-validate-longdesc", function () {
  return attributeValidateLongdesc;
});
defineLazyProp(builtInRules, "attribute-validate-marginheight", function () {
  return attributeValidateMarginheight;
});
defineLazyProp(builtInRules, "attribute-validate-marginwidth", function () {
  return attributeValidateMarginwidth;
});
defineLazyProp(builtInRules, "attribute-validate-maxlength", function () {
  return attributeValidateMaxlength;
});
defineLazyProp(builtInRules, "attribute-validate-media", function () {
  return attributeValidateMedia;
});
defineLazyProp(builtInRules, "attribute-validate-method", function () {
  return attributeValidateMethod;
});
defineLazyProp(builtInRules, "attribute-validate-multiple", function () {
  return attributeValidateMultiple;
});
defineLazyProp(builtInRules, "attribute-validate-name", function () {
  return attributeValidateName;
});
defineLazyProp(builtInRules, "attribute-validate-nohref", function () {
  return attributeValidateNohref;
});
defineLazyProp(builtInRules, "attribute-validate-noresize", function () {
  return attributeValidateNoresize;
});
defineLazyProp(builtInRules, "attribute-validate-noshade", function () {
  return attributeValidateNoshade;
});
defineLazyProp(builtInRules, "attribute-validate-nowrap", function () {
  return attributeValidateNowrap;
});
defineLazyProp(builtInRules, "attribute-validate-object", function () {
  return attributeValidateObject;
});
defineLazyProp(builtInRules, "attribute-validate-onblur", function () {
  return attributeValidateOnblur;
});
defineLazyProp(builtInRules, "attribute-validate-onchange", function () {
  return attributeValidateOnchange;
});
defineLazyProp(builtInRules, "attribute-validate-onclick", function () {
  return attributeValidateOnclick;
});
defineLazyProp(builtInRules, "attribute-validate-ondblclick", function () {
  return attributeValidateOndblclick;
});
defineLazyProp(builtInRules, "attribute-validate-onfocus", function () {
  return attributeValidateOnfocus;
});
defineLazyProp(builtInRules, "attribute-validate-onkeydown", function () {
  return attributeValidateOnkeydown;
});
defineLazyProp(builtInRules, "attribute-validate-onkeypress", function () {
  return attributeValidateOnkeypress;
});
defineLazyProp(builtInRules, "attribute-validate-onkeyup", function () {
  return attributeValidateOnkeyup;
});
defineLazyProp(builtInRules, "attribute-validate-onload", function () {
  return attributeValidateOnload;
});
defineLazyProp(builtInRules, "attribute-validate-onmousedown", function () {
  return attributeValidateOnmousedown;
});
defineLazyProp(builtInRules, "attribute-validate-onmousemove", function () {
  return attributeValidateOnmousemove;
});
defineLazyProp(builtInRules, "attribute-validate-onmouseout", function () {
  return attributeValidateOnmouseout;
});
defineLazyProp(builtInRules, "attribute-validate-onmouseover", function () {
  return attributeValidateOnmouseover;
});
defineLazyProp(builtInRules, "attribute-validate-onmouseup", function () {
  return attributeValidateOnmouseup;
});
defineLazyProp(builtInRules, "attribute-validate-onreset", function () {
  return attributeValidateOnreset;
});
defineLazyProp(builtInRules, "attribute-validate-onsubmit", function () {
  return attributeValidateOnsubmit;
});
defineLazyProp(builtInRules, "attribute-validate-onselect", function () {
  return attributeValidateOnselect;
});
defineLazyProp(builtInRules, "attribute-validate-onunload", function () {
  return attributeValidateOnunload;
});
defineLazyProp(builtInRules, "attribute-validate-profile", function () {
  return attributeValidateProfile;
});
defineLazyProp(builtInRules, "attribute-validate-prompt", function () {
  return attributeValidatePrompt;
});
defineLazyProp(builtInRules, "attribute-validate-readonly", function () {
  return attributeValidateReadonly;
});
defineLazyProp(builtInRules, "attribute-validate-rel", function () {
  return attributeValidateRel;
});
defineLazyProp(builtInRules, "attribute-validate-rev", function () {
  return attributeValidateRev;
});
defineLazyProp(builtInRules, "attribute-validate-rows", function () {
  return attributeValidateRows;
});
defineLazyProp(builtInRules, "attribute-validate-rowspan", function () {
  return attributeValidateRowspan;
});
defineLazyProp(builtInRules, "attribute-validate-rules", function () {
  return attributeValidateRules;
});
defineLazyProp(builtInRules, "attribute-validate-scheme", function () {
  return attributeValidateScheme;
});
defineLazyProp(builtInRules, "attribute-validate-scope", function () {
  return attributeValidateScope;
});
defineLazyProp(builtInRules, "attribute-validate-scrolling", function () {
  return attributeValidateScrolling;
});
defineLazyProp(builtInRules, "attribute-validate-selected", function () {
  return attributeValidateSelected;
});
defineLazyProp(builtInRules, "attribute-validate-shape", function () {
  return attributeValidateShape;
});
defineLazyProp(builtInRules, "attribute-validate-size", function () {
  return attributeValidateSize;
});
defineLazyProp(builtInRules, "attribute-validate-span", function () {
  return attributeValidateSpan;
});
defineLazyProp(builtInRules, "attribute-validate-src", function () {
  return attributeValidateSrc;
});
defineLazyProp(builtInRules, "attribute-validate-standby", function () {
  return attributeValidateStandby;
});
defineLazyProp(builtInRules, "attribute-validate-start", function () {
  return attributeValidateStart;
});
defineLazyProp(builtInRules, "attribute-validate-style", function () {
  return attributeValidateStyle;
});
defineLazyProp(builtInRules, "attribute-validate-summary", function () {
  return attributeValidateSummary;
});
defineLazyProp(builtInRules, "attribute-validate-tabindex", function () {
  return attributeValidateTabindex;
});
defineLazyProp(builtInRules, "attribute-validate-target", function () {
  return attributeValidateTarget;
});
defineLazyProp(builtInRules, "attribute-validate-text", function () {
  return attributeValidateText;
});
defineLazyProp(builtInRules, "attribute-validate-title", function () {
  return attributeValidateTitle;
});
defineLazyProp(builtInRules, "attribute-validate-type", function () {
  return attributeValidateType;
});
defineLazyProp(builtInRules, "attribute-validate-usemap", function () {
  return attributeValidateUsemap;
});
defineLazyProp(builtInRules, "attribute-validate-valign", function () {
  return attributeValidateValign;
});
defineLazyProp(builtInRules, "attribute-validate-value", function () {
  return attributeValidateValue;
});
defineLazyProp(builtInRules, "attribute-validate-valuetype", function () {
  return attributeValidateValuetype;
});
defineLazyProp(builtInRules, "attribute-validate-version", function () {
  return attributeValidateVersion;
});
defineLazyProp(builtInRules, "attribute-validate-vlink", function () {
  return attributeValidateVlink;
});
defineLazyProp(builtInRules, "attribute-validate-vspace", function () {
  return attributeValidateVspace;
});
defineLazyProp(builtInRules, "attribute-validate-width", function () {
  return attributeValidateWidth;
});
defineLazyProp(builtInRules, "bad-named-html-entity-not-email-friendly", function () {
  return htmlEntitiesNotEmailFriendly;
});
defineLazyProp(builtInRules, "character-encode", function () {
  return characterEncode;
});
defineLazyProp(builtInRules, "character-unspaced-punctuation", function () {
  return characterUnspacedPunctuation;
});
defineLazyProp(builtInRules, "media-malformed", function () {
  return mediaMalformed;
});
defineLazyProp(builtInRules, "comment-closing-malformed", function () {
  return commentClosingMalformed;
});
defineLazyProp(builtInRules, "comment-opening-malformed", function () {
  return commentOpeningMalformed;
});
defineLazyProp(builtInRules, "comment-mismatching-pair", function () {
  return commentMismatchingPair;
});
defineLazyProp(builtInRules, "comment-conditional-nested", function () {
  return commentConditionalNested;
}); // EMAIL rules
// -----------------------------------------------------------------------------

defineLazyProp(builtInRules, "email-td-sibling-padding", function () {
  return tdSiblingPadding;
}); // CSS rules
// -----------------------------------------------------------------------------

defineLazyProp(builtInRules, "css-trailing-semi", function () {
  return trailingSemi;
});
defineLazyProp(builtInRules, "css-rule-malformed", function () {
  return cssRuleMalformed;
}); // Formatting rules
// -----------------------------------------------------------------------------

defineLazyProp(builtInRules, "format-prettier", function () {
  return formatPrettier;
}); // EXPORTS
// -----------------------------------------------------------------------------

function get(something) {
  return builtInRules[something];
} // it expands the grouped rules, such as "bad-character", then
// removes the grouped rule so that only real, single rules
// are passed to Linter


function normaliseRequestedRules(opts) {
  // console.log(
  //   `870 normaliseRequestedRules() RECEIVED: ${`\u001b[${33}m${`opts`}\u001b[${39}m`} = ${JSON.stringify(
  //     opts,
  //     null,
  //     4
  //   )}`
  // );
  var res = {}; // first, if there are known group rules such as "bad-character", set
  // them as a foundation:

  if (Object.keys(opts).includes("all") && isAnEnabledValue(opts.all)) {
    Object.keys(builtInRules).forEach(function (ruleName) {
      res[ruleName] = opts.all;
    });
  } else {
    var temp;

    if (Object.keys(opts).some(function (ruleName) {
      if (["bad-character", "bad-character*", "bad-character-*"].includes(ruleName)) {
        temp = ruleName;
        return true;
      }

      return false;
    })) {
      allBadCharacterRules.forEach(function (ruleName) {
        res[ruleName] = opts[temp];
      });
    }

    if (Object.keys(opts).some(function (ruleName) {
      if (["tag", "tag*", "tag-*"].includes(ruleName)) {
        temp = ruleName;
        return true;
      }

      return false;
    })) {
      allTagRules.forEach(function (ruleName) {
        res[ruleName] = opts[temp];
      });
    }

    if (Object.keys(opts).some(function (ruleName) {
      if (["attribute", "attribute*", "attribute-*"].includes(ruleName)) {
        temp = ruleName;
        return true;
      }

      return false;
    })) {
      allAttribRules.forEach(function (ruleName) {
        res[ruleName] = opts[temp];
      });
    }

    if (Object.keys(opts).some(function (ruleName) {
      if (["css", "css*", "css-*"].includes(ruleName)) {
        temp = ruleName;
        return true;
      }

      return false;
    })) {
      allCSSRules.forEach(function (ruleName) {
        res[ruleName] = opts[temp];
      });
    }

    if (Object.keys(opts).includes("bad-html-entity")) {
      allBadNamedHTMLEntityRules.forEach(function (ruleName) {
        // whole group of rules, not necessarily starting with "bad-html-entity"
        // will be added. Currently it's the list:
        //  * bad-named-html-entity-malformed-nbsp
        //  * bad-named-html-entity-malformed-*
        //  * bad-named-html-entity-unrecognised
        //  * bad-named-html-entity-multiple-encoding
        //  * bad-malformed-numeric-character-entity
        //  * encoded-html-entity-nbsp
        //  * encoded-numeric-html-entity-reference
        res[ruleName] = opts["bad-html-entity"];
      });
    } // then, a-la Object.assign the rest


    Object.keys(opts).forEach(function (ruleName) {
      if (!["all", "tag", "tag*", "tag-*", "attribute", "attribute*", "attribute-*", "bad-character", "bad-character", "bad-character*", "bad-character-*", "bad-html-entity"].includes(ruleName)) {
        // now, it depends is an exact rule name being queried or is it wildcard
        if (Object.keys(builtInRules).includes(ruleName)) {
          res[ruleName] = lodash_clonedeep(opts[ruleName]);
        } else if (ruleName.includes("*")) {
          Object.keys(builtInRules).forEach(function (builtInRule) {
            if (matcher.isMatch(builtInRule, ruleName)) {
              res[builtInRule] = lodash_clonedeep(opts[ruleName]);
            }
          });
        } // TODO - else clause error messaging - rule is configured but not available

      }
    });
  }
  return res;
}

TypedEmitter.defaultMaxListeners = 0;
/**
 * Pluggable email template code linter
 */

var Linter = /*#__PURE__*/function (_TypedEmitter) {
  _inheritsLoose(Linter, _TypedEmitter);

  function Linter() {
    var _this;

    _this = _TypedEmitter.call(this) || this;
    _this.messages = [];
    _this.str = "";
    _this.strLineStartIndexes = [];
    _this.config = {};
    _this.hasBeenCalledWithKeepSeparateWhenFixing = false;
    _this.processedRulesConfig = {};
    return _this;
  }

  var _proto = Linter.prototype;

  _proto.verify = function verify(str, config) {
    var _this2 = this;

    this.messages = [];
    this.str = str; // calculate line start indexes for row/column
    // reporting later, it allows line-column-mini to cut corners

    this.strLineStartIndexes = getLineStartIndexes(str);
    this.config = lodash_clonedeep(config);
    this.hasBeenCalledWithKeepSeparateWhenFixing = false;
    this.processedRulesConfig = {};
    var has = Object.prototype.hasOwnProperty; // VALIDATION FIRST

    if (config) {
      if (typeof config !== "object") {
        throw new Error("emlint/verify(): [THROW_ID_01] second input argument, config is not a plain object but " + typeof config + ". It's equal to:\n" + JSON.stringify(config, null, 4));
      } else if (!Object.keys(config).length) {
        // empty config => early return
        return [];
      } else if (!config.rules || typeof config.rules !== "object") {
        throw new Error("emlint/verify(): [THROW_ID_02] config contains no rules! It was given as:\n" + JSON.stringify(config, null, 4));
      }
    } else {
      // falsey config => early return
      return [];
    } // detect the language
    // const lang = detectLanguage(str);
    // filter out all applicable values and make them listen for events that
    // tokenizer emits
    // TODO - rebase, avoid using const, assign directly to "this."


    var processedRulesConfig = normaliseRequestedRules(config.rules);
    this.processedRulesConfig = processedRulesConfig;
    Object.keys(processedRulesConfig) // filter out the rules coming from external packages - they'll be
    // processed separately, in the callbacks coming out of external packages,
    // see the section "rules coming from standalone packages".
    .filter(function (ruleName) {
      return get(ruleName);
    }) // filter out enabled rules:
    .filter(function (ruleName) {
      // same config like in ESLint - 0 is off, 1 is warning, 2 is error
      if (typeof processedRulesConfig[ruleName] === "number") {
        return processedRulesConfig[ruleName] > 0;
      }

      if (Array.isArray(processedRulesConfig[ruleName])) {
        return processedRulesConfig[ruleName][0] > 0;
      }

      return false;
    }).forEach(function (rule) { // extract all the options, second array element onwards - the length is indeterminable

      var rulesFunction;

      if (Array.isArray(processedRulesConfig[rule]) && processedRulesConfig[rule].length > 1) {
        // pass not only "this", the context, but also all the opts, as args
        rulesFunction = get(rule).apply(void 0, [_this2].concat(processedRulesConfig[rule].slice(1)));
      } else {
        // just pass "this", the context
        rulesFunction = get(rule)(_this2);
      }

      Object.keys(rulesFunction).forEach(function (consumedNode) {
        _this2.on(consumedNode, function () {
          var _rulesFunction;

          // console.log(
          //   `106 ${`\u001b[${32}m${`linter.js`}\u001b[${39}m`}: ${`\u001b[${33}m${`consumedNode`}\u001b[${39}m`} = ${JSON.stringify(
          //     consumedNode,
          //     null,
          //     4
          //   )}`
          // );
          (_rulesFunction = rulesFunction)[consumedNode].apply(_rulesFunction, arguments);
        });
      });
    }); // emlint runs on codsen-parser which in turn runs on codsen-tokenizer.
    // Tokenizer recognises string as various token types and "pings" the
    // callback function given to the tokenizer with those lumps, plain objects.
    // Now, Parser consumes those tokens and assembles a tree, an AST.
    // EMLint is plugin-based. Plugins work on code source - consuming either
    // raw tokens, each token of particular kind, listening to event emitted
    // called after that token type, or plugins consume whole AST, listening
    // to "ast"-type event.
    // Now, the less work done the faster program runs.
    // The quickest way for emlint to obtain tokens is from codsen-parser,
    // to tap them raw, bypassing the AST tree, as they come from tokenizer.
    // But the problem is, this approach does not work with broken code.
    // We can't consume tokenizer's nodes because parser can change the
    // nodes, correcting the errors - it's possible because parser "sees" the
    // whole picture.
    // Therefore, we don't consume tokens from the tokenizer, we consume AST
    // from parser, then we send the monkey (ast-monkey-traverse) to traverse
    // that AST and emit the token events.

    this.emit("ast", traverse(cparser(str, {
      charCb: function charCb(obj) {
        // We call the character-level callback from raw characters, coming
        // if from parser which comes straight from tokenizer.
        // console.log(
        //   `160 ██ ${`\u001b[${35}m${`linter/charCb():`}\u001b[${39}m`} incoming ${`\u001b[${33}m${`obj`}\u001b[${39}m`} = ${JSON.stringify(
        //     obj,
        //     null,
        //     4
        //   )}`
        // );
        _this2.emit("character", obj);
      },
      errCb: function errCb(obj) { // check, is rule enabled at the first place:

        var currentRulesSeverity = isAnEnabledRule(config.rules, obj.ruleId);

        if (currentRulesSeverity) {
          var message = "Something is wrong.";

          if (isObj(obj) && typeof obj.ruleId === "string" && has.call(astErrMessages, obj.ruleId)) {
            message = astErrMessages[obj.ruleId];
          }

          _this2.report(_objectSpread2({
            message: message,
            severity: currentRulesSeverity,
            fix: null
          }, obj));
        }
      }
    }), function (key, val, innerObj) {
      var current = val !== undefined ? val : key;

      if (isObj(current) && (!innerObj.parentKey || !innerObj.parentKey.startsWith("attrib"))) {
        // console.log(` `);
        // console.log(
        //   `-----------------------------------------------------------------------------`
        // );
        // console.log(` `);
        // console.log(
        //   `275 ${`\u001b[${33}m${`██`}\u001b[${39}m`} ${`\u001b[${33}m${`innerObj`}\u001b[${39}m`} = ${JSON.stringify(
        //     innerObj,
        //     null,
        //     4
        //   )}`
        // );
        // monkey will traverse every key, every string within.
        // We need to pick the objects of a type we need: "tag", "comment" etc.
        // tag-level callback
        // console.log(
        //   `286 ██ ${`\u001b[${35}m${`linter/tagCb():`}\u001b[${39}m`} PING ${
        //     current.type
        //   } - ${`\u001b[${33}m${`current`}\u001b[${39}m`} = ${JSON.stringify(
        //     current,
        //     null,
        //     4
        //   )}`
        // );
        _this2.emit(current.type, current); // plus, for type:html also ping each attribute


        if (current.type === "tag" && Array.isArray(current.attribs) && current.attribs.length) {
          current.attribs.forEach(function (attribObj) {

            _this2.emit("attribute", _objectSpread2(_objectSpread2({}, attribObj), {}, {
              parent: _objectSpread2({}, current)
            }));
          });
        }
      }

      return current;
    })); //
    //
    //
    //
    //
    //
    //                rules coming from standalone packages
    //
    //
    //
    //
    //
    //
    // 1. if any of bad named HTML entity catcher rules is requested, run it

    if (Object.keys(config.rules).some(function (ruleName) {
      return (ruleName === "all" || // group blanket setting
      ruleName === "bad-html-entity" || // group blanket setting
      ruleName.startsWith("bad-html-entity") || ruleName.startsWith("bad-named-html-entity") || matcher.isMatch(["bad-malformed-numeric-character-entity"], ruleName)) && (isAnEnabledValue(config.rules[ruleName]) || isAnEnabledValue(processedRulesConfig[ruleName]));
    })) {
      fixEnt(str, {
        cb: function cb(obj) { // evaluate, does the config have this emitted rule set and enabled

          var matchedRulesName = ""; // A severity value can be under array's first element or as digit,
          // plus rule itself might be group rule ("bad-html-entity") or
          // mentioned directly.
          // The plan is to try to extract severity various ways, later if it's
          // set, then report the error.

          var severity; // rule is group, blanket rule

          if (Object.keys(config.rules).includes("bad-html-entity")) {
            if (obj.ruleName === "bad-named-html-entity-unrecognised") {
              // unrecongnised named HTML entities might be false positives,
              // mix of ampersand, letters and semicolon, without spaces,
              // so default level is "warning", not "error":
              severity = 1;
            } else if (Array.isArray(config.rules["bad-html-entity"])) {
              severity = config.rules["bad-html-entity"][0];
            } else if (Number.isInteger(config.rules["bad-html-entity"])) {
              severity = config.rules["bad-html-entity"];
            }
          } else if (Object.keys(config.rules).some(function (rulesName) {

            if (matcher.isMatch(obj.ruleName, rulesName)) {
              matchedRulesName = rulesName;
              return true;
            }

            return false;
          })) {
            if (obj.ruleName === "bad-named-html-entity-unrecognised" && config.rules["bad-named-html-entity-unrecognised"] === undefined) {
              // unless the rule was requested exactly, severity is 1.
              // This applies to both group blanket rules "bad-html-entity" and
              // any rules achieved by applying wildcards, for example,
              // "bad-named-html-entity-*".
              severity = 1;
            } else if (Array.isArray(config.rules[matchedRulesName])) {
              severity = config.rules[matchedRulesName][0];
            } else if (Number.isInteger(config.rules[matchedRulesName])) {
              severity = config.rules[matchedRulesName];
            }
          }

          if (Number.isInteger(severity)) {
            var message;

            if (obj.ruleName === "bad-named-html-entity-malformed-nbsp") {
              message = "Malformed NBSP entity.";
            } else if (obj.ruleName === "bad-named-html-entity-unrecognised") {
              message = "Unrecognised named entity.";
            } else if (obj.ruleName === "bad-named-html-entity-multiple-encoding") {
              message = "HTML entity encoding over and over.";
            } else if (obj.ruleName === "bad-malformed-numeric-character-entity") {
              message = "Malformed numeric entity.";
            } else {
              message = "Malformed " + (obj.entityName ? obj.entityName : "named") + " entity.";
            }

            var ranges = [[obj.rangeFrom, obj.rangeTo, obj.rangeValEncoded ? obj.rangeValEncoded : ""]];

            if (obj.ruleName === "bad-named-html-entity-unrecognised") {
              ranges = [];
            }

            _this2.report({
              severity: severity,
              ruleId: obj.ruleName,
              message: message,
              idxFrom: obj.rangeFrom,
              idxTo: obj.rangeTo,
              fix: {
                ranges: ranges
              }
            });
          }
        },
        entityCatcherCb: function entityCatcherCb(from, to) {

          _this2.emit("entity", {
            idxFrom: from,
            idxTo: to
          });
        }
      });
    } // remove all listeners
    // extract all keys from the events interface


    var allEventNames = ["tag", "at", "rule", "text", "esp", "character", "attribute", "ast", "comment", "entity"];
    allEventNames.forEach(function (eventName) {
      _this2.removeAllListeners(eventName);
    });
    return lodash_clonedeep(this.messages);
  };

  _proto.report = function report(obj) { // fill in other data points:

    var _lineCol = lineCol(this.strLineStartIndexes, obj.idxFrom, true),
        line = _lineCol.line,
        col = _lineCol.col;

    var severity = obj.severity || 0; // rules coming from 3rd party packages will give the severity value

    if (!Number.isInteger(obj.severity) && typeof this.processedRulesConfig[obj.ruleId] === "number") {
      severity = this.processedRulesConfig[obj.ruleId];
    } else if (!Number.isInteger(obj.severity) && Array.isArray(this.processedRulesConfig[obj.ruleId])) {
      severity = this.processedRulesConfig[obj.ruleId][0];
    }
    this.messages.push(_objectSpread2(_objectSpread2({
      fix: null,
      keepSeparateWhenFixing: false,
      line: line,
      column: col,
      severity: severity
    }, obj), this.hasBeenCalledWithKeepSeparateWhenFixing ? {
      fix: null
    } : {})); // After pushing, let's manage "keepSeparateWhenFixing" messages -
    // make a note of the first incoming message with "keepSeparateWhenFixing"
    // key, in order to remove "fix" values from all other incoming messages
    // with "keepSeparateWhenFixing" key. That's necessary to support certain
    // fixes composition.

    if (obj.keepSeparateWhenFixing && !this.hasBeenCalledWithKeepSeparateWhenFixing && obj.fix) {
      this.hasBeenCalledWithKeepSeparateWhenFixing = true;
    }
  };

  return Linter;
}(TypedEmitter);

var version$1 = "4.4.0";

var version = version$1;

exports.Linter = Linter;
exports.util = util;
exports.version = version;

Object.defineProperty(exports, '__esModule', { value: true });

})));
