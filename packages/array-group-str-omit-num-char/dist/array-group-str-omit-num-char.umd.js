/**
 * @name array-group-str-omit-num-char
 * @fileoverview Groups array of strings by omitting number characters
 * @version 5.0.5
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/array-group-str-omit-num-char/}
 */

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).arrayGroupStrOmitNumChar={})}(this,(function(e){"use strict";var t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},r="__lodash_hash_undefined__",n="[object Function]",o="[object GeneratorFunction]",i=/^\[object .+?Constructor\]$/,s="object"==typeof self&&self&&self.Object===Object&&self,a="object"==typeof t&&t&&t.Object===Object&&t||s||Function("return this")();function l(e,t){return!!(e?e.length:0)&&function(e,t,r){if(t!=t)return function(e,t,r,n){var o=e.length,i=r+(n?1:-1);for(;n?i--:++i<o;)if(t(e[i],i,e))return i;return-1}(e,f,r);var n=r-1,o=e.length;for(;++n<o;)if(e[n]===t)return n;return-1}(e,t,0)>-1}function u(e,t,r){for(var n=-1,o=e?e.length:0;++n<o;)if(r(t,e[n]))return!0;return!1}function f(e){return e!=e}function c(e,t){return e.has(t)}function h(e){var t=-1,r=Array(e.size);return e.forEach((function(e){r[++t]=e})),r}var p,g=Array.prototype,y=Function.prototype,d=Object.prototype,_=a["__core-js_shared__"],m=(p=/[^.]+$/.exec(_&&_.keys&&_.keys.IE_PROTO||""))?"Symbol(src)_1."+p:"",w=y.toString,T=d.hasOwnProperty,b=d.toString,v=RegExp("^"+w.call(T).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),W=g.splice,O=C(a,"Map"),$=C(a,"Set"),R=C(Object,"create");function I(e){var t=-1,r=e?e.length:0;for(this.clear();++t<r;){var n=e[t];this.set(n[0],n[1])}}function E(e){var t=-1,r=e?e.length:0;for(this.clear();++t<r;){var n=e[t];this.set(n[0],n[1])}}function j(e){var t=-1,r=e?e.length:0;for(this.clear();++t<r;){var n=e[t];this.set(n[0],n[1])}}function A(e){var t=-1,r=e?e.length:0;for(this.__data__=new j;++t<r;)this.add(e[t])}function F(e,t){for(var r,n,o=e.length;o--;)if((r=e[o][0])===(n=t)||r!=r&&n!=n)return o;return-1}function N(e){if(!J(e)||(t=e,m&&m in t))return!1;var t,r=function(e){var t=J(e)?b.call(e):"";return t==n||t==o}(e)||function(e){var t=!1;if(null!=e&&"function"!=typeof e.toString)try{t=!!(e+"")}catch(e){}return t}(e)?v:i;return r.test(function(e){if(null!=e){try{return w.call(e)}catch(e){}try{return e+""}catch(e){}}return""}(e))}I.prototype.clear=function(){this.__data__=R?R(null):{}},I.prototype.delete=function(e){return this.has(e)&&delete this.__data__[e]},I.prototype.get=function(e){var t=this.__data__;if(R){var n=t[e];return n===r?void 0:n}return T.call(t,e)?t[e]:void 0},I.prototype.has=function(e){var t=this.__data__;return R?void 0!==t[e]:T.call(t,e)},I.prototype.set=function(e,t){return this.__data__[e]=R&&void 0===t?r:t,this},E.prototype.clear=function(){this.__data__=[]},E.prototype.delete=function(e){var t=this.__data__,r=F(t,e);return!(r<0)&&(r==t.length-1?t.pop():W.call(t,r,1),!0)},E.prototype.get=function(e){var t=this.__data__,r=F(t,e);return r<0?void 0:t[r][1]},E.prototype.has=function(e){return F(this.__data__,e)>-1},E.prototype.set=function(e,t){var r=this.__data__,n=F(r,e);return n<0?r.push([e,t]):r[n][1]=t,this},j.prototype.clear=function(){this.__data__={hash:new I,map:new(O||E),string:new I}},j.prototype.delete=function(e){return H(this,e).delete(e)},j.prototype.get=function(e){return H(this,e).get(e)},j.prototype.has=function(e){return H(this,e).has(e)},j.prototype.set=function(e,t){return H(this,e).set(e,t),this},A.prototype.add=A.prototype.push=function(e){return this.__data__.set(e,r),this},A.prototype.has=function(e){return this.__data__.has(e)};var S=$&&1/h(new $([,-0]))[1]==1/0?function(e){return new $(e)}:function(){};function H(e,t){var r,n,o=e.__data__;return("string"==(n=typeof(r=t))||"number"==n||"symbol"==n||"boolean"==n?"__proto__"!==r:null===r)?o["string"==typeof t?"string":"hash"]:o.map}function C(e,t){var r=function(e,t){return null==e?void 0:e[t]}(e,t);return N(r)?r:void 0}function J(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}var x=function(e){return e&&e.length?function(e,t,r){var n=-1,o=l,i=e.length,s=!0,a=[],f=a;if(r)s=!1,o=u;else if(i>=200){var p=t?null:S(e);if(p)return h(p);s=!1,o=c,f=new A}else f=t?[]:a;e:for(;++n<i;){var g=e[n],y=t?t(g):g;if(g=r||0!==g?g:0,s&&y==y){for(var d=f.length;d--;)if(f[d]===y)continue e;t&&f.push(y),a.push(g)}else o(f,y,r)||(f!==a&&f.push(y),a.push(g))}return a}(e):[]};
/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 5.0.5
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */const D={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function M(e,t){if(!Array.isArray(e)||!e.length)return e;const r={...D,...t};let n,o;if(r.strictlyTwoElementsInRangeArrays&&!e.filter((e=>e)).every(((e,t)=>2===e.length||(n=t,o=e.length,!1))))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${n}th range (${JSON.stringify(e[n],null,4)}) has not two but ${o} elements!`);if(!e.filter((e=>e)).every(((e,t)=>!(!Number.isInteger(e[0])||e[0]<0||!Number.isInteger(e[1])||e[1]<0)||(n=t,!1))))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${n}th range (${JSON.stringify(e[n],null,4)}) does not consist of only natural numbers!`);const i=e.filter((e=>e)).length**2;let s=0;return Array.from(e).filter((e=>e)).sort(((e,t)=>(r.progressFn&&(s+=1,r.progressFn(Math.floor(100*s/i))),e[0]===t[0]?e[1]<t[1]?-1:e[1]>t[1]?1:0:e[0]<t[0]?-1:1)))}
/**
 * @name ranges-merge
 * @fileoverview Merge and sort string index ranges
 * @version 8.0.5
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-merge/}
 */const q={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function P(e,t){function r(e){return e&&"object"==typeof e&&!Array.isArray(e)}if(!Array.isArray(e)||!e.length)return null;let n;if(t){if(!r(t))throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:\n${JSON.stringify(t,null,4)} (type ${typeof t})`);if(n={...q,...t},n.progressFn&&r(n.progressFn)&&!Object.keys(n.progressFn).length)n.progressFn=null;else if(n.progressFn&&"function"!=typeof n.progressFn)throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof n.progressFn}", equal to ${JSON.stringify(n.progressFn,null,4)}`);if(n.mergeType&&1!=+n.mergeType&&2!=+n.mergeType)throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof n.mergeType}", equal to ${JSON.stringify(n.mergeType,null,4)}`);if("boolean"!=typeof n.joinRangesThatTouchEdges)throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof n.joinRangesThatTouchEdges}", equal to ${JSON.stringify(n.joinRangesThatTouchEdges,null,4)}`)}else n={...q};const o=e.filter((e=>e)).map((e=>[...e])).filter((e=>void 0!==e[2]||e[0]!==e[1]));let i,s,a;if(i=n.progressFn?M(o,{progressFn:e=>{a=Math.floor(e/5),a!==s&&(s=a,n.progressFn(a))}}):M(o),!i)return null;const l=i.length-1;for(let e=l;e>0;e--)n.progressFn&&(a=Math.floor(78*(1-e/l))+21,a!==s&&a>s&&(s=a,n.progressFn(a))),(i[e][0]<=i[e-1][0]||!n.joinRangesThatTouchEdges&&i[e][0]<i[e-1][1]||n.joinRangesThatTouchEdges&&i[e][0]<=i[e-1][1])&&(i[e-1][0]=Math.min(i[e][0],i[e-1][0]),i[e-1][1]=Math.max(i[e][1],i[e-1][1]),void 0!==i[e][2]&&(i[e-1][0]>=i[e][0]||i[e-1][1]<=i[e][1])&&null!==i[e-1][2]&&(null===i[e][2]&&null!==i[e-1][2]?i[e-1][2]=null:null!=i[e-1][2]?2==+n.mergeType&&i[e-1][0]===i[e][0]?i[e-1][2]=i[e][2]:i[e-1][2]+=i[e][2]:i[e-1][2]=i[e][2]),i.splice(e,1),e=i.length);return i.length?i:null}
/**
 * @name ranges-apply
 * @fileoverview Take an array of string index ranges, delete/replace the string according to them
 * @version 6.0.5
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-apply/}
 */const k={wildcard:"*",dedupePlease:!0};e.groupStr=function(e,t){if(!Array.isArray(e))return e;if(!e.length)return{};const r={...k,...t},n=r.dedupePlease?x(e):Array.from(e),o={};for(let e=0,t=n.length;e<t;e++){const t=n[e].match(/\d+/gm);if(t){const i=n[e].replace(/\d+/gm,r.wildcard);Object.prototype.hasOwnProperty.call(o,i)?(t.forEach(((e,t)=>{o[i].elementsWhichWeCanReplaceWithWildcards[t]&&e!==o[i].elementsWhichWeCanReplaceWithWildcards[t]&&(o[i].elementsWhichWeCanReplaceWithWildcards[t]=!1)})),o[i].count+=1):o[i]={count:1,elementsWhichWeCanReplaceWithWildcards:Array.from(t)}}else o[n[e]]={count:1}}const i={};return Object.keys(o).forEach((e=>{let t=e;if(Array.isArray(o[e].elementsWhichWeCanReplaceWithWildcards)&&o[e].elementsWhichWeCanReplaceWithWildcards.some((e=>!1!==e))){const n=[];let i=0;for(let s=0;s<o[e].elementsWhichWeCanReplaceWithWildcards.length;s++)i=t.indexOf(`${r.wildcard||""}`,i+(r.wildcard||"").length),!1!==o[e].elementsWhichWeCanReplaceWithWildcards[s]&&n.push([i,i+(r.wildcard||"").length,o[e].elementsWhichWeCanReplaceWithWildcards[s]]);t=function(e,t,r){let n,o=0,i=0;if(0===arguments.length)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if("string"!=typeof e)throw new TypeError(`ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ${typeof e}, equal to: ${JSON.stringify(e,null,4)}`);if(t&&!Array.isArray(t))throw new TypeError(`ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ${typeof t}, equal to: ${JSON.stringify(t,null,4)}`);if(r&&"function"!=typeof r)throw new TypeError(`ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ${typeof r}, equal to: ${JSON.stringify(r,null,4)}`);if(!t||!t.filter((e=>e)).length)return e;n=Array.isArray(t)&&Number.isInteger(t[0])&&Number.isInteger(t[1])?[Array.from(t)]:Array.from(t);const s=n.length;let a=0;n.filter((e=>e)).forEach(((e,t)=>{if(r&&(o=Math.floor(a/s*10),o!==i&&(i=o,r(o))),!Array.isArray(e))throw new TypeError(`ranges-apply: [THROW_ID_05] ranges array, second input arg., has ${t}th element not an array: ${JSON.stringify(e,null,4)}, which is ${typeof e}`);if(!Number.isInteger(e[0])){if(!Number.isInteger(+e[0])||+e[0]<0)throw new TypeError(`ranges-apply: [THROW_ID_06] ranges array, second input arg. has ${t}th element, array ${JSON.stringify(e,null,0)}. Its first element is not an integer, string index, but ${typeof e[0]}, equal to: ${JSON.stringify(e[0],null,4)}.`);n[t][0]=+n[t][0]}if(!Number.isInteger(e[1])){if(!Number.isInteger(+e[1])||+e[1]<0)throw new TypeError(`ranges-apply: [THROW_ID_07] ranges array, second input arg. has ${t}th element, array ${JSON.stringify(e,null,0)}. Its second element is not an integer, string index, but ${typeof e[1]}, equal to: ${JSON.stringify(e[1],null,4)}.`);n[t][1]=+n[t][1]}a+=1}));const l=P(n,{progressFn:e=>{r&&(o=10+Math.floor(e/10),o!==i&&(i=o,r(o)))}}),u=Array.isArray(l)?l.length:0;if(u>0){const t=e.slice(l[u-1][1]);e=l.reduce(((t,n,s,a)=>(r&&(o=20+Math.floor(s/u*80),o!==i&&(i=o,r(o))),t+e.slice(0===s?0:a[s-1][1],a[s][0])+(a[s][2]||""))),""),e+=t}return e}(t,n)}i[t]=o[e].count})),i},e.version="5.0.5",Object.defineProperty(e,"__esModule",{value:!0})}));
