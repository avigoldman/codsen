{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n&#x7D; from \"json-comb-core\";\n\n// STEP #1\n// =======\n\n// calculate the schema - superset of all possible keys used across\n// all JSON files\nconst schema = getKeysetSync([\n  &#x7B;\n    // <- object #1\n    a: \"a\",\n    b: \"c\",\n    c: &#x7B;\n      d: \"d\",\n      e: \"e\",\n    &#x7D;,\n  &#x7D;,\n  &#x7B;\n    // <- object #2\n    a: \"a\",\n  &#x7D;,\n  &#x7B;\n    // <- object #3\n    c: &#x7B;\n      f: \"f\",\n    &#x7D;,\n  &#x7D;,\n]);\n\nassert.deepEqual(schema, &#x7B;\n  a: false,\n  b: false,\n  c: &#x7B;\n    d: false,\n    e: false,\n    f: false,\n  &#x7D;,\n&#x7D;);\n\n// STEP #2\n// =======\n\n// now we can normalise the object #2 for example:\nassert.deepEqual(\n  enforceKeysetSync(\n    &#x7B;\n      // <- object #2\n      a: \"a\",\n    &#x7D;,\n    schema\n  ),\n  &#x7B;\n    a: \"a\",\n    b: false,\n    c: &#x7B;\n      d: false,\n      e: false,\n      f: false,\n    &#x7D;,\n  &#x7D;\n);"},"enforceKeyset.js":{"title":"Asynchronous `enforceKeyset()`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n&#x7D; from \"json-comb-core\";\n\n// Let's enforce the keyset using previously-calculated schema.\n\n// Let's use an async IIFE to trigger the action and let us use await:\n(async () => &#x7B;\n  // let's create three plain objects, each somewhat overlapping with others:\n  const obj1 = &#x7B;\n    b: [\n      &#x7B;\n        c: \"ccc\",\n        d: \"ddd\",\n      &#x7D;,\n    ],\n    a: \"aaa\",\n  &#x7D;;\n  const obj2 = &#x7B;\n    a: \"ccc\",\n    e: \"eee\",\n  &#x7D;;\n  const obj3 = &#x7B;\n    a: \"zzz\",\n  &#x7D;;\n  // calculate the schema:\n  const schema = await getKeyset([obj1, obj2, obj3]);\n\n  assert.deepEqual(schema, &#x7B;\n    a: false,\n    b: [\n      &#x7B;\n        c: false,\n        d: false,\n      &#x7D;,\n    ],\n    e: false,\n  &#x7D;);\n\n  assert.deepEqual(await enforceKeyset(obj1, schema), &#x7B;\n    a: \"aaa\",\n    b: [\n      &#x7B;\n        c: \"ccc\",\n        d: \"ddd\",\n      &#x7D;,\n    ],\n    e: false, // <------ new key added\n  &#x7D;);\n\n  assert.deepEqual(await enforceKeyset(obj2, schema), &#x7B;\n    a: \"ccc\",\n    b: [\n      // <------- new key added\n      &#x7B;\n        c: false,\n        d: false,\n      &#x7D;,\n    ],\n    e: \"eee\",\n  &#x7D;);\n\n  assert.deepEqual(await enforceKeyset(obj3, schema), &#x7B;\n    a: \"zzz\",\n    b: [\n      // <------- new key added\n      &#x7B;\n        c: false,\n        d: false,\n      &#x7D;,\n    ],\n    e: false, // <------- new key added\n  &#x7D;);\n&#x7D;)();"},"enforceKeysetSync.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n&#x7D; from \"json-comb-core\";\n\nconst schema = &#x7B;\n  a: false,\n  b: false,\n  c: &#x7B;\n    d: false,\n    e: false,\n    f: false,\n  &#x7D;,\n&#x7D;;\n\nassert.deepEqual(\n  enforceKeysetSync(\n    &#x7B;\n      c: &#x7B; d: \"x\" &#x7D;,\n    &#x7D;,\n    schema\n  ),\n  &#x7B;\n    a: false,\n    b: false,\n    c: &#x7B;\n      d: \"x\",\n      e: false,\n      f: false,\n    &#x7D;,\n  &#x7D;\n);"},"findUnusedSync-2.js":{"title":"Synchronous `findUnusedSync()` - example #2","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n&#x7D; from \"json-comb-core\";\n\n// This function will work on arrays of both normalised and not normalised object sets.\nassert.deepEqual(\n  findUnusedSync([\n    &#x7B;\n      a: [\n        &#x7B;\n          k: false,\n          l: false,\n          m: false,\n        &#x7D;,\n        &#x7B;\n          k: \"k\",\n          l: false,\n          m: \"m\",\n        &#x7D;,\n      ],\n      b: \"bbb1\",\n      c: false,\n    &#x7D;,\n    &#x7B;\n      a: [\n        &#x7B;\n          k: \"k\",\n          l: false,\n          m: \"m\",\n        &#x7D;,\n        &#x7B;\n          k: \"k\",\n          l: false,\n          m: \"m\",\n        &#x7D;,\n      ],\n      b: \"bbb2\",\n      c: false,\n    &#x7D;,\n    &#x7B; b: false &#x7D;,\n    &#x7B; c: false &#x7D;,\n  ]),\n  [\"c\", \"a[0].l\"]\n);"},"findUnusedSync.js":{"title":"Synchronous `findUnusedSync()` - example #1","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n&#x7D; from \"json-comb-core\";\n\nassert.deepEqual(\n  findUnusedSync([\n    &#x7B;\n      // <- object #1\n      a: false,\n      b: \"bbb1\",\n      c: false,\n    &#x7D;,\n    &#x7B;\n      // <- object #2\n      a: \"aaa\",\n      b: \"bbb2\",\n      c: false,\n    &#x7D;,\n    &#x7B;&#x7D;, // <- object #3\n  ]),\n  [\"c\"]\n);"},"getKeyset.js":{"title":"Asynchronous `getKeyset()`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n&#x7D; from \"json-comb-core\";\n\n// Let's calculate the schema of the following arrays of plain objects,\n// and do it asynchronously.\n\n// Let's use an async IIFE to trigger the action and let us use await:\n(async () => &#x7B;\n  // First, prepare array of promises:\n  const source = [\n    &#x7B;\n      a: \"a\",\n      b: \"c\",\n      c: &#x7B;\n        d: \"d\",\n        e: \"e\",\n      &#x7D;,\n    &#x7D;,\n    &#x7B;\n      a: \"a\",\n    &#x7D;,\n    &#x7B;\n      c: &#x7B;\n        f: \"f\",\n      &#x7D;,\n    &#x7D;,\n  ].map((el) => Promise.resolve(el));\n\n  // use async/await to avoid using .then\n  assert.deepEqual(await getKeyset(source), &#x7B;\n    a: false,\n    b: false,\n    c: &#x7B;\n      d: false,\n      e: false,\n      f: false,\n    &#x7D;,\n  &#x7D;);\n&#x7D;)();"},"getKeysetSync.js":{"title":"Synchronous `getKeysetSync()`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n&#x7D; from \"json-comb-core\";\n\nconst schema = getKeysetSync([\n  &#x7B;\n    // <- object #1\n    a: \"a\",\n    b: \"c\",\n    c: &#x7B;\n      d: \"d\",\n      e: \"e\",\n    &#x7D;,\n  &#x7D;,\n  &#x7B;\n    // <- object #2\n    a: \"a\",\n  &#x7D;,\n  &#x7B;\n    // <- object #3\n    c: &#x7B;\n      f: \"f\",\n    &#x7D;,\n  &#x7D;,\n]);\n\nassert.deepEqual(schema, &#x7B;\n  a: false,\n  b: false,\n  c: &#x7B;\n    d: false,\n    e: false,\n    f: false,\n  &#x7D;,\n&#x7D;);"},"noNewKeys-2.js":{"title":"Synchronous `noNewKeysSync()` - example #2","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n&#x7D; from \"json-comb-core\";\n\nassert.deepEqual(\n  noNewKeysSync(\n    &#x7B;\n      // <- input we're checking\n      z: [\n        &#x7B;\n          a: \"a\",\n          b: \"b\",\n          c: \"c\",\n        &#x7D;,\n        &#x7B;\n          a: false,\n          b: false,\n          c: \"c\",\n        &#x7D;,\n      ],\n    &#x7D;,\n    &#x7B;\n      // <- reference keyset\n      z: [\n        &#x7B;\n          a: \"a\",\n          b: \"b\",\n        &#x7D;,\n        &#x7B;\n          a: false,\n          b: false,\n        &#x7D;,\n      ],\n    &#x7D;\n  ),\n  [\"z[0].c\", \"z[1].c\"]\n);"},"noNewKeys.js":{"title":"Synchronous `noNewKeysSync()` - example #1","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n&#x7D; from \"json-comb-core\";\n\n// We are going to catch the rogue key `b`:\n\nassert.deepEqual(\n  noNewKeysSync(\n    &#x7B;\n      // <- input we're checking\n      a: \"a\",\n      b: \"b\",\n      c: \"c\",\n    &#x7D;,\n    &#x7B;\n      // <- reference keyset\n      a: \"aaa\",\n      c: \"ccc\",\n    &#x7D;\n  ),\n  [\"b\"] // list of rogue paths\n);"},"sortAllObjectsSync.js":{"title":"Synchronous `getKeysetSync()`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n&#x7D; from \"json-comb-core\";\n\nassert.deepEqual(\n  sortAllObjectsSync(&#x7B;\n    a: \"a\",\n    c: \"c\",\n    b: \"b\",\n  &#x7D;),\n  &#x7B;\n    a: \"a\",\n    b: \"b\",\n    c: \"c\",\n  &#x7D;\n);"}}