{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; fixEnt &#x7D; from \"string-fix-broken-named-entities\";\nimport &#x7B; rApply &#x7D; from \"ranges-apply\";\n\nconst source = \"&nsp;x&nsp;y&nsp;\";\n\n// returns Ranges notation, see codsen.com/ranges/\nassert.deepEqual(fixEnt(source), [\n  [0, 5, \"&nbsp;\"],\n  [6, 11, \"&nbsp;\"],\n  [12, 17, \"&nbsp;\"],\n]);\n\n// render result from ranges using \"ranges-apply\":\nassert.equal(rApply(source, fixEnt(source)), \"&nbsp;x&nbsp;y&nbsp;\");"},"sift-raw-ampersands-from-entities.js":{"title":"Sift raw ampersands in a string from broken character references","content":"// encode those raw ampersands and fix broken character references\n\nimport &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; fixEnt &#x7D; from \"string-fix-broken-named-entities\";\nimport &#x7B; rApply &#x7D; from \"ranges-apply\";\n\nconst source = \"&&nsp;&&nsp;&\";\n\nconst finalRanges = [];\nconst indexesOfRawAmpersands = [];\n\n// fixEnt() returns Ranges (see codsen.com/ranges/)\nconst resultRanges = fixEnt(source, &#x7B;\n  textAmpersandCatcherCb: (idx) => indexesOfRawAmpersands.push(idx),\n&#x7D;);\n\n// check the ranges - all broken NBSP's were fixed:\nassert.deepEqual(resultRanges, [\n  [1, 6, \"&nbsp;\"],\n  [7, 12, \"&nbsp;\"],\n]);\n\n// don't apply the ranges yet, dump them into the \"finalRanges\" array\n// it's because applying them onto a string,\n// rApply(source, resultRanges);\n// will mess up the index positions, we'll need to calculate again.\n// The whole point of Ranges is they're COMPOSABLE.\n\nresultRanges.forEach((range) => &#x7B;\n  finalRanges.push(range);\n&#x7D;);\n\n// check the positions of reported raw ampersands:\nassert.deepEqual(indexesOfRawAmpersands, [0, 6, 12]);\n\n// replace each character at these positions: 0, 6 and 12\n// with string \"&amp;\" - in terms of Ranges, it's a matter\n// of building a Ranges array:\nconst replacementRanges = indexesOfRawAmpersands.map((idx) => [\n  idx,\n  idx + 1,\n  \"&amp;\",\n]);\n// this is Ranges notation, array of arrays: [from index, to index, what-to-replace]\nassert.deepEqual(replacementRanges, [\n  [0, 1, \"&amp;\"], // we're saying, replace indexes from 0 to 1 with &amp;\n  [6, 7, \"&amp;\"],\n  [12, 13, \"&amp;\"],\n]);\n\n// push them into resultRanges as well:\nreplacementRanges.forEach((range) => &#x7B;\n  resultRanges.push(range);\n&#x7D;);\n\n// check what's been gathered so far:\nassert.deepEqual(resultRanges, [\n  [1, 6, \"&nbsp;\"],\n  [7, 12, \"&nbsp;\"],\n  [0, 1, \"&amp;\"],\n  [6, 7, \"&amp;\"],\n  [12, 13, \"&amp;\"],\n]);\n\n// apply Ranges onto a string - all amendments at once!\nconst finalResultStr = rApply(source, resultRanges);\n\n// check result\nassert.equal(finalResultStr, \"&amp;&nbsp;&amp;&nbsp;&amp;\");\n\n// Voil√†! We fixed broken entities and encoded raw ampersands"}}